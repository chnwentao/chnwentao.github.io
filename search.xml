<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[文本特征选择方法和特征权重计算方法]]></title>
      <url>/2017/11/NLP/NLP-%20%E6%96%87%E6%9C%AC%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E6%96%B9%E6%B3%95%E5%92%8C%E7%89%B9%E5%BE%81%E6%9D%83%E9%87%8D%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>介绍了一下文本特征 提取的常用的方法，实际上这个是2月份写的博客，但是当时放在工作总结了，没有单独提出去。</p>
<a id="more"></a>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="什么是文本分类："><a href="#什么是文本分类：" class="headerlink" title="什么是文本分类："></a>什么是文本分类：</h3><p>再预定的分类体系下，根据文本的特征，将给定文本与一个或多个类别相关联。</p>
<h3 id="什么是文本表示："><a href="#什么是文本表示：" class="headerlink" title="什么是文本表示："></a>什么是文本表示：</h3><p>将文本翻译成机器可以理解或处理的形式. 也就是从 文本 —&gt; 特征集合</p>
<h3 id="什么是理想的文本表示（特征）"><a href="#什么是理想的文本表示（特征）" class="headerlink" title="什么是理想的文本表示（特征）?"></a>什么是理想的文本表示（特征）?</h3><ul>
<li><p>可以真实的反应文档的内容（向量空间就丢失了语序，和上下文 ）</p>
</li>
<li><p>对不同文档有区分能力 (ID 不能作为特征)</p>
</li>
</ul>
<h3 id="特征征选择-amp-特征权重计算"><a href="#特征征选择-amp-特征权重计算" class="headerlink" title="特征征选择 &amp; 特征权重计算"></a>特征征选择 &amp; 特征权重计算</h3><p>特征选择阶段的重要程度量化和将具体文本转化为向量时的特征权重量化。</p>
<p>权重代表的是差别</p>
<p>问题：</p>
<p>一个方法既适用于 特征征选择  也 特征权重计算 吗？ TF—IDF</p>
<h2 id="特征选择方法"><a href="#特征选择方法" class="headerlink" title="特征选择方法"></a>特征选择方法</h2><h2 id="词频方法（Word-Frequency）："><a href="#词频方法（Word-Frequency）：" class="headerlink" title="词频方法（Word Frequency）："></a>词频方法（Word Frequency）：</h2><p>词频是一个词在文档中出现的次数。</p>
<p>通过词频进行特征选择就是将词频小于某一闭值的词删除，从而降低特征空间的维数。</p>
<p>这个方法是基于这样一个假设，即出现频率小的词对过滤的影响也较小。但是在信息检索的研究中认为，有时频率小的词含有更多的信息。因此，在特征选择的过程中不宜简单地根据词频大幅度删词。</p>
<h3 id="文档频数-DF"><a href="#文档频数-DF" class="headerlink" title="文档频数 DF"></a>文档频数 DF</h3><p>原理：</p>
<ul>
<li><p>所用文档中统计包含某个特征的文档的频率，然后卡一个上下阀值。</p>
</li>
<li><p>频率太低的， 没有代表性 (稀有词要么不含有用信息,要么太少而不足以对分类产生影响,要么是噪音,所以可以删去。)</p>
</li>
<li><p>频率太高，没有区分度</p>
</li>
</ul>
<p>优点：</p>
<ul>
<li><p>速度快,它的时间复杂度和文本数量成线性关系,所以非常适合于超大规模文本数据集的特征选择。</p>
</li>
<li><p>文档频数还非常地高效,在有监督的特征选择应用中当删除90%单词的时候其性能与信息增益和x2 统计的性能还不相上下。</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li><strong>稀有词</strong>可能在某一类文本中并不稀有,也可能包含着重要的判断信息,简单舍弃,可能影响分类器的精度。</li>
</ul>
<h3 id="信息增益方法-Information-Gain"><a href="#信息增益方法-Information-Gain" class="headerlink" title="信息增益方法 (Information Gain)"></a>信息增益方法 (Information Gain)</h3><p>基础：</p>
<p>信息量 ：一个变量可能的变化越多（反而跟变量具体的取值没有任何关系，只和值的种类多少以及发生概率有关），它携带的信息量就越大。</p>
<p>信息量越大， 不确定性越小。</p>
<p>不足：</p>
<p>信息息增益最大的问题还在于它只能考察特征对整个系统的贡献，而不能具体到某个类别上，这就使得它只适合用来做所谓“全局”的特征选择（指所有的类都使用相同的特征集合），而无法做“本地”的特征选择（每个类别有自己的特征集合，因为有的词，对这个类别很有区分度，对另一个类别则无足轻重）。</p>
<p>数据稀疏问题：许多信息增益高的特征出现频率比较低, 这样会引起数据稀疏问题，影响分类。</p>
<p>考虑了单词未发生的情况，对判断文本类别贡献不大，而且引入不必要的干扰，特别是在处理类分布和特征值分布高度不平衡的数据时选择精度下降。</p>
<p>参考：</p>
<p><a href="http://www.blogjava.net/zhenandaci/archive/2009/03/24/261701.html" target="_blank" rel="noopener">文本分类入门（十一）特征选择方法之信息增益</a></p>
<h3 id="卡方统计量-CHI"><a href="#卡方统计量-CHI" class="headerlink" title="卡方统计量 CHI"></a>卡方统计量 CHI</h3><p>基础：</p>
<p>开方检验:最基本的思想就是通过观察实际值与理论值的偏差来确定理论的正确与否。</p>
<p>零假设（null hypothesis） : 变量相互独立</p>
<p>临界值: 置信度为0.999的卡方临界值是10.83，也就是当卡方值&gt;10.83时，我们有99.9%的把握，t与c不独立，</p>
<p>原理：</p>
<p>一个词t（一个随机变量）与一个类别c（另一个随机变量）之间是否相互独立？如果独立，就可以说词t对类别c完全没有表征作用，即我们根本无法根据t出现与否来判断一篇文档是否属于c这个分类。</p>
<p>方法：</p>
<p>原假设: 词t与类别c不相关</p>
<p>备则假设：特征词与类别有着很高的关联度。</p>
<p>计算出的开方值越大，说明对原假设的偏离越大</p>
<p>多分类问题的情况：</p>
<p>对每个类别分别计算 CHI 取 max</p>
<p>不足：</p>
<p>低频词缺陷: 统计文档中是否出现词t，却不管t在该文档中出现了几次，这会使得他对低频词有所偏袒（因为它夸大了低频词的作用）。</p>
<p>特征提取步骤</p>
<p>1.1  统计样本集中文档总数（N）。</p>
<p>1.2  统计每个词的正文档出现频率（A）、负文档出现频率（B）、正文档不出现频率C 、负文档不出现频率D。</p>
<p>1.3 计算每个词的卡方值，公式如下： <code>N * （A*D - B*C）** 2 / ((A + C) * (A + B) * (C + D))</code></p>
<p>1.4  将每个词按卡方值从大到小排序，选取前k个词作为特征，k即特征维数。</p>
<h3 id="互信息-Mutual-Information"><a href="#互信息-Mutual-Information" class="headerlink" title="互信息(Mutual Information)"></a>互信息(Mutual Information)</h3><p>思想 ：</p>
<p>MI度量的是词的存在与否给类别c带来的信息量</p>
<p>互相信息越大，特征 t 和 类别 C 共现 程度越大。</p>
<p>果某个词项均匀的分布在各个类别，那么I(U;C)=0I(U;C)=0，当某词项总是出现在当前类别，而在其他类别中很少出现时，I(U;C)I(U;C)就会比较大。使用互信息能够保留具有信息含量的词项的同时，去掉那些没有信息含量的词项，从而提高正确率。</p>
<p>互信息计算的时间复杂度类似于信息增益，互信息的平均值就是信息增益。</p>
<p>不足：</p>
<p>没有考虑特征出现的频率，这样导致互信息评估函数不选择高频的有用词而有可能选择<strong>稀有词</strong>作为文本的最佳特征。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>英文文本中, 作为特征选择方法时，开方检验和信息增益的效果最佳（相同的分类算法，使用不同的特征选择算法来得到比较结果）；文档频率方法的性能同前两者大体相当，术语强度方法性能一般；互信息方法的性能最差 (Yiming Yang,Jan O Pedersen:A comparative Study on Feature Selection in Text Categorization, Proceedings of the Fourteenth International Conference on Machine Learning(ICML~97)，l997 )</p>
<h2 id="特征权重计算"><a href="#特征权重计算" class="headerlink" title="特征权重计算"></a>特征权重计算</h2><p>CHI、TFIDF既可以作为特征选取也可以作为权重计算的方法，不同之处在于TFIDF可以用于任意文本集合，而CHI则需要文本有分类标签的标记才能计算。</p>
<p>问题：</p>
<h2 id="布尔特征，"><a href="#布尔特征，" class="headerlink" title="布尔特征，"></a>布尔特征，</h2><p>最原始的， 出现于不出现 0 1</p>
<p>无法提前特征的作用程度</p>
<h2 id="TF"><a href="#TF" class="headerlink" title="TF"></a>TF</h2><p>特征词在这篇文档中的权重</p>
<p>无法提现低频特征的区分能力</p>
<h3 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h3><p>假设： 对区别文档最有意义的词语应该是那些在文档中出现频率高，而在整个文档集合的其他文档中出现频率少的词语，所以如果特征空间坐标系取TF词频作为测度，就可以体现同类文本的特点。</p>
<p>思想： 信息论，是在某个特定情况下，是词语分布与文档分布的KL距离。</p>
<p>TF: 指该特征词在这篇文档中的词频</p>
<p>IDF ： <code>idf (term) = log ( N / N_term + 1 )</code></p>
<p>如果一个词越常见，那么分母就越大，逆文档频率就越小越接近0。</p>
<p>分母之所以要加1，是为了避免分母为0（即所有文档都不包含该词）。log表示对得到的值取对数。</p>
<p>缺点:</p>
<ul>
<li><p>单纯以”词频”衡量一个词的重要性，不够全面，有时重要的词可能出现次数并不多</p>
</li>
<li><p>这种算法无法体现词的位置信息，出现位置靠前的词与出现位置靠后的词，都被视为重要性相同，这是不正确的。（一种解决方法是，对全文的第一段和每一段的第一句话，给予较大的权重。）</p>
</li>
</ul>
<h3 id="TF-IDF-于多分类"><a href="#TF-IDF-于多分类" class="headerlink" title="TF-IDF 于多分类"></a>TF-IDF 于多分类</h3><p>文本分类问题更复杂一些，因为除了词语、文档这两个原有的维度，又多了一个文档类别的维度。</p>
<p>改进的idf计算： <code>idf (term) = log ( N * M / N_term )</code></p>
<p>其中M是当前类别中包含词语term的文档数——这个要与最终计算的词语对该类别的权重成正比。</p>
<h3 id="TFC-amp-ITC-amp-TF-IWF"><a href="#TFC-amp-ITC-amp-TF-IWF" class="headerlink" title="TFC &amp; ITC &amp; TF-IWF"></a>TFC &amp; ITC &amp; TF-IWF</h3><p><code>TF*IDF</code>权重没有考虑不同的文本长度对词权重的影响。</p>
<p>TFC权重算法与 <code>TF*IDF</code> 权重算法的唯一不同在于前者对于文本长度进行了归一化处理。</p>
<p>ITC权重与TFC权重的不同在于使用词频的log值代替了词频，从而减少了词频对权重的影响</p>
<p>TF-IWF ：在TF-IDF算法的基础上，用特征项频率倒数的对数值IWF代替IDF，并且用IWF的平方平衡权重值对于特征项频率的倚重。</p>
]]></content>
      
        <categories>
            
            <category> NLP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 文本处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CNN在自然语言处理中的使用]]></title>
      <url>/2017/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CNN%20%E5%9C%A8%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>CNN 在自然语言中的使用<br>施工中 ing</p>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/liuchonge/article/details/67638232" target="_blank" rel="noopener">CNN与句子分类之动态池化方法DCNN–模型介绍篇 - CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30268946" target="_blank" rel="noopener">从CNN视角看在自然语言处理上的应用</a></li>
<li><a href="http://www.jeyzhang.com/cnn-apply-on-modelling-sentence.html" target="_blank" rel="noopener">卷积神经网络(CNN)在句子建模上的应用 | Jey Zhang</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NLP </tag>
            
            <tag> CNN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习读书笔记-CNN基础]]></title>
      <url>/2017/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_CNN/</url>
      <content type="html"><![CDATA[<p>个人对基础的 CNN 的知识点的理解很梳理，梳理脉络是依据 Bengio 的 深度学习的第九章。</p>
<p>施工中 ing</p>
<a id="more"></a>
<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><h3 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h3><p><img src="http://7xiuu0.com1.z0.glb.clouddn.com/17-11-25/57838136.jpg" alt="经典卷积动图"></p>
<p>卷积的本质：是加权叠加/积分</p>
<h3 id="动机-特点"><a href="#动机-特点" class="headerlink" title="动机/ 特点"></a>动机/ 特点</h3><h4 id="稀疏交互"><a href="#稀疏交互" class="headerlink" title="稀疏交互"></a>稀疏交互</h4><p>传统神经网络:使用 矩阵乘法建立 输入输出的连接关系 –&gt; 参数矩阵 w 中每个参数 == 一个input 与一个 output 的 互交</p>
<p>卷积网络 : 通过卷积 –&gt; 参数更少（稀疏 权重） –&gt; 更少的计算代价</p>
<p>我们可以理解为：CNN 可以看作是 DNN 的一种简化形式.</p>
<p>这种情况带来以下的特点：</p>
<ul>
<li><p>卷积网络 相邻的两层，一个输入只能影响(连接)少量的输出（如图:CNN_1）：<br><img src="http://7xiuu0.com1.z0.glb.clouddn.com/17-11-25/60238378.jpg" alt=""></p>
</li>
<li><p>但是通过多层，深层的单元可以间接的连接到全部或大部分的输入（如图:CNN_2）：<br><img src="http://7xiuu0.com1.z0.glb.clouddn.com/17-11-25/52654500.jpg" alt=""></p>
</li>
</ul>
<h4 id="参数共享-parameter-sharing"><a href="#参数共享-parameter-sharing" class="headerlink" title="参数共享(parameter sharing)"></a>参数共享(parameter sharing)</h4><p>一个 Convolution Kernel 在与 Input 不同区域做卷积时，它的参数是固定不变的。<br>这是它具有以下两个性质：</p>
<ul>
<li><p>参数共享 –&gt; 卷积在存储需求和统计效率方面极大地优于稠密矩阵的乘法运算。</p>
</li>
<li><p>其实 每一个 Convolution Kernel 卷积后得到的会是原图的某些特征（如边缘信息），所以在 CNN 中，Convolution Kernel 卷积得到的 Layer 称作 Feature Map</p>
</li>
</ul>
<h4 id="等变表示"><a href="#等变表示" class="headerlink" title="等变表示"></a>等变表示</h4><p>参数共享 –&gt; 使得神经网络层具有对平移 等变(equivariance) 的性质:</p>
<pre><code>- 对时间序列：如果我们把输入中的一个事件向后延时，在输出中仍然 会有完全相同的表示，只是时间延后了。
- 对图像：可以识别图像中的某种特定曲线(特征)，
</code></pre><p>卷积对其他的一些变换并不是天然等变的，例如对于图像的放缩或者旋转变换， 需要其他的一些机制来处理这些变换。（比如使用另外几个核 在上下的方向上滑动，然后通过 pooling 筛选）</p>
<h2 id="池化（pooling）"><a href="#池化（pooling）" class="headerlink" title="池化（pooling）"></a>池化（pooling）</h2><p>注意池化与卷积的区别：<br><img src="http://7xiuu0.com1.z0.glb.clouddn.com/17-11-25/64190326.jpg" alt=""></p>
<p>Pooling 的本质，其实是采样。</p>
<p>池化的意义：</p>
<ul>
<li><p>显而易见，就是减少参数。通过对 Feature Map 降维，有效减少后续层需要的参数</p>
</li>
<li><p>当输入做出少量平移的时候，池化可以帮助输入的表示近似不变形。（局部平移不变性）<br>  -池化的局部平移不变性 带来的好处: 非常适合 我们关心某个特征是否出现而不关系出现位置的时候 – 人脸识别</p>
</li>
<li><p>对处理不同大小的输入具有重要的意义：-可以通过调整池化区域的偏置，使分类层具有具有固定大小的输入</p>
<ul>
<li>论文见：ECCV2014  <a href="https://arxiv.org/abs/1406.4729" target="_blank" rel="noopener">[1406.4729] Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition</a></li>
</ul>
</li>
</ul>
<p>池化相当于增加的一个很强的先验： 的每一个单元都具有对少量的平移的不变性，</p>
<p>这带了以下的问题，也就是使用池化要注意的地方：</p>
<ul>
<li><p>卷积和池化可能导致欠拟合</p>
</li>
<li><p>不适合依赖精确的空间信息的任务，这种任务使用池化会增大训练误差。</p>
</li>
<li><p>如何任务要对输入中相隔很远的信息进行合并的时候，卷积就无能为力了。</p>
</li>
</ul>
<h2 id="基本卷积函数的变种"><a href="#基本卷积函数的变种" class="headerlink" title="基本卷积函数的变种"></a>基本卷积函数的变种</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.zhihu.com/question/49376084" target="_blank" rel="noopener">(82 条消息)如何理解卷积神经网络（CNN）中的卷积和池化？ - 知乎</a></li>
<li><a href="http://www.hackcv.com/index.php/archives/104/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">[翻译] 神经网络的直观解释 博客 | HackCV</a></li>
<li><a href="http://dataunion.org/11692.html" target="_blank" rel="noopener">技术向：一文读懂卷积神经网络CNN | 数盟社区</a></li>
<li><a href="http://blog.csdn.net/zhangjunhit/article/details/53909548" target="_blank" rel="noopener">SPP-Net 是怎么让 CNN 实现输入任意尺寸图像的？ - CSDN博客</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CNN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据预处理_数据归一_标准化]]></title>
      <url>/2017/11/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/DM-%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86_%E6%95%B0%E6%8D%AE%E5%BD%92%E4%B8%80_%E6%A0%87%E5%87%86%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>数据标准化主要功能之一，就是消除变量间的量纲关系，从而使数据具有可比性。</p>
<p>怎么去做数据变换？什么时候需要做什么样的数据变换？</p>
<p>对不同的数据和需求要使用不同的数据变换方法，这个取决于你数据的分布和希望保留的信息，因为 <strong>数据的变换必然导致数据特性的改变</strong>。所以我们做选择的时候要特别的小心。</p>
<h3 id="简单函数变换"><a href="#简单函数变换" class="headerlink" title="简单函数变换"></a>简单函数变换</h3><p>这个有很多， 常有的有 <code>x^k, 1/x , log（x）, e^x, sin X, |x|</code>， 他们（特别是平方根，对数，倒数）大多是将不具备高斯分布的数据变换为具有高斯分布的数据。</p>
<p>但是每种变换都有不同的特性，这个要十分的小心！</p>
<h4 id="倒数-1-x"><a href="#倒数-1-x" class="headerlink" title="倒数 1 / x"></a>倒数 <code>1 / x</code></h4><p>注意： 压缩了 &gt; 1 的值，却放大 &lt; 1 的值</p>
<h4 id="对数-log-x"><a href="#对数-log-x" class="headerlink" title="对数 log(x)"></a>对数 <code>log(x)</code></h4><p>对 [1, ++ ] 数据越大  压缩越厉害, e.g.  np.log10(100) == 2 , np.log10(1000) ==  3</p>
<p>特点：</p>
<ul>
<li>使服从对数正态分布的资料正态化；</li>
<li>使方差不齐且各组的接近的资料达到方差齐的要求；</li>
<li>使曲线直线化，常用于曲线拟合。</li>
</ul>
<h3 id="标准化-规范化"><a href="#标准化-规范化" class="headerlink" title="标准化/ 规范化"></a>标准化/ 规范化</h3><p>这两者在数据挖掘上是没有区别的，但是统计学术语上是有差异的，这个要注意。<br>标准化 使用与组合多个来源的变量的时候， 可以避免较大的值域影响计算结果，即消除变量值域的影响,</p>
<h4 id="Z-score标准化"><a href="#Z-score标准化" class="headerlink" title="Z-score标准化"></a>Z-score标准化</h4><p>这种标准化的前提是特征值服从正态分布，标准化后，其转换成标准正态分布(均值0 标准差差1)。也就是说这种变换适合分布为正态分布的数据.</p>
<p>适用：</p>
<p>缺点： 受离群点影响很大，改进：使用 中位数代替均值， 使用绝对标准差 取代标准差<br>公式：</p>
<p>$$ \frac{x - \bar{x}}{ S}$$</p>
<p>其中 S 是标准差</p>
<p>sklearn：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line"><span class="meta">... </span>                    [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line"><span class="meta">... </span>                    [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled = preprocessing.scale(X_train)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled</span><br><span class="line">array([[ <span class="number">0.</span>  ..., <span class="number">-1.22</span>...,  <span class="number">1.33</span>...],</span><br><span class="line">       [ <span class="number">1.22</span>...,  <span class="number">0.</span>  ..., <span class="number">-0.26</span>...],</span><br><span class="line">       [<span class="number">-1.22</span>...,  <span class="number">1.22</span>..., <span class="number">-1.06</span>...]])</span><br></pre></td></tr></table></figure>
<h4 id="min-max标准化（区间缩放法）"><a href="#min-max标准化（区间缩放法）" class="headerlink" title="min-max标准化（区间缩放法）"></a>min-max标准化（区间缩放法）</h4><p>区间缩放法利用了边界值信息，将特征的取值区间缩放到某个特点的范围，例如[0, 1]等。</p>
<p>这种方式通常在(1) 特征的标准差较小 (2) 可以使稀疏数据集中的0值继续为0，这两种情况下使用。</p>
<p>缺点： 这种方法有个缺陷就是当有新数据加入时，可能导致max和min的变化，需要重新定义。</p>
<p>公式：$[\frac{x - min}{ max - min}]$</p>
<p>sklearn：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line"><span class="meta">... </span>                    [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line"><span class="meta">... </span>                    [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min_max_scaler = preprocessing.MinMaxScaler()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train_minmax = min_max_scaler.fit_transform(X_train)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train_minmax</span><br><span class="line">array([[ <span class="number">0.5</span>       ,  <span class="number">0.</span>        ,  <span class="number">1.</span>        ],</span><br><span class="line">       [ <span class="number">1.</span>        ,  <span class="number">0.5</span>       ,  <span class="number">0.33333333</span>],</span><br><span class="line">       [ <span class="number">0.</span>        ,  <span class="number">1.</span>        ,  <span class="number">0.</span>        ]])</span><br></pre></td></tr></table></figure>
<h3 id="QuantileTransformer"><a href="#QuantileTransformer" class="headerlink" title="QuantileTransformer"></a>QuantileTransformer</h3><ol>
<li>preprocessing.QuantileTransformer()，将数据映射到[0,1]之间均匀分布，会破坏原数据之间的相关特性。</li>
</ol>
<h4 id="其他常用的标准方法："><a href="#其他常用的标准方法：" class="headerlink" title="其他常用的标准方法："></a>其他常用的标准方法：</h4><ul>
<li>decimal scaling</li>
</ul>
<h3 id="各种数据变换方法特点对比"><a href="#各种数据变换方法特点对比" class="headerlink" title="各种数据变换方法特点对比"></a>各种数据变换方法特点对比</h3><table>
<thead>
<tr>
<th style="text-align:right">数据变换方法</th>
<th style="text-align:left">有无量纲</th>
<th style="text-align:left">变换后数据分布特点</th>
<th style="text-align:left">计算特点</th>
<th style="text-align:left">方法特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">中心化变换</td>
<td style="text-align:left">有</td>
<td style="text-align:left">变量均值为0</td>
<td style="text-align:left">每列数据平方和是该列变量样本方差的(n-1)倍</td>
<td style="text-align:left">方便地计算方差与协方差的变换</td>
</tr>
<tr>
<td style="text-align:right">min-max标准化</td>
<td style="text-align:left">无</td>
<td style="text-align:left">每个变量的最大数值为1，最小数值为0，其余数据取值均在0－1之间</td>
<td style="text-align:left"></td>
<td style="text-align:left">便于不同的变量之间的比较</td>
</tr>
<tr>
<td style="text-align:right">Z-score标准化</td>
<td style="text-align:left">无</td>
<td style="text-align:left">每个变量即数据矩阵中每列数据的平均值为0，方差为1</td>
<td style="text-align:left">任何两列数据乘积之和是两个变量相关系数的（n－1）倍</td>
<td style="text-align:left">是一种很方便地计算相关矩阵的变换</td>
</tr>
<tr>
<td style="text-align:right">log变换</td>
<td style="text-align:left">有</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">使曲线直线化，常用于曲线拟合</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/jasonfreak/p/5448385.html" target="_blank" rel="noopener">使用sklearn做单机特征工程 - jasonfreak - 博客园</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_78874e890101e134.html" target="_blank" rel="noopener">不同数据变换处理及其特点_昵称真难起_新浪博客</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 数据挖掘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DM </tag>
            
            <tag> 数据预处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chrome 常用插件]]></title>
      <url>/2017/10/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-chrome-%E6%8F%92%E4%BB%B6%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<p>自己常用 + 觉不错的插件</p>
<p>不断更新ing<br><a id="more"></a></p>
<h3 id="Copy-as-Markdown："><a href="#Copy-as-Markdown：" class="headerlink" title="Copy as Markdown："></a>Copy as Markdown：</h3><p>对于经常用Markdown写文档的人来说，复制网页链接之后还要插入到<a href=""></a>里，实在麻烦。Copying Link, Image and Tab(s) as Markdown：<a href="https://github.com/chitsaou/copy-as-markdown解决这个头疼的问题。" target="_blank" rel="noopener">https://github.com/chitsaou/copy-as-markdown解决这个头疼的问题。</a></p>
<h3 id="Json-Viewer"><a href="#Json-Viewer" class="headerlink" title="Json Viewer"></a>Json Viewer</h3><p>在浏览器上返回的Json文件，如果没有格式化太难看清其结构，利用Json Viewer：<a href="https://github.com/tulios/json-viewer插件，就明了多了。" target="_blank" rel="noopener">https://github.com/tulios/json-viewer插件，就明了多了。</a></p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> chrome </tag>
            
            <tag> 插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RecNN vs RNN in NLP]]></title>
      <url>/2017/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_RecNN_vs_RNN_inNLP/</url>
      <content type="html"><![CDATA[<p>主要是依据 Yoav  17年的新书 NNM for NLP 的 18 章 的内容。</p>
<p>可以说是NNM for NLP的 读书笔记 ，不过自己会慢慢扩充<a id="more"></a></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li>1990 Pollack 提出 RecNN</li>
<li>2010 开始 流行与 NLP 领域</li>
</ul>
<h2 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h2><p>作者认为：RecNN is a generalization of the RNN from sequences to (binary) trees.</p>
<h2 id="RecNN-及一些变种"><a href="#RecNN-及一些变种" class="headerlink" title="RecNN 及一些变种"></a>RecNN 及一些变种</h2><h3 id="base-RecNN"><a href="#base-RecNN" class="headerlink" title="base RecNN"></a>base RecNN</h3><p>递归神经网络按照语言的树结构来构造网络结构的，其中每个节点都可以使用向量进行表示。</p>
<p><img src="./001.jpg" alt=""></p>
<p>其中c1和c2分别是两个子节点向量，p是父节点向量，W是权重矩阵，b是偏置向量。</p>
<p>这里面需要<strong>注意</strong>的是，对于树中不同的组合节点，都使用<strong>同一套参数</strong>，即W和b进行组合。(显然是不合理，因为节点的性质不同，如不同的词性、短语类型等，组合方式必然是不一样的。)</p>
<h3 id="SU-RNN（Syntactically-Untied-RNN）by-Socher-et-al-2013a"><a href="#SU-RNN（Syntactically-Untied-RNN）by-Socher-et-al-2013a" class="headerlink" title="SU-RNN（Syntactically-Untied RNN）by  [Socher et al. 2013a]"></a>SU-RNN（Syntactically-Untied RNN）by  [Socher et al. 2013a]</h3><p>基于上述问题：</p>
<p>SU-RNN对<strong>不同类型的组合节点</strong>使用不同的组合参数，如ADJ与NN组合时，使用WADJ-NN。</p>
<p>但是，相同的节点类型也未必可以共享同一套组合参数，如同样是形容词，“好”和“坏”与其它词在组合时，获得的结果应该是不同的。</p>
<h3 id="MV-RNN-recursive-matrix-vector-model-Socher-et-al-2012"><a href="#MV-RNN-recursive-matrix-vector-model-Socher-et-al-2012" class="headerlink" title="MV-RNN(recursive matrix-vector model) [Socher et al., 2012]"></a>MV-RNN(recursive matrix-vector model) [Socher et al., 2012]</h3><p>基于上述问题：</p>
<p>MV-RNN将不同体现在<strong>每个节点</strong>上，而非不同种类的节点上。</p>
<p>它认为，每个节点除了需要使用向量表示外，还需要使用一个矩阵来表示，其中向量表示节点自身的属性，而矩阵则表示其在组合时，对另一个节点的操作。</p>
<p>例如，“好”与“人”组合的结果是“好人”，它仍然是一种“人”，只是属性发生了一些改变，可以通过将“好”的矩阵与“人”的向量相乘获得“好人”的向量。</p>
<p>但是， MV-RNN对每个节点除赋予一个向量外，还需要赋予一个矩阵，使需要学习的参数过多，所以往往学习的并不充分。</p>
<h3 id="RNTN（Recursive-Neural-Tensor-Networks）-Socher-et-al-2013"><a href="#RNTN（Recursive-Neural-Tensor-Networks）-Socher-et-al-2013" class="headerlink" title="RNTN（Recursive Neural Tensor Networks）[ Socher et al., 2013]"></a>RNTN（Recursive Neural Tensor Networks）[ Socher et al., 2013]</h3><p>基于上述问题：</p>
<p>socher 提出使用张量（Tensor）来表示组合参数。</p>
<p>通过张量，既可以减少所需学习的参数,提示学习效果 (粒度情感分析任务上  MV-RNN44.4%的准确率，提升到45.7%)</p>
<h3 id="Tree-shaped-LSTMs-Tai-et-al-2015-Zhu-et-al-2015b"><a href="#Tree-shaped-LSTMs-Tai-et-al-2015-Zhu-et-al-2015b" class="headerlink" title="Tree-shaped LSTMs [Tai et al., 2015, Zhu et al., 2015b]"></a>Tree-shaped LSTMs [Tai et al., 2015, Zhu et al., 2015b]</h3><p>RecNN suffer from the vanishing gradients problem of the Simple RNN。(梯度消失问题)</p>
<p>所以，Tai  将序列的LSTM模型扩展到树结构上。</p>
<h3 id="作者自己的研究-Kiperwasser-and-Goldberg-2016a"><a href="#作者自己的研究-Kiperwasser-and-Goldberg-2016a" class="headerlink" title="作者自己的研究 [Kiperwasser and Goldberg, 2016a]"></a>作者自己的研究 [Kiperwasser and Goldberg, 2016a]</h3><p>we propose a tree encoder that is not restricted to binary trees but instead can work with arbitrary branching trees.</p>
<h2 id="RecNN-与-sequence-level-RNN-对比-（树结构是否有效？）"><a href="#RecNN-与-sequence-level-RNN-对比-（树结构是否有效？）" class="headerlink" title="RecNN 与 sequence-level RNN 对比 （树结构是否有效？）"></a>RecNN 与 sequence-level RNN 对比 （树结构是否有效？）</h2><p>参考 Jiwei Li 在2015年ACL上发了一篇“When Are Tree Structures Necessary for Deep Learning of Representations?”</p>
<p>很悲剧的发现，除语义关系分类(semantic relation classification)任务外，在其它任务中，序列模型都取得了比树结构模型更好的结果。</p>
<p>甚至 ：Bowman等人（2015） 研究结果甚至一定程度上证明，序列模型（LSTM）能够发现隐含的树结构</p>
<p>我认为：</p>
<pre><code>- 树结构 相当于使用先验知识构造特征集，在小数据的情况是有效的
- 树结构天生对长程依赖的问题(或较长文本)更加合适
</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>A SIMPLE ALTERNATIVE–LINEARIZED TREES<br>  linearizing trees into linear sequence that is then fed into a gated RNN acceptor (or a biRNN encoder)</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjAzNDY5Mg==&amp;mid=209300177&amp;idx=1&amp;sn=4d24467ee27da15ae05effaa0ded9332&amp;scene=2&amp;srcid=1015LyJAMxAtArMzdyKyIRHh&amp;from=timeline&amp;isappinstalled=0#rd" target="_blank" rel="noopener">哈工大车万翔：自然语言处理中的深度学习模型是否依赖于树结构？</a></p>
</li>
<li><p><a href="None">Jiwei Li 在2015年ACL上发了一篇“When Are Tree Structures Necessary for Deep Learning of Representations?”</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/39034550" target="_blank" rel="noopener">句法分析 (syntactic parsing) 在 NLP 领域的应用是怎样的？</a></p>
</li>
<li><p><a href="https://zh.wikipedia.org/wiki/递归神经网络" target="_blank" rel="noopener">wiki 递归神经网络 </a></p>
</li>
</ul>
<p>-<a href="https://wugh.github.io/posts/2016/05/cs224d-notes5-recusive-neural-networks/" target="_blank" rel="noopener">CS224d笔记5——递归神经网络（Recusive Neural Network, RNN）</a></p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NLP </tag>
            
            <tag> RNN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RNN  and encoder-decoder in NLP]]></title>
      <url>/2017/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_RNN_encoder_decoder_inNLP/</url>
      <content type="html"><![CDATA[<p>主要是依据 Yoav  17年的新书 NNM for NLP 的 16 章 的内容。</p>
<p>可以说是NNM for NLP 的读书笔记 ，不过自己会慢慢扩充  <a id="more"></a></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>又叫做 Sequence to Sequence learning。</p>
<p>所谓编码，就是将输入序列转化成一个固定长度的向量；解码，就是将之前生成的固定向量再转化成输出序列。</p>
<h2 id="Sequence-to-Sequence"><a href="#Sequence-to-Sequence" class="headerlink" title="Sequence to Sequence"></a>Sequence to Sequence</h2><p>注意:</p>
<ul>
<li>sequence to sequence conditioned generation framework, also called the encoder-decoder framework</li>
</ul>
<h3 id="RNN-generation"><a href="#RNN-generation" class="headerlink" title="RNN generation"></a>RNN generation</h3><p><img src="./RNN_encoder_decoder/001.jpg" alt=""></p>
<p>比较易于理解，只要端到端训练RNN（LSTM）网络就可以了，在每一个句子末尾打上一个end-of-sentence symbol， EOS符号，用输入句子来预测输出句子。</p>
<p>相比 ngram language models, RNN 可以捕获 ：</p>
<ul>
<li>line lengths</li>
<li>nested parenthesis balancing.</li>
</ul>
<h3 id="condition-generation"><a href="#condition-generation" class="headerlink" title="condition generation"></a>condition generation</h3><p>直观的讲，相比 RNN generation  多了一个 conditioning context 的 向量 。</p>
<h4 id="What-kind-of-information-can-be-encoded-in-the-context-c"><a href="#What-kind-of-information-can-be-encoded-in-the-context-c" class="headerlink" title="What kind of information can be encoded in the context c?"></a>What kind of information can be encoded in the context c?</h4><p>这个就依据任务而定了：</p>
<ul>
<li>新闻的话，可以是相关主题</li>
<li>电影评论的话，可以是 电影评级，地区等等。</li>
</ul>
<h3 id="Sequence-to-Sequence-Encoder-Decoder"><a href="#Sequence-to-Sequence-Encoder-Decoder" class="headerlink" title="Sequence to Sequence  (Encoder-Decoder)"></a>Sequence to Sequence  (Encoder-Decoder)</h3><p>相比 Encoder-Decoder (condition generation) Models ， 他的<br>conditioning context C  表示的是一个序列</p>
<h4 id="常见的-conditioning-context"><a href="#常见的-conditioning-context" class="headerlink" title="常见的 conditioning context"></a>常见的 conditioning context</h4><ul>
<li>条件生成方法非常灵活，编码器不需要是RNN。</li>
<li>条件环境甚至不需要基于文本。</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>Machine Translation</li>
<li>Email Auto-response</li>
<li>Morphological Inflection</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h2 id="attention机制"><a href="#attention机制" class="headerlink" title="attention机制"></a>attention机制</h2><p>上面介绍的Sequence to Sequence 中编码器要将整个序列的信息压缩进一个固定长度的向量中去。但是这样做有两个弊端，一是语义向量无法完全表示整个序列的信息，还有就是先输入的内容携带的信息会被后输入的信息稀释掉，或者说，被覆盖了。输入序列越长，这个现象就越严重。</p>
<p>针对 这个问题 有人借用了图像领域中的  Attention机制。 下图是经典图：<br><a href="./RNN_encoder_decoder/001.jpg"></a></p>
<p>在我看到的文章中， Attention是一个权重vector（通常是softmax的输出），其维度等于context的长度。越大的权重代表对应位置的context越重要。</p>
<p>一个有趣的事情是：我们可以可视化attention矩阵来告诉大家神经网络在进行任务时关注了哪些部分。</p>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>199X ——2014  Attention机制最早是在视觉图像领域提出来的，应该是在九几年思想就提出来了，</p>
<p>2014 ：google mind团队的《Recurrent Models of Visual Attention》，他们在RNN模型上使用了attention机制来进行图像分类。</p>
<p>2014 Bahdanau et al. 《Neural Machine Translation by Jointly Learning to Align and Translate》 使用类似attention的机制在机器翻译任务上将翻译和对齐同时进行，他们的工作算是是第一个提出attention机制应用到NLP领域中。接着类似的基于attention机制的RNN模型扩展开始应用到各种NLP任务中。</p>
<p>2015 《ABCNN: Attention-Based Convolutional Neural Network for Modeling Sentence Pairs》 这篇论文就提出了3中在CNN中使用attention的方法，是attention在CNN中较早的探索性工作。</p>
<h3 id="Attention可以分成hard与soft两种模型"><a href="#Attention可以分成hard与soft两种模型" class="headerlink" title="Attention可以分成hard与soft两种模型:"></a>Attention可以分成hard与soft两种模型:</h3><p>hard: Attention每次移动到一个固定大小的区域</p>
<p>soft: Attention每次是所有区域的一个加权和</p>
<h3 id="性能的问题"><a href="#性能的问题" class="headerlink" title="性能的问题"></a>性能的问题</h3><p>他增加的模型的计算复杂度</p>
<p>不使用 attention 机制的时候 ：</p>
<pre><code>- the encoding is performed in linear time in the input length (O(n))
- the decoding is performed in linear time in the output length (O(m)).
</code></pre><p>使用  attention 机制 ：</p>
<pre><code>- encoding 不变
- the decoding is performed in linear time in the output length( O(m * n))
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/22081325" target="_blank" rel="noopener">RNN Encoder–Decoder的attention机制简介</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/36591394/answer/69124544?utm_campaign=webshare&amp;utm_source=weibo&amp;utm_medium=zhihu" target="_blank" rel="noopener">Attention based model 是什么，它解决了什么问题？</a></p>
</li>
<li><p><a href="http://blog.csdn.net/xbinworld/article/details/54605408" target="_blank" rel="noopener"> 深度学习方法（八）：自然语言处理中的Encoder-Decoder模型，基本Sequence to Sequence模型</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/robert-dlut/p/5952032.html" target="_blank" rel="noopener">注意力机制（Attention Mechanism）在自然语言处理中的应用</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NLP </tag>
            
            <tag> RNN </tag>
            
            <tag> RecNN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在分类中如何处理训练集中不平衡问题]]></title>
      <url>/2017/03/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/DM-%E5%9C%A8%E5%88%86%E7%B1%BB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%AE%AD%E7%BB%83%E9%9B%86%E4%B8%AD%E4%B8%8D%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="不平衡问题-及不平衡问题的危害"><a href="#不平衡问题-及不平衡问题的危害" class="headerlink" title="不平衡问题 及不平衡问题的危害"></a>不平衡问题 及不平衡问题的危害</h2><p>训练集中可能会存在某个或某些类别下的样本数远大于另一些类别下的样本数目。即类别不平衡，为了使得学习达到更好的效果，因此需要解决该类别不平衡问题。<br><a id="more"></a></p>
<ul>
<li><p>在一个二分类问题中，训练集中class 1的样本数比class 2的样本数是60:1。使用逻辑回归进行分类，最后结果是其忽略了class 2，即其将所有的训练样本都分类为class 1。</p>
</li>
<li><p>在分类任务的数据集中，有三个类别，分别为A，B，C。在训练集中，A类的样本占70%，B类的样本占25%，C类的样本占5%。最后我的分类器对类A的样本过拟合了，而对其它两个类别的样本欠拟合。</p>
</li>
</ul>
<h2 id="扩大数据集"><a href="#扩大数据集" class="headerlink" title="扩大数据集"></a>扩大数据集</h2><h2 id="对数据集进行重采样"><a href="#对数据集进行重采样" class="headerlink" title="对数据集进行重采样"></a>对数据集进行重采样</h2><p>对小类的数据样本进行采样来增加小类的数据样本个数，即过采样（over-sampling ，采样的个数大于该类样本的个数）。</p>
<p>对大类的数据样本进行采样来减少该类数据样本的个数，即欠采样（under-sampling，采样的次数少于该类样本的个素）。</p>
<p>一些经验法则：</p>
<ul>
<li>考虑对大类下的样本（超过1万、十万甚至更多）进行欠采样，即删除部分样本；</li>
<li>考虑对小类下的样本（不足1为甚至更少）进行过采样，即添加部分样本的副本；</li>
<li>考虑尝试随机采样与非随机采样两种采样方法；</li>
<li>考虑对各类别尝试不同的采样比例，比一定是1:1，有时候1:1反而不好，因为与现实情况相差甚远；</li>
<li>考虑同时使用过采样与欠采样。</li>
</ul>
<h2 id="改变分类算法"><a href="#改变分类算法" class="headerlink" title="改变分类算法"></a>改变分类算法</h2><p>更换其他算法： 决策树往往在类别不均衡数据上表现不错。它使用基于类变量的划分规则去创建分类树，因此可以强制地将不同类别的样本分开。</p>
<p>代价敏感学习:  对模型进行惩罚 , 研究者们针对不同的学习模型如感知机，支持向量机，决策树，神经网络等分别提出了其代价敏感的版本。</p>
<h2 id="更改评价指标"><a href="#更改评价指标" class="headerlink" title="更改评价指标"></a>更改评价指标</h2><p>几个比传统的准确度更有效的评价指标：</p>
<ul>
<li>混淆矩阵(Confusion Matrix)：使用一个表格对分类器所预测的类别与其真实的类别的样本统计，分别为：TP、FN、FP与TN。</li>
<li>精确度(Precision)</li>
<li>召回率(Recall)</li>
<li>F1得分(F1 Score)：精确度与找召回率的加权平均。</li>
</ul>
<p>特别是：</p>
<ul>
<li>Kappa (Cohen kappa)</li>
<li>ROC曲线(ROC Curves)：见Assessing and Comparing Classifier Performance with ROC Curves</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/heyongluoyao8/article/details/49408131" target="_blank" rel="noopener">在分类中如何处理训练集中不平衡问题</a></p>
]]></content>
      
        <categories>
            
            <category> 数据挖掘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 经验 </tag>
            
            <tag> 练集 </tag>
            
            <tag> 分类 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据挖掘经验——过拟合与cross-validation]]></title>
      <url>/2017/03/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/DM-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C-%E8%BF%87%E6%8B%9F%E5%90%88%E4%B8%8Ecross-validation/</url>
      <content type="html"><![CDATA[<h2 id="如何做交叉验证"><a href="#如何做交叉验证" class="headerlink" title="如何做交叉验证"></a>如何做交叉验证</h2><p>做交叉验证时要分成三个集合，training set ,validation set, and test set.</p>
<p>是不是overfitting只能由前两个集合决定。<br><a id="more"></a><br>根据前两个集合上的结果，你可以调整树的数量，使得在training和validation上的结果比较接近。具体的说是，当你增加树的数量时发现validation上的结果会下降，就表明有overfitting.当然用随机森林还有些别的参数可以控制overfitting。所以，要说明没有overfiiting，只要画张折线图：x轴是你的树的数量（或其它参数），y轴是在validation上的结果（１０份平均）。这图显示你用的树的数量正好对应y的一个局部最大值处即可。</p>
<h2 id="几点注意"><a href="#几点注意" class="headerlink" title="几点注意"></a>几点注意</h2><ol>
<li><p>cross-validation的结果稳定并不能说明没有过拟合。</p>
</li>
<li><p>确定是否过拟合，要看variance是否比较高。</p>
</li>
<li><p>判断variance是否比较高，要看test error是否比traing error明显高很多。// Andrew Ng的课程里专门讲到了用learning curve来分析bias与variance，可以参考</p>
</li>
<li><p>test error和training error的比较可以用你十轮交叉验证的test error与training error的均值进行。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 数据挖掘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 经验 </tag>
            
            <tag> DM </tag>
            
            <tag> 过拟合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据预处理——多值分类变量]]></title>
      <url>/2017/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/DM-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B-%E5%A4%9A%E5%80%BC%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<h2 id="多值分类变量-定性数据-编码"><a href="#多值分类变量-定性数据-编码" class="headerlink" title="多值分类变量(定性数据) 编码"></a>多值分类变量(定性数据) 编码</h2><h3 id="one-hot编码"><a href="#one-hot编码" class="headerlink" title="one-hot编码"></a>one-hot编码</h3><p>这种方法在NLP里用的很多，就是所谓的词向量模型。变换后的向量长度对于词典长度，每个词对应于向量中的一个元素。<br><a id="more"></a><br>优点是简单，缺点是维度高了，太稀。</p>
<h3 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h3><p>把分类变量做特征工程，比如： 汇总分组、SVD</p>
<h3 id="三元组"><a href="#三元组" class="headerlink" title="三元组"></a>三元组</h3><p>把分类变量变成数值变量，例如把不同城市的编码变成对应的经纬度，或是城市人口值，或是Y值，类似于银行信用评级里头WOE的搞法。</p>
<h3 id="词向量"><a href="#词向量" class="headerlink" title="词向量"></a>词向量</h3><p>词向量的思路，对任何一个取值比较多的分类变量，都可以采用类似的向量化嵌入的思路来搞。</p>
<h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><h2 id="降维-1"><a href="#降维-1" class="headerlink" title="降维"></a>降维</h2>]]></content>
      
        <categories>
            
            <category> 数据挖掘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 经验 </tag>
            
            <tag> DM </tag>
            
            <tag> 过拟合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于 Gensim 的 Word2Vec 实践]]></title>
      <url>/2017/01/%E5%BE%85%E6%95%B4%E7%90%86/NLP-word2vec%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="模型原理"><a href="#模型原理" class="headerlink" title="模型原理"></a>模型原理</h2><p>向量空间模型(Vector space model, VSM)将词语表示为一个连续的词向量, 且语义接近的单词对应的词向量在空间上(欧式距离, cosine相似度等)也是接近的.<br><a id="more"></a></p>
<p>VSM基于分布假说, 即若两个单词的上下文相同则两个单词的语义也相同.</p>
<p>基于分布假说的生成词向量的方法分为两大类:</p>
<p>统计法(count-based methods), 比如潜在语义分析(Latent Semantic Analysis, LSA)</p>
<p>预测法(predictive methods), 比如神经网络语言模型(Neural Network Language Model)</p>
<p>word2vec就是一种典型的神经网络语言模型.</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p> 需要注意的是：</p>
<p><code>pip install Cpython</code> :不安装不能开启并发</p>
<p><code>pin install Pattern</code></p>
<h2 id="加载语料库"><a href="#加载语料库" class="headerlink" title="加载语料库"></a>加载语料库</h2><p>Gensim的word2vec的输入是句子的list</p>
<p>对于大量的输入语料集或者需要整合磁盘上多个文件夹下的数据，我们可以以迭代器的方式而不是一次性将全部内容读取到内存中来节省 RAM 空间：</p>
 <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sentences_generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        self.dirname = dirname</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(self.dirname):</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> open(os.path.join(self.dirname, fname)):</span><br><span class="line">                sentence = line.strip().decode(<span class="string">'utf-8'</span>).split(<span class="string">' '</span>)</span><br><span class="line">                <span class="keyword">yield</span> sentence</span><br><span class="line"></span><br><span class="line">sent = sentences_generator(<span class="string">'/you/file/name'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="参数的设定"><a href="#参数的设定" class="headerlink" title="参数的设定"></a>参数的设定</h2><h3 id="min-count"><a href="#min-count" class="headerlink" title="min_count"></a>min_count</h3><p><code>model = Word2Vec(sentences, min_count=10) # default value is 5</code></p>
<p>在不同大小的语料集中，我们对于基准词频的需求也是不一样的。譬如在较大的语料集中，我们希望忽略那些只出现过一两次的单词，这里我们就可以通过设置min_count参数进行控制。一般而言，合理的参数值会设置在0~100之间。</p>
<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>size参数主要是用来设置神经网络的层数，Word2Vec 中的默认值是设置为100层。更大的层次设置意味着更多的输入数据，不过也能提升整体的准确度，合理的设置范围为 10~数百。</p>
<p><code>model = Word2Vec(sentences, size=200) # default value is 100</code></p>
<h3 id="workers"><a href="#workers" class="headerlink" title="workers"></a>workers</h3><p>workers参数用于设置并发训练时候的线程数，不过仅当Cython安装的情况下才会起作用：</p>
<p><code>model = Word2Vec(sentences, workers=4) # default = 1 worker = no paralleliz</code></p>
<h2 id="存储和加载模型"><a href="#存储和加载模型" class="headerlink" title="存储和加载模型"></a>存储和加载模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.save(<span class="string">'/tmp/mymodel'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_model = gensim.models.Word2Vec.load(<span class="string">'/tmp/mymodel'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="直接储存或加载由C生成的模型"><a href="#直接储存或加载由C生成的模型" class="headerlink" title="直接储存或加载由C生成的模型:"></a>直接储存或加载由C生成的模型:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model.save_word2vec_format(<span class="string">'./baike.zh.text.vector'</span>, binary=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">model = Word2Vec.load_word2vec_format(<span class="string">'/tmp/vectors.txt'</span>, binary=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># using gzipped/bz2 input works too, no need to unzip:</span></span><br><span class="line">model = Word2Vec.load_word2vec_format(<span class="string">'/tmp/vectors.bin.gz'</span>, binary=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>word2vec会在整个数据集上跑两遍：</p>
<ul>
<li><p>第一遍会收集单词及其词频来构建一个内部字典树结构.</p>
</li>
<li><p>第二遍训练神经网络.</p>
</li>
</ul>
<p>只能遍历一边数据, 则可以参考以下做法分步训练的方法 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; model = gensim.models.Word2Vec() # an empty model, no training</span><br><span class="line">&gt;&gt;&gt; model.build_vocab(some_sentences)  # can be a non-repeatable, 1-pass generator</span><br><span class="line">&gt;&gt;&gt; model.train(other_sentences)  # can be a non-repeatable, 1-pass generator</span><br></pre></td></tr></table></figure>
<h2 id="在线升级"><a href="#在线升级" class="headerlink" title="在线升级"></a>在线升级</h2><p>可以在加载模型之后使用另外的句子来进一步训练模型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>model = gensim.models.Word2Vec.load(<span class="string">'/tmp/mymodel'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.train(more_sentences)</span><br></pre></td></tr></table></figure>
<h2 id="RAM空间占用"><a href="#RAM空间占用" class="headerlink" title="RAM空间占用"></a>RAM空间占用</h2><p>官方：</p>
<blockquote>
<p>Every 10 million word types need about 1GB of RAM.</p>
</blockquote>
<p>有的人的说法：</p>
<p>word2vec的参数被存储为矩阵(Numpy array). array的大小为<code>vocabulary</code>  乘以 <code>size</code> 大小的浮点数(4 byte)矩阵.</p>
<p>内存中有三个这样的矩阵, 如果你的输入包含100,000个单词, 隐层单元数为200, 则需要的内存大小为100,000 <em> 200 </em> 4 * 3 bytes, 约为229MB.</p>
<p>另外还需要一些内存来存储字典树, 但是除非你的单词是特别长的字符串, 大部分内存占用都来自前面说的三个矩阵.</p>
<p>The simplest solution is probably to increase min_count or decrease size</p>
<h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>word2vec会在整个句子序列上跑两遍, 第一遍会收集单词及其词频来够爱走一个内部字典树结构. 第二遍才会训练神经网络.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2017-01-24 01:57:42: INFO: work start!</span><br><span class="line">2017-01-24 03:37:28: INFO: collected 25703385 word types from a corpus of 6380177283 raw words and 16408256 sentences</span><br><span class="line">2017-01-24 03:37:28: INFO: Loading a fresh vocabulary</span><br><span class="line">2017-01-24 03:41:15: INFO: min_count=10 retains 2501759 unique words (9% of original 25703385, drops 23201626)</span><br><span class="line">2017-01-24 03:41:15: INFO: min_count=10 leaves 6336057704 word corpus (99% of original 6380177283, drops 44119579)</span><br><span class="line">2017-01-24 03:41:29: INFO: deleting the raw counts dictionary of 25703385 items</span><br><span class="line">2017-01-24 03:41:44: INFO: sample=0.001 downsamples 29 most-common words</span><br><span class="line">2017-01-24 03:41:44: INFO: downsampling leaves estimated 5284735896 word corpus (83.4% of prior 6336057704)</span><br><span class="line">2017-01-24 03:41:44: INFO: estimated required memory for 2501759 words and 300 dimensions: 7255101100 bytes</span><br><span class="line">2017-01-24 03:42:07: INFO: resetting layer weights</span><br><span class="line">2017-01-24 03:43:06: INFO: training model with 4 workers on 2501759 vocabulary and 300 features, using sg=0 hs=0 sample=0.001 negative=5 window=5</span><br><span class="line">2017-01-24 03:43:06: INFO: expecting 16408256 sentences, matching count from corpus used for vocabulary survey</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/Finley/p/6043769.html" target="_blank" rel="noopener">word2vec模型原理与实现</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 数据挖掘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Word2Vec </tag>
            
            <tag> Gensim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步做一个自己的聊天机器人——— Word2Vec建模]]></title>
      <url>/2016/12/%E5%BE%85%E6%95%B4%E7%90%86/NLP-%E5%81%9A%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      <content type="html"><![CDATA[<p>不断更新 ing; <a id="more"></a></p>
<h2 id="语料库准备获取"><a href="#语料库准备获取" class="headerlink" title="语料库准备获取"></a>语料库准备获取</h2><p>当代自然语言处理都是基于统计的，统计自然需要很多样本，因此语料和词汇资源是必不可少的。</p>
<h3 id="维基百科简体中文语料的获取"><a href="#维基百科简体中文语料的获取" class="headerlink" title="维基百科简体中文语料的获取"></a>维基百科简体中文语料的获取</h3><p>使用维基百科做训练语料有很多好处：</p>
<p>维基百科资源获取非常方便，有 Wiki Dump 可以直接下载，所有的最新备份都在里面。相比之下，其他很多语料都需要用爬虫抓取，或者付费获得。</p>
<p>维基百科的文档解析有非常多的成熟工具，直接使用开源工具即可完成正文的提取。</p>
<p>维基百科的质量较高，而且领域广泛（比较适合我要做的问题）。</p>
<p>缺点也有：</p>
<p>最主要的就是数量较少，相比国内的百度百科、互动百科等，数据量要少一个数量级。(处理后 909M )</p>
<h4 id="下载中文的-Wiki-Dump"><a href="#下载中文的-Wiki-Dump" class="headerlink" title="下载中文的 Wiki Dump"></a>下载中文的 Wiki Dump</h4><p>链接是：<a href="http://download.wikipedia.com/zhwiki/latest/zhwiki-latest-pages-articles.xml.bz2" target="_blank" rel="noopener">http://download.wikipedia.com/zhwiki/latest/zhwiki-latest-pages-articles.xml.bz2</a></p>
<p>这个压缩包里面存的是标题、正文部分，如果需要其他数据，如页面跳转、历史编辑记录等，可以到目录下找别的下载链接。</p>
<h4 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h4><p>首先将xml的wiki数据转换为text格式，通过下面这个脚本(process_wiki.py)实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> gensim.corpora <span class="keyword">import</span> WikiCorpus</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    program = os.path.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">    logger = logging.getLogger(program)</span><br><span class="line"></span><br><span class="line">    logging.basicConfig(format=<span class="string">'%(asctime)s: %(levelname)s: %(message)s'</span>)</span><br><span class="line">    logging.root.setLevel(level=logging.INFO)</span><br><span class="line">    logger.info(<span class="string">"running %s"</span> % <span class="string">' '</span>.join(sys.argv))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># check and process input arguments</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">print</span> globals()[<span class="string">'__doc__'</span>] % locals()</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    inp, outp = sys.argv[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    space = <span class="string">" "</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    output = open(outp, <span class="string">'w'</span>)</span><br><span class="line">    wiki = WikiCorpus(inp, lemmatize=<span class="keyword">False</span>, dictionary=&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> text <span class="keyword">in</span> wiki.get_texts():</span><br><span class="line">        output.write(space.join(text) + <span class="string">"\n"</span>)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">10000</span> == <span class="number">0</span>):</span><br><span class="line">            logger.info(<span class="string">"Saved "</span> + str(i) + <span class="string">" articles"</span>)</span><br><span class="line"></span><br><span class="line">    output.close()</span><br><span class="line">    logger.info(<span class="string">"Finished Saved "</span> + str(i) + <span class="string">" articles"</span>)</span><br></pre></td></tr></table></figure>
<p>首先用 process_wiki.py处理这个XML压缩文件(大约20min rmbp)，执行：<code>python process_wiki.py zhwiki-latest-pages-articles.xml.bz2 wiki.zh.text</code></p>
<p>得到了大约23万多篇中文语料的text格式的语料:wiki.zh.text，大概750多M。不过查看之后发现，除了加杂一些英文词汇外，还有很多繁体字混迹其中，这里还是参考了 @licstar 《维基百科简体中文语料的获取》中的方法，安装opencc，然后将wiki.zh.text中的繁体字转化位简体字：</p>
<p><code>opencc -i wiki.zh.text -o wiki.zh.text.jian -c t2s.json</code></p>
<h2 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h2><p>这个软件很多:</p>
<ul>
<li><p>比较说免费且常用的<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">“结巴”中文分词</a></p>
</li>
<li><p>想自己动手做一个的话可以参考<a href="http://www.52nlp.cn/%E7%94%A8mecab%E6%89%93%E9%80%A0%E4%B8%80%E5%A5%97%E5%AE%9E%E7%94%A8%E7%9A%84%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">用MeCab打造一套实用的中文分词系统(我爱自然语言处理)</a></p>
</li>
<li><p>我用的是百度 内部的 NLPC (不要羡慕，嘿嘿)</p>
</li>
</ul>
<p>下面是我写的 jiaba 脚本：（用时 15 min）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    program = os.path.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">    logger = logging.getLogger(program)</span><br><span class="line"></span><br><span class="line">    logging.basicConfig(format=<span class="string">'%(asctime)s: %(levelname)s: %(message)s'</span>)</span><br><span class="line">    logging.root.setLevel(level=logging.INFO)</span><br><span class="line">    logger.info(<span class="string">"running %s"</span> % <span class="string">' '</span>.join(sys.argv))</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">        line = line.strip().decode(<span class="string">'utf-8'</span>, <span class="string">'ignore'</span>)</span><br><span class="line">        seg_list = jieba.cut(line, cut_all=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">" "</span>.join(seg_list).encode(<span class="string">'utf-8'</span>, <span class="string">'ignore'</span>)  <span class="comment"># 全模式</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">10000</span> == <span class="number">0</span>):</span><br><span class="line">            logger.info(<span class="string">"Saved "</span> + str(i) + <span class="string">" articles"</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>执行如下：<br><code>cat wiki.zh.text.jian | ~/anaconda/bin/python jieba_seg.py &gt; wiki.zh.text.jian.jieba</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 剔除其他语言字符(可选)</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./wiki.zh.text.jian.seg'</span> , <span class="string">'r'</span>) <span class="keyword">as</span> fr, open(<span class="string">'./wiki.zh.text.jian.seg.utf8'</span>, <span class="string">'a'</span>) <span class="keyword">as</span> fw:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr:</span><br><span class="line">        line = line.strip().decode(<span class="string">'utf-8'</span>, <span class="string">"gb18030"</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">        p = re.compile(<span class="string">ur'([\u4E00-\u9FA5a-zA-Z0-9+_]+)'</span>)</span><br><span class="line">        res = p.findall(line)</span><br><span class="line"></span><br><span class="line">        fw.write(line)</span><br><span class="line">        fw.write(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Word2Vec建模"><a href="#Word2Vec建模" class="headerlink" title="Word2Vec建模"></a>Word2Vec建模</h2><p>我们使用 gensim中的python word2vec版本，训练word2vec模型（比原版的快），脚本train_word2vec_model.py如下：</p>
<p>参数的说明如下：</p>
<ul>
<li>size：向量的维度 * 大的size值会要求更多的训练数据，但能带来更准确的模型</li>
<li>window：在一个句子内，目标词与预测词之间的最大距离</li>
<li>min_count：忽略所有总词频低于这个值的词。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> gensim</span><br><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> Word2Vec</span><br><span class="line"><span class="keyword">from</span> gensim.models.word2vec <span class="keyword">import</span> LineSentence</span><br><span class="line"><span class="comment">## 加载语料库</span></span><br><span class="line">sent = LineSentence(<span class="string">'./wiki.zh.text.jian.seg.utf8'</span>)</span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model = Word2Vec(sent, size=<span class="number">400</span>, window=<span class="number">5</span>, min_count=<span class="number">5</span>,workers=multiprocessing.cpu_count())</span><br><span class="line"><span class="comment">## 模型保存</span></span><br><span class="line">model.save(<span class="string">'./wiki.zh.text.model'</span>)</span><br><span class="line">model.save_word2vec_format(<span class="string">'./wiki.zh.text.vector'</span>, binary=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure>
<h2 id="模型的效果："><a href="#模型的效果：" class="headerlink" title="模型的效果："></a>模型的效果：</h2><p>让我们看一下训练好的中文维基百科word2vec模型“wiki.zh.text.vector”的效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 加载模型</span></span><br><span class="line">model = gensim.models.Word2Vec.load(<span class="string">"./wiki.zh.text.model"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> model.most_similar(<span class="string">u"计算机"</span>):</span><br><span class="line">    <span class="keyword">print</span> e[<span class="number">0</span>], e[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>电脑 0.661385774612
集成电路 0.642173707485
计算器 0.637504577637
嵌入式系统 0.635099411011
软件工程 0.617608428001
图像处理 0.612333893776
信号处理 0.609744787216
模式识别 0.605699121952
计算机科学 0.605493366718
计算机图形学 0.603613495827
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.similarity(<span class="string">u"计算机"</span>, <span class="string">u"自动化"</span>)</span><br></pre></td></tr></table></figure>
<pre><code>0.56565640705507891
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> model.doesnt_match(<span class="string">u"早餐 晚餐 午餐 中心"</span>.split())</span><br></pre></td></tr></table></figure>
<pre><code>中心
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> model.most_similar(<span class="string">u"自动化"</span>):</span><br><span class="line">    <span class="keyword">print</span> e[<span class="number">0</span>], e[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>系统工程 0.703799128532
自动控制 0.67300671339
电气工程 0.657055139542
信息系统 0.655942738056
电力电子 0.653406620026
控制工程 0.652179896832
电力系统 0.639267086983
智能化 0.635521113873
精密仪器 0.621204257011
农业机械 0.620398402214
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> NLP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 聊天机器人 </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ATOM使用及优化]]></title>
      <url>/2016/11/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-ATOM-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>Atom 是 Github 专门为程序员推出的一个跨平台文本编辑器。</p>
<p>Atom的简单入门就不科普了<a href="http://www.dbpoo.com/atom-tips/" target="_blank" rel="noopener">Atom 使用技巧及常用快捷键</a></p>
<p>20170908 更新： 总是莫名其妙会卡 ！ 会死机！！ 会100% cpu ！！！ 一天好几次啊！！！！ 太不省心了，现在已经弃坑，投入 sublime 怀抱 。心累哦，<br><a id="more"></a></p>
<h2 id="插件手动安装"><a href="#插件手动安装" class="headerlink" title="插件手动安装"></a>插件手动安装</h2><p><code>apm install XXX</code> 即可</p>
<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h3 id="自动补全："><a href="#自动补全：" class="headerlink" title="自动补全："></a>自动补全：</h3><p><a href="https://atom.io/packages/autocomplete-python" target="_blank" rel="noopener">https://atom.io/packages/autocomplete-python</a></p>
<p><a href="https://atom.io/packages/autocomplete-plus-python-jedi" target="_blank" rel="noopener">https://atom.io/packages/autocomplete-plus-python-jedi</a> (已经很少人用了)</p>
<h3 id="python语法检查linter-Flake8"><a href="#python语法检查linter-Flake8" class="headerlink" title="python语法检查linter-Flake8"></a>python语法检查linter-Flake8</h3><p>Python是一门动态语言。在给python传参数的时候并没 有严格的类型限制。写python程序的时候，发现错误经常只能在执行的时候发现。有一些 错误由于隐藏的比较深，只有特定逻辑才会触发，往往导致需要花很多时间才能将语法错误慢慢排查出来。其实有一些错误是很明显的，假如能在写程序的时候发现这些错误，就能提高工作效率。</p>
<p>Flake8是集大成者，是以下三个工具的包装：PyFlakes, Pep8, Ned Batchelder’s McCabe script</p>
<p>先要安装linter：</p>
<p><code>apm install linter</code></p>
<p>这是安装linter-flake8的基础。</p>
<p>之后，安装linter-flake8：</p>
<p>先安装flake8，这是一个python的包：</p>
<p><code>pip install flake8</code></p>
<p>然后是atom插件：</p>
<p><code>apm install linter-flake8</code></p>
<p>都安装好以后，如果代码写的不规范，或者有语法错误，就会被提示啦.</p>
<h3 id="python代码规范——格式化"><a href="#python代码规范——格式化" class="headerlink" title="python代码规范——格式化"></a>python代码规范——格式化</h3><p><a href="https://atom.io/packages/atom-beautify" target="_blank" rel="noopener">atom-beautify</a></p>
<p><code>apm install atom-beautify</code></p>
<p>Beautify On Save can be enabled for each language individually.</p>
<p>For example, for language HTML go into Atom-Beautify’s package settings (Atom ➔ Preferences ➔ Search for atom-beautify), find HTML, and toggle the Beautify On Save option.<br>需要以下 支持：</p>
<ul>
<li><p>autopep8 From pip:  <code>pip install --upgrade autopep8</code></p>
<ul>
<li>isort Installing isort is as simple as: <code>pip install isort</code></li>
</ul>
</li>
</ul>
<h3 id="Minimap"><a href="#Minimap" class="headerlink" title="Minimap"></a>Minimap</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://github.com/t9md/atom-project-folder.git" target="_blank" rel="noopener">https://github.com/t9md/atom-project-folder.git</a></p>
<h3 id="markdown-相关"><a href="#markdown-相关" class="headerlink" title="markdown 相关"></a>markdown 相关</h3><p>使用以下插件（都可以在 Settings &gt; Install 里面找到）：</p>
<p>markdown-preview：编辑实时预览插件，Atom 官方出品 (官方自带不用安装)</p>
<p><a href="https://atom.io/packages/markdown-preview" target="_blank" rel="noopener">https://atom.io/packages/markdown-preview</a></p>
<p>language-markdown：提供 Github Flavored Markdown 等 MD 高亮支持</p>
<p><a href="https://atom.io/packages/language-markdown" target="_blank" rel="noopener">https://atom.io/packages/language-markdown</a></p>
<p>markdown-scroll-sync：将 markdown-preview 的编辑区和预览区同步滚动</p>
<p><a href="https://atom.io/packages/markdown-scroll-sync" target="_blank" rel="noopener">https://atom.io/packages/markdown-scroll-sync</a></p>
<p>markdown-writer：方便管理图片、链接等</p>
<p><a href="https://atom.io/packages/markdown-writer" target="_blank" rel="noopener">https://atom.io/packages/markdown-writer</a></p>
<p>markdown-table-formatter：格式化表格</p>
<p><a href="https://atom.io/packages/markdown-table-formatter" target="_blank" rel="noopener">https://atom.io/packages/markdown-table-formatter</a></p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工具使用 </tag>
            
            <tag> 教程 </tag>
            
            <tag> ATOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python代码效率优化常用方法]]></title>
      <url>/2016/11/%E5%BE%85%E6%95%B4%E7%90%86/Python-%E6%80%BB%E7%BB%93-Python%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>不断添加ing…..<br><a id="more"></a></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法的时间复杂度排序上依次是：<br><code>O(1) -&gt; O(lg n) -&gt; O(n lg n) -&gt; O(n^2) -&gt; O(n^3) -&gt; O(n^k) -&gt; O(k^n) -&gt; O(n!)</code></p>
<ul>
<li>有两二以上的for的循环就要warming!!看是否思路有问题？？？</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字典-dictionary-vs-列表-list-vs-集合（set）"><a href="#字典-dictionary-vs-列表-list-vs-集合（set）" class="headerlink" title="字典 (dictionary) vs. 列表 (list) vs. 集合（set）"></a>字典 (dictionary) vs. 列表 (list) vs. 集合（set）</h3><p>Python 字典中使用了 hash table，因此查找操作的复杂度为 O(1)，而 list 实际是个数组，在 list 中，查找需要遍历整个 list，其复杂度为 O(n)，因此对成员的查找访问等操作字典要比 list 更快。</p>
<p>dict与set实现原理是一样的，<strong>速度相差无几</strong>。都是将实际的值放到list中。唯一不同的在于hash函数操作的对象，对于dict，hash函数操作的是其key，而对于set是直接操作的它的元素，假设操作内容为x，其作为因变量，放入hash函数，通过运算后取list的余数，转化为一个list的下标，此下标位置对于set而言用来放其本身，而对于dict则是创建了两个list，一个list该下表放此key，另一个list中该下标方对应的value。 <strong>如果只是查找key的话要用set,内存占用少的多</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##test list</span></span><br><span class="line">l = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'is'</span>,<span class="string">'python'</span>,<span class="string">'jason'</span>,<span class="string">'hello'</span>,<span class="string">'hill'</span>,<span class="string">'with'</span>,<span class="string">'phone'</span>,<span class="string">'test'</span>, <span class="string">'dfdf'</span> \</span><br><span class="line">     ,<span class="string">'apple'</span>,<span class="string">'pddf'</span>,<span class="string">'ind'</span>,<span class="string">'basic'</span>,<span class="string">'none'</span>,<span class="string">'baecr'</span>,<span class="string">'var'</span>,<span class="string">'bana'</span>,<span class="string">'dd'</span>,<span class="string">'wrd'</span>]</span><br><span class="line"><span class="comment">## test data</span></span><br><span class="line">d = dict.fromkeys(l,<span class="keyword">True</span>)</span><br><span class="line">s = set(l)</span><br><span class="line">res = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_list</span><span class="params">()</span>:</span>   </span><br><span class="line">    <span class="keyword">for</span> find <span class="keyword">in</span> [<span class="string">'is'</span>,<span class="string">'hat'</span>,<span class="string">'new'</span>,<span class="string">'list'</span>,<span class="string">'old'</span>,<span class="string">'.'</span>]:</span><br><span class="line">        <span class="keyword">if</span> find <span class="keyword">not</span> <span class="keyword">in</span> l:</span><br><span class="line">            res.append(find)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_dict</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> find <span class="keyword">in</span> [<span class="string">'is'</span>,<span class="string">'hat'</span>,<span class="string">'new'</span>,<span class="string">'list'</span>,<span class="string">'old'</span>,<span class="string">'.'</span>]:</span><br><span class="line">        <span class="keyword">if</span> find <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">            res.append(find)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_set</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> find <span class="keyword">in</span> [<span class="string">'is'</span>,<span class="string">'hat'</span>,<span class="string">'new'</span>,<span class="string">'list'</span>,<span class="string">'old'</span>,<span class="string">'.'</span>]:</span><br><span class="line">            <span class="keyword">if</span> find <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">                res.append(find)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"traverse list time:"</span></span><br><span class="line">%timeit test_list()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"traverse dist time:"</span></span><br><span class="line">%timeit test_dict()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"traverse set time:"</span></span><br><span class="line">%timeit test_set()</span><br></pre></td></tr></table></figure>
<pre><code>traverse list time:
The slowest run took 13.61 times longer than the fastest. This could mean that an intermediate result is being cached.
100000 loops, best of 3: 2.79 µs per loop
traverse dist time:
The slowest run took 4.65 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 1.08 µs per loop
traverse set time:
The slowest run took 4.52 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 1.11 µs per loop
</code></pre><h3 id="LIST推导式"><a href="#LIST推导式" class="headerlink" title="LIST推导式"></a>LIST推导式</h3><p>不要使用老式的 <code>[x for i in range(n)]</code> 而在要用 <code>[x] * n</code> ，效率上差的很多：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%timeit f1=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>)]</span><br><span class="line">%timeit f2=[<span class="number">0</span>] * <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<pre><code>1000 loops, best of 3: 476 µs per loop
10000 loops, best of 3: 46.4 µs per loop
</code></pre><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="子串的查找方法比较-find-vs-in-vs-re-match"><a href="#子串的查找方法比较-find-vs-in-vs-re-match" class="headerlink" title="子串的查找方法比较  find vs in vs. re.match"></a>子串的查找方法比较  find vs in vs. re.match</h3><p>Python中字符串查找方式有多种，常见的有re.match/search or str.find</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(string, text)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> string.find(text) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">re_find</span><span class="params">(string, text)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> re.match(text, string):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_find</span><span class="params">(string, text)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> text <span class="keyword">in</span> string:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">%timeit(<span class="string">"find(string, text)"</span>, <span class="string">"from __main__ import find; string='lookforme'; text='look'"</span>)</span><br><span class="line">%timeit(<span class="string">"re_find(string, text)"</span>, <span class="string">"from __main__ import re_find; string='lookforme'; text='look'"</span>)</span><br><span class="line">%timeit(<span class="string">"best_find(string, text)"</span>, <span class="string">"from __main__ import best_find; string='lookforme'; text='look'"</span>)</span><br></pre></td></tr></table></figure>
<pre><code>The slowest run took 41.41 times longer than the fastest. This could mean that an intermediate result is being cached.
10000000 loops, best of 3: 28.8 ns per loop
10000000 loops, best of 3: 29.1 ns per loop
10000000 loops, best of 3: 28.9 ns per loop
</code></pre><p>可以看到效率最高的方式是：if text in string :</p>
<h3 id="join-vs"><a href="#join-vs" class="headerlink" title="join vs. +"></a>join vs. +</h3><p>在字符的操作上 join 比 + 要快，因此要尽量使用 join 而不是 +。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="string">'酒'</span>, <span class="string">'茶'</span>, <span class="string">'水'</span>, <span class="string">'兔'</span>, <span class="string">'狗'</span>, <span class="string">'鹿'</span>, <span class="string">'牛'</span>, <span class="string">'猪'</span>, <span class="string">'螺'</span>, <span class="string">'蚌'</span>, <span class="string">'蛤'</span>, <span class="string">'蚝'</span>]*<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_join</span><span class="params">()</span>:</span></span><br><span class="line">    new0 = <span class="string">""</span>.join(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_plus</span><span class="params">()</span>:</span></span><br><span class="line">    new1 = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        new1 += i</span><br><span class="line"><span class="keyword">print</span> <span class="string">"use join time:"</span></span><br><span class="line">%timeit test_join()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"use + time:"</span></span><br><span class="line">%timeit test_plus()</span><br></pre></td></tr></table></figure>
<pre><code>use join time:
100000 loops, best of 3: 17.6 µs per loop
use + time:
10000 loops, best of 3: 98.7 µs per loop
</code></pre><h3 id="对字符进行格式化比直接串联读取要快"><a href="#对字符进行格式化比直接串联读取要快" class="headerlink" title="对字符进行格式化比直接串联读取要快"></a>对字符进行格式化比直接串联读取要快</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="string">'酒sdf'</span>, <span class="string">'茶ghjdfg'</span>, <span class="string">'水fghjfghj'</span>]</span><br><span class="line">%time <span class="keyword">print</span> (<span class="string">'%s%s%s'</span> % (s[<span class="number">0</span>], s[<span class="number">1</span>], s[<span class="number">2</span>]))</span><br><span class="line">%time  <span class="keyword">print</span> s[<span class="number">0</span>] + s[<span class="number">1</span>] + s[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<pre><code>酒sdf茶ghjdfg水fghjfghj
CPU times: user 78 µs, sys: 36 µs, total: 114 µs
Wall time: 92 µs
酒sdf茶ghjdfg水fghjfghj
CPU times: user 89 µs, sys: 45 µs, total: 134 µs
Wall time: 123 µs
</code></pre><h3 id="内置函数-vs-re"><a href="#内置函数-vs-re" class="headerlink" title="内置函数 vs re"></a>内置函数 vs re</h3><p>当对字符串可以使用正则表达式或者内置函数来处理的时候，选择内置函数。如 str.isalpha()，str.isdigit()，str.startswith((‘x’, ‘yz’))，str.endswith((‘x’, ‘yz’))</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><h3 id="按行读取大文件-GB"><a href="#按行读取大文件-GB" class="headerlink" title="按行读取大文件(GB)"></a>按行读取大文件(GB)</h3><p>下面两种方法是等效的， 效率上差的不多 但第二个方法 ：</p>
<ul>
<li><p>with语句打开和关闭文件，包括抛出一个内部块异常。</p>
</li>
<li><p>for line in fr文件对象f视为一个迭代器，会自动的采用缓冲IO和内存管理，所以你不必担心大文件。</p>
</li>
</ul>
<p>所以我推荐大家使用第二个方法读取文件，特别是大的文件（超过本机内存）。</p>
<p>多说一点：</p>
<p>在使用python进行，一些底层的东东。应该让系统来处理，使用最简单的方式，交给解释器，就管好自己的工作就行了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#If the file is line based</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_lines</span><span class="params">()</span>:</span></span><br><span class="line">    d= []</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'./test.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fr:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">            d.append(line)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">()</span>:</span></span><br><span class="line">    d = []</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'./test.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fr:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fr:</span><br><span class="line">            d.append(line)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t = open(<span class="string">'./test.txt'</span>, <span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">import</span> random,string</span><br><span class="line">    tmp = <span class="string">'1223434563425'</span>.join([(string.ascii_letters+string.digits)[x] <span class="keyword">for</span> x <span class="keyword">in</span> random.sample(range(<span class="number">0</span>,<span class="number">62</span>),<span class="number">32</span>)])</span><br><span class="line">    t.write(tmp + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'read_lines:'</span></span><br><span class="line">%timeit read_lines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'read_file:'</span></span><br><span class="line">%timeit read_file()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.remove(<span class="string">'./test.txt'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>read_lines:
The slowest run took 6.70 times longer than the fastest. This could mean that an intermediate result is being cached.
1000 loops, best of 3: 282 µs per loop
read_file:
1000 loops, best of 3: 257 µs per loop
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> Python3 </tag>
            
            <tag> 效率 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[中文编码处理小结（python）]]></title>
      <url>/2016/10/%E5%BE%85%E6%95%B4%E7%90%86/NLP-%E6%80%BB%E7%BB%93-python%E7%BC%96%E7%A0%81%E5%A4%84%E7%90%86%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>注意：本文只是针对 python 2，在 python 3 中，编码方式与处理技巧有些许变化</p>
<a id="more"></a>
<h2 id="编码基础"><a href="#编码基础" class="headerlink" title="编码基础"></a>编码基础</h2><p><a href="http://www.imkevinyang.com/2009/02/%E5%AD%97%E7%AC%A6%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%88ascii%EF%BC%8Cansi%EF%BC%8Cunicode%EF%BC%8Cutf-8%E5%8C%BA%E5%88%AB%EF%BC%89.html" target="_blank" rel="noopener">字符编解码的故事（ASCII，ANSI，Unicode，Utf-8区别</a></p>
<h2 id="几种编码方式比较"><a href="#几种编码方式比较" class="headerlink" title="几种编码方式比较"></a>几种编码方式比较</h2><h3 id="test-code"><a href="#test-code" class="headerlink" title="test code"></a>test code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</span><br><span class="line"><span class="keyword">print</span> <span class="string">'----raw str----'</span></span><br><span class="line">a = <span class="string">'统计ab12'</span></span><br><span class="line">display(a)</span><br><span class="line"><span class="keyword">print</span> a</span><br><span class="line"><span class="keyword">print</span> <span class="string">'len'</span> ,(len(a))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----str with u---'</span></span><br><span class="line">x = <span class="string">u'统计ab12'</span></span><br><span class="line">display(x)</span><br><span class="line"><span class="keyword">print</span> x</span><br><span class="line"><span class="keyword">print</span> <span class="string">'len'</span> , len(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----utf-8----'</span></span><br><span class="line">y = x.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">display(y)</span><br><span class="line"><span class="keyword">print</span> y</span><br><span class="line"><span class="keyword">print</span> <span class="string">'len'</span> , len(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'---gb18030---'</span></span><br><span class="line">z = x.encode(<span class="string">'gb18030'</span>)</span><br><span class="line">display(z)</span><br><span class="line"><span class="keyword">print</span> z</span><br><span class="line"><span class="keyword">print</span> <span class="string">'len'</span> , len(z)</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">----raw str----</span><br><span class="line"><span class="string">'\xe7\xbb\x9f\xe8\xae\xa1ab12'</span></span><br><span class="line">统计ab12</span><br><span class="line">len <span class="number">10</span></span><br><span class="line"></span><br><span class="line">----str <span class="keyword">with</span> u---</span><br><span class="line"><span class="string">u'\u7edf\u8ba1ab12'</span></span><br><span class="line">统计ab12</span><br><span class="line">len <span class="number">6</span></span><br><span class="line"></span><br><span class="line">----utf<span class="number">-8</span>----</span><br><span class="line"><span class="string">'\xe7\xbb\x9f\xe8\xae\xa1ab12'</span></span><br><span class="line">统计ab12</span><br><span class="line">len <span class="number">10</span></span><br><span class="line"></span><br><span class="line">---gb18030---</span><br><span class="line"><span class="string">'\xcd\xb3\xbc\xc6ab12'</span></span><br><span class="line">ͳ��ab12</span><br><span class="line">len <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>python2.X 默认的编码方式是UTF8 ，UTF-8 <strong><em>变长度的</em></strong>，最多 6 个字节，小于 127 的字符用一个字节表示，和ASCII码完全相同。</li>
<li>python 中的<code>u&#39;xxx&#39;</code>unicode 是严格的16位一个字符， 长度为字符大小，和哪种文字无关。就是传说中的 “与存储无关的表示”。</li>
<li>gb18030 是两个字节一个汉字， 也就是传说中的 ：一个汉字算两个英文字符！所以我们用gb储存有汉字的文件。</li>
</ul>
<h2 id="decode-与eccode"><a href="#decode-与eccode" class="headerlink" title="decode 与eccode"></a>decode 与eccode</h2><p>参考 ：<a href="http://wklken.me/posts/2013/08/31/python-extra-coding-intro.html" target="_blank" rel="noopener">PYTHON-进阶-编码处理小结</a></p>
<p>下面是 调试时最常出现的错误：</p>
<blockquote>
<p>UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe7 in position 0: ordinal not in range(128)</p>
</blockquote>
<ul>
<li>unicode才是真正意义上的字符串，由字符组成</li>
<li>搞明白要处理的是str还是unicode, 使用对的处理方法(str.decode/unicode.encode)</li>
<li>简单原则：不要对str使用encode，不要对unicode使用decode (事实上可以对str进行encode的，为了保证简单，不建议)</li>
<li>不同编码转换,使用unicode作为中间编码</li>
</ul>
<h2 id="未知编码文本的处理-感谢-qinhuapeng-提供）"><a href="#未知编码文本的处理-感谢-qinhuapeng-提供）" class="headerlink" title="未知编码文本的处理 (感谢@qinhuapeng 提供）"></a>未知编码文本的处理 (感谢@qinhuapeng 提供）</h2><p><a href="https://pypi.python.org/pypi/chardet/" target="_blank" rel="noopener">chardet 2.3 库</a></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'./testbm.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fr:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        line = line.strip()</span><br><span class="line">        code = chardet.detect(line)[<span class="string">'encoding'</span>].lower()</span><br><span class="line">        word = line.decode(code)</span><br></pre></td></tr></table></figure>
<h2 id="读取文件时的几种解码方式的效率比较"><a href="#读取文件时的几种解码方式的效率比较" class="headerlink" title="读取文件时的几种解码方式的效率比较"></a>读取文件时的几种解码方式的效率比较</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test file</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./testbm.txt'</span>, <span class="string">'a'</span>) <span class="keyword">as</span> fw:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">15</span>):</span><br><span class="line">        <span class="comment">#x = u'用print输出已经用CP936编码过的str对象'.encode('utf-8')</span></span><br><span class="line">        y = <span class="string">u'我也试了用encode,decode各种转，但是就是转不成中文...'</span>.encode(<span class="string">'gb18030'</span>)</span><br><span class="line">        <span class="comment">#z = u'在Windows 7简体中文环境下，默认标准输出（就是运行cmd命令后的窗口）中'.encode('gbk')</span></span><br><span class="line">        fw.write(y + <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test01</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="comment"># 使用chardet每行解码，优点可以解码含有不同编码的文件，但是速度很慢。</span></span><br><span class="line">    <span class="comment"># 大文件和单一编码文件不适用</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'./testbm.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fr:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">            line = line.strip()</span><br><span class="line">            code = chardet.detect(line)[<span class="string">'encoding'</span>].lower()</span><br><span class="line">            word = line.decode(code)</span><br><span class="line">            <span class="comment">#print word</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test02</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="comment"># 对照组，读取中按行解码</span></span><br><span class="line">    <span class="comment">#只能单一编码文件可能</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'./testbm.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fr:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">            line = line.strip()</span><br><span class="line">            word = line.decode(<span class="string">"gb18030"</span>)</span><br><span class="line">            <span class="comment">#print word</span></span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test03</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="comment"># codecs在打开时自动解码</span></span><br><span class="line">    <span class="comment"># #只能单一编码文件可能</span></span><br><span class="line">    <span class="keyword">with</span> codecs.open(<span class="string">'./testbm.txt'</span>, <span class="string">'r'</span>, <span class="string">'gb18030'</span>) <span class="keyword">as</span> fr:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">            line = line.strip()</span><br><span class="line">            word = line</span><br><span class="line">            <span class="comment">#print word</span></span><br></pre></td></tr></table></figure>
<p>测试这几个种方法的效率:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line">%timeit test01()</span><br><span class="line">%timeit test02()</span><br><span class="line">%timeit test03()</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">76.2</span> ms per loop</span><br><span class="line">The slowest run took <span class="number">5.07</span> times longer than the fastest. This could mean that an intermediate result <span class="keyword">is</span> being cached.</span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">58.4</span> µs per loop</span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">57.7</span> µs per loop</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>chardet</code> 使用chardet每行解码，优点可以解码含有不同编码的文件，但是速度很慢（还不稳定）。大文件和单一编码文件不适用！</li>
<li>codecs在打开时自动解码 和 每行 decode 效率 差不多，实际上他两个在python 内部的实现是一样的。</li>
<li>文件读取前转换编码是一种比较好的习惯， 对自己来说，要尽可能的统一编码。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> NLP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NLP </tag>
            
            <tag> DM </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python面向对象编程快速指南]]></title>
      <url>/2016/10/%E5%BE%85%E6%95%B4%E7%90%86/Python-%E6%80%BB%E7%BB%93-python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>这个不是给小白看的……本文假定：</p>
<ul>
<li>已经掌握了一门或多门其他的OPP语言。</li>
<li>已经可以用python写脚本了。<a id="more"></a>
</li>
</ul>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>一个文件夹。</p>
<h3 id="init-py文件："><a href="#init-py文件：" class="headerlink" title="__init__.py文件："></a><code>__init__.py</code>文件：</h3><ol>
<li>Python用来说明这个文件夹可以当做一个包。在Python术语中，包是一组模块的集合，主要用来把相似的文件分组，防止出现命名冲突。</li>
<li>可以为空。</li>
<li>导入这个包的时候，<code>__init__.py</code>文件自动运行。</li>
</ol>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>可以理解他一个<code>.py</code>文件，里面可以有多个类.(秒杀java)<br>一个模块的模板：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">' a test module '</span></span><br><span class="line">__author__ = <span class="string">'Michael Liao'</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 命令行运行hello模块文件时 自动运行</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>长这个样子：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>类名通常是大写开头的单词，紧接着是(object)，表示该类继承的父类。</p>
<p>类的方法，除了第一个参数是self外，其他和普通函数一样。</p>
<h3 id="构造函数-init-self"><a href="#构造函数-init-self" class="headerlink" title="构造函数__init__(self)"></a>构造函数<code>__init__(self)</code></h3><p>绑定属性用的，也就是java中的构造器。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure></p>
<h2 id="几个类常用的函数"><a href="#几个类常用的函数" class="headerlink" title="几个类常用的函数"></a>几个类常用的函数</h2><h3 id="析构函数-del-self"><a href="#析构函数-del-self" class="headerlink" title="析构函数 __del__(self)"></a>析构函数 <code>__del__(self)</code></h3><ol>
<li>如果基类和子类都有<strong>del</strong>，那么子类必须显式的调用的基类的<strong>del</strong>。</li>
<li>在对象销毁的时候，会调用对象的<strong>del</strong>方法，</li>
<li>循环引用和<code>__del__</code>同时使用就会出现问题。</li>
</ol>
<h3 id="限制实例的属性-slots-self"><a href="#限制实例的属性-slots-self" class="headerlink" title="限制实例的属性 __slots__(self)"></a>限制实例的属性 <code>__slots__(self)</code></h3><p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p>
<p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的.除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<strong>slots</strong>加上父类的<code>__slots__</code>。</p>
<h3 id="其他的"><a href="#其他的" class="headerlink" title="其他的"></a>其他的</h3><p><code>__str__</code> 返回一个好看的字符串（to_str）</p>
<p><code>_iter__</code> 方法返回一个迭代对象，</p>
<p><code>__next__</code>方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环</p>
<p><code>__call__</code>用实例本身时的默认方法,通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。</p>
<h2 id="绑定属性-方法"><a href="#绑定属性-方法" class="headerlink" title="绑定属性/方法"></a>绑定属性/方法</h2><p>动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言(java)中很难实现。(也是不同点)</p>
<h3 id="实例绑定属性"><a href="#实例绑定属性" class="headerlink" title="实例绑定属性"></a>实例绑定属性</h3><p>注意：对另一个实例是不起作用。</p>
<p>就是可以给这个类绑定任何属性，而不管他事前有没有,(这个很动态……)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Student()</span><br><span class="line">s.name = <span class="string">'Michael'</span></span><br></pre></td></tr></table></figure>
<h3 id="实例绑定的方法"><a href="#实例绑定的方法" class="headerlink" title="实例绑定的方法"></a>实例绑定的方法</h3><p>注意 ：对另一个实例是不起作用。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line">s.set_age = MethodType(new_age, s) <span class="comment"># 给实例绑定一个方法</span></span><br></pre></td></tr></table></figure></p>
<h3 id="class绑定方法"><a href="#class绑定方法" class="headerlink" title="class绑定方法"></a>class绑定方法</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line">Student.set_score = set_score</span><br></pre></td></tr></table></figure>
<h2 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h2><p>@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。</p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。</p>
<p>只允许单一继承的语言（如Java）不能使用MixIn的设计。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Mammal, RunnableMixIn, CarnivorousMixIn)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><code>try...except...finally...</code>的错误处理机制，Python也不例外。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'try...'</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    print(<span class="string">'result:'</span>, r)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'except:'</span>, e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'finally...'</span>)</span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li><p>没有错误发生，except语句块不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。</p>
</li>
<li><p>没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句：</p>
</li>
</ul>
<h2 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h2><p>定义一个错误的class，选择好继承关系，然后，用raise语句抛出一个错误的实例<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooError</span><span class="params">(ValueError)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></span><br><span class="line">    n = int(s)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> FooError(<span class="string">'invalid value: %s'</span> % s)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'0'</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><code>assert</code> 如果断言失败，assert语句本身就会抛出AssertionError：</p>
<p><code>logging</code> 不会抛出错误，而且可以输出到文件</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p><strong>“测试驱动开发”（TDD：Test-Driven Development）</strong></p>
<p>这个就和语言关系不大了</p>
<ul>
<li>推荐使用PyUnit做单元测试。<br><a href="https://www.ibm.com/developerworks/cn/linux/l-pyunit/" target="_blank" rel="noopener">IBM-Python自动单元测试框架介绍</a></li>
<li>推荐测试代码放在单独的test目录中。如果被测试代码文件名为xxx.py，那么测试代码文件应该被命名为xxx_test.py</li>
</ul>
<h2 id="导入自定义模块"><a href="#导入自定义模块" class="headerlink" title="导入自定义模块"></a>导入自定义模块</h2><ol>
<li><p>如果导入的模块和主程序在同个目录下，直接import就行了</p>
</li>
<li><p>如果导入的模块是在主程序所在目录的子目录下，可以在子目录中增加一个空白的<strong>init</strong>.py文件，该文件使得python解释器将子目录整个也当成一个模块，然后直接通过“import 子目录.模块”导入即可。</p>
</li>
<li><p>如果导入的模块是在主程序所在目录的父目录下，则要通过修改path来解决，有两种方法：</p>
</li>
</ol>
<ul>
<li><p>通过”import sys，sys.path.append(‘父目录的路径’)“来改变，这种方法属于一次性的，只对当前的python解释器进程有效，关掉python重启后就失效了。</p>
</li>
<li><p>直接修改环境变量：种方式是永久的，一次设置以后一直都有效。</p>
</li>
<li><p>通过修改path是通用的方法，因为python解释器就是通过sys.path去一个地方一个地方的寻找模块的。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Python3 </tag>
            
            <tag> OPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试常见基础算法:排序/查找/树的遍历/链表/hash/堆栈（python版）]]></title>
      <url>/2016/09/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>这几天去了几个面试，现场coding的表现差强人意。感觉自己好像东西都忘的差不多了，现在这里总结一下，以备忘，以复习。<br>当然，你别指望考官会直接考你这些，太基础，但是，当他知道你这些都写不出来的时候，你面试绝对没希望了。</p>
<p>PS: 真的有面试官会考啊， 包括（sina, meituan, baidu）…………<br><a id="more"></a></p>
<h2 id="8大排序"><a href="#8大排序" class="headerlink" title="8大排序"></a>8大排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>时间复杂度为O(n^2)</strong>。是 <strong>稳定</strong> 的排序方法。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort1</span><span class="params">(list)</span>:</span></span><br><span class="line">    n = len(list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span> , n):</span><br><span class="line">            <span class="keyword">if</span> list[i] &gt; list[j]:</span><br><span class="line">                list[i], list[j] = list[j],list[i]</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">sort1(arr)</span><br></pre></td></tr></table></figure></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><strong>时间复杂度为O(n^2)</strong> 。是 <strong>不稳定</strong> 的排序方法。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort2</span><span class="params">(list)</span>:</span></span><br><span class="line">    n = len(list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        m = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span> , n):</span><br><span class="line">            <span class="keyword">if</span> list[j] &lt; list[m]:</span><br><span class="line">                m = j</span><br><span class="line">        list[i], list[m] = list[m], list[i]</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">%timeit sort2(arr)</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><img src="./01.gif" alt=""><br><strong>时间复杂度为O(n^2)</strong> 。是 <strong>稳定</strong> 的排序方法。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span> <span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        key = arr[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; key:</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">                larr[j] = key</span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">%timeit insert_sort(arr)</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序Shell Sort是插入排序的一种。<br>待补充！</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p>
<h3 id="快速排序-QuickSort"><a href="#快速排序-QuickSort" class="headerlink" title="快速排序 QuickSort"></a>快速排序 QuickSort</h3><p><img src="./02.gif" alt=""><br>快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">test_arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">print(test_arr)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr, lo, hi)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &gt;= hi :</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    j = partion(arr, lo, hi)</span><br><span class="line">    quick_sort(arr, lo, j<span class="number">-1</span>)</span><br><span class="line">    quick_sort(arr, j+<span class="number">1</span>, hi)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partion</span><span class="params">(arr, lo, hi)</span>:</span></span><br><span class="line">    key = arr[lo]</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> arr[hi] &gt;= key:</span><br><span class="line">            hi = hi - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> arr[hi] &lt; key:</span><br><span class="line">            arr[lo] = arr[hi]</span><br><span class="line">            lo += <span class="number">1</span></span><br><span class="line">            arr[hi] = arr[lo]</span><br><span class="line"></span><br><span class="line">    arr[lo] = key</span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">n = len(test_arr)</span><br><span class="line">quick_sort(test_arr, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">test_arr</span><br></pre></td></tr></table></figure>
<h3 id="堆排序-HeapSort"><a href="#堆排序-HeapSort" class="headerlink" title="堆排序 HeapSort"></a>堆排序 HeapSort</h3><p><img src="/03.gif" alt=""><br>堆排序在 top K 问题中使用比较频繁。<br>O(nlogn) 是不稳定的排序方法。</p>
<h2 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search2</span><span class="params">(arr, f)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (high + low)/<span class="number">2</span></span><br><span class="line">        tmp = arr[mid]</span><br><span class="line">        <span class="keyword">if</span> tmp &gt; f :</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> tmp &lt; f :</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">print</span> (mid)</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">print</span> (<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>树的遍历主要有两种，一种是深度优先遍历，像前序、中序、后序；另一种是广度优先遍历，像层次遍历。在树结构中两者的区别还不是非常明显，但从树扩展到有向图，到无向图的时候，深度优先搜索和广度优先搜索的效率和作用还是有很大不同的。</p>
<p>深度优先一般用递归，广度优先一般用队列。</p>
<p>一般情况下能用递归实现的算法大部分也能用堆栈来实现。</p>
<p>根据访问结点操作发生位置命名：</p>
<ul>
<li>NLR：前序遍历(PreorderTraversal亦称(先序遍历))  ——访问结点的操作发生在遍历其左右子树之前。</li>
<li>LNR：中序遍历(InorderTraversal)  ——访问结点的操作发生在遍历其左右子树之中(间)。</li>
<li>LRN：后序遍历(PostorderTraversal)    ——访问结点的操作发生在遍历其左右子树之后。</li>
</ul>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">front</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="string">"""利用递归实现树的先序遍历"""</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span>;</span><br><span class="line">    print(root.val)</span><br><span class="line">    front(root.left)</span><br><span class="line">    front(root.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mid</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="string">"""利用递归实现树的中序遍历"""</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    mid(root.left)</span><br><span class="line">    print(root.val)</span><br><span class="line">    mid(root.right)</span><br></pre></td></tr></table></figure>
<h3 id="非递归实现前序遍历（堆栈）"><a href="#非递归实现前序遍历（堆栈）" class="headerlink" title="非递归实现前序遍历（堆栈）"></a>非递归实现前序遍历（堆栈）</h3><p>递归算法的本质是利用函数的调用栈进行，实际上我们可以自行使用栈来进行模拟，这样的算法 <strong>空间复杂度为O(h)</strong>，h为二叉树的高度。</p>
<p>首先把根节点入栈，然后在每次循环中执行以下操作：</p>
<ul>
<li>此时栈顶元素即为当前的根节点，弹出并打印当前的根节点。</li>
<li>把当前根节点的右儿子和左儿子分别入栈（注意是右儿子先入栈左儿子后入栈，这样的话下次出栈的元素才是左儿子，这样才符合前序遍历的顺序要求：根节点-&gt;左儿子-&gt;右儿子）。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre</span><span class="params">(root)</span>:</span></span><br><span class="line">    myStack = []</span><br><span class="line">    node = root</span><br><span class="line">    <span class="keyword">while</span> node <span class="keyword">or</span> myStack:</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            print(node.val)</span><br><span class="line">            myStack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        node = myStack.pop()</span><br><span class="line">        node = node.right</span><br></pre></td></tr></table></figure>
<h3 id="利用队列实现树的层次遍历"><a href="#利用队列实现树的层次遍历" class="headerlink" title="利用队列实现树的层次遍历"></a>利用队列实现树的层次遍历</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lev</span><span class="params">(root)</span>:</span></span><br><span class="line">    myQ = []</span><br><span class="line">    node = root</span><br><span class="line"></span><br><span class="line">    myQ.append(node)</span><br><span class="line">    <span class="keyword">while</span> myQ:</span><br><span class="line">        node = myQ.pop(<span class="number">0</span>)</span><br><span class="line">        print(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left == <span class="keyword">None</span>:</span><br><span class="line">            myQ.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right == <span class="keyword">None</span>:</span><br><span class="line">            myQ.append(node.right)</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的顺序查找"><a href="#二叉树的顺序查找" class="headerlink" title="二叉树的顺序查找"></a>二叉树的顺序查找</h3><p>待补充！</p>
<h2 id="堆栈链表实现"><a href="#堆栈链表实现" class="headerlink" title="堆栈链表实现"></a>堆栈链表实现</h2><p>待补充！</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> python </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习中常见的评估方法]]></title>
      <url>/2016/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ML-%E6%80%BB%E7%BB%93-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>评价指标是机器学习任务中非常重要的一环。不同的机器学习任务有着不同的评价指标，同时同一种机器学习任务也有着不同的评价指标，每个指标的着重点不一样。如分类（classification）、回归（regression）、排序（ranking）、聚类（clustering）、热门主题模型（topic modeling）、推荐（recommendation）等。并且很多指标可以对多种不同的机器学习模型进行评价，<br><a id="more"></a></p>
<p>本文是我总结的的几种常见的评估方法,不断更新Ing</p>
<p>不同的机器学习任务有着不同的性能评价指标。例如，在垃圾邮件检测系统中，它本身是一个二分类问题（垃圾邮件vs正常邮件），可以使用准确率（Accuracy）、对数损失函数（log-loss）、AUC等评价方法。又如在股票预测中，它本身是一个实数序列数据预测问题，可以使用平方根误差（root mean square error， RMSE）等指标；又如在搜索引擎中进行与查询相关的项目排序中，可以使用精确率－召回率（precision-recall）、NDCG（normalized discounted cumulative gain）。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> ML </tag>
            
            <tag> 评估 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[爬虫原理及知识点总结]]></title>
      <url>/2016/09/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/DM-%E6%80%BB%E7%BB%93-%E7%88%AC%E8%99%AB%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="什么是网络爬虫？"><a href="#什么是网络爬虫？" class="headerlink" title="什么是网络爬虫？"></a>什么是网络爬虫？</h2><p>网络爬虫是一个自动提取网页的程序。</p>
<a id="more"></a>
<p>from wiki:</p>
<blockquote>
<p>网络蜘蛛（Web spider）也叫网络爬虫（Web crawler），蚂蚁（ant），自动检索工具（automatic indexer），或者（在FOAF软件概念中）网络疾走（WEB scutter），是一种“自动化浏览网络”的程序，或者说是一种网络机器人。它们被广泛用于互联网搜索引擎或其他类似网站，以获取或更新这些网站的内容和检索方式。它们可以自动采集所有其能够访问到的页面内容，以供搜索引擎做进一步处理（分检整理下载的页面），而使得用户能更快的检索到他们需要的信息。</p>
<p>网络爬虫始于一张被称作种子的统一资源地址（URLs）列表。当网络爬虫访问这些统一资源定位器时，它们会甄别出页面上所有的超链接，并将它们写入一张＂待访列表＂，即所谓＂爬行疆域＂（crawl frontier）。此疆域上的统一资源地址将被按照一套策略循环访问。如果爬虫在他执行的过程中复制归档和保存网站上的信息，这些档案通常储存，使他们可以被查看。阅读和浏览他们的网站上实时更新的信息，并保存为网站的“快照”。大容量的体积意味着网络爬虫只能在给定时间内下载有限数量的网页，所以要优先考虑其下载。高变化率意味着网页可能已经被更新或者删除。一些被服务器端软件生成的URLs（统一资源定位符）也使得网络爬虫很难避免检索到重复内容。</p>
</blockquote>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h2 id="网络爬虫的抓取策略"><a href="#网络爬虫的抓取策略" class="headerlink" title="网络爬虫的抓取策略"></a>网络爬虫的抓取策略</h2><p><img src="./01.png" alt=""><br>在爬虫系统中，待抓取URL队列是很重要的一部分。待抓取URL队列中的URL以什麽样的顺序排列也是一个很重要的问题，因为这涉及到先抓取那个页面，后抓取哪个页面。而决定这些URL排列顺序的方法，叫做抓取策略。网页的抓取策略可以分为深度优先、广度优先和最佳优先三种。深度优先在很多情况下会导致爬虫的陷入(trapped)问题，目前常见的是广度优先和最佳优先方法。</p>
<h3 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h3><p>深度优先，即从起始网页开始，选择一个URL，进入，分析这个网页中的URL，选择一个再进入。如此一个链接一个链接地深入追踪下去，处理完一条路线之后再处理下一条路线。</p>
<p>该类爬虫设计时较为简单。然而深度优先型网络爬虫存在一个问题：门户网站提供的链接往往最具价值，PageRank也很高，而每深入一层，网页价值和PageRank都会相应地有所下降。这暗示了重要网页通常距离种子较近，而过度深入抓取到的网页却价值很低。<br>由于这个缺陷，广度优先策略产生了。</p>
<h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><p>广度优先搜索策略是指在抓取过程中，在完成当前层次的搜索后，才进行下一层次的搜索。该演算法的设计和实现相对简单。在目前为覆盖尽可能多的网页，一般使用广度优先搜索方法。也有很多研究将广度优先搜索策略应用于聚焦爬虫中。其基本思想是认为与初始URL在一定链接距离内的网页具有主题相关性的概率很大。另外一种方法是将广度优先搜索与网页过滤技术结合使用，先用广度优先策略抓取网页，再将其中无关的网页过滤掉。这些方法的缺点在于，随著抓取网页的增多，大量的无关网页将被下载并过滤，演算法的效率将变低。</p>
<h3 id="最佳优先"><a href="#最佳优先" class="headerlink" title="最佳优先"></a>最佳优先</h3><p>最佳优先搜索策略按照一定的网页分析演算法，预测候选URL与目标网页的相似度，或与主题的相关性，并选取评价最好的一个或几个URL进行抓取。它只访问经过网页分析演算法预测为「有用」的网页。存在的一个问题是，在爬虫抓取路径上的很多相关网页可能被忽略，因为最佳优先策略是一种局部最优搜索演算法。因此需要将最佳优先结合具体的应用进行改进，以跳出局部最优点。研究表明，这样的闭环调整可以将无关网页数量降低30%~90%。</p>
]]></content>
      
        <categories>
            
            <category> 数据挖掘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> spider </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[xgboost 训练数据格式总结]]></title>
      <url>/2016/09/%E5%BE%85%E6%95%B4%E7%90%86/DM-xgboost-%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="xgboost-支持的数据格式"><a href="#xgboost-支持的数据格式" class="headerlink" title="xgboost 支持的数据格式"></a>xgboost 支持的数据格式</h3><p>xgboost 官方用的数据格式 DMatix 支持以下4种种数据格式导入或说转换：<br><a id="more"></a></p>
<ul>
<li><p>Libsvm</p>
</li>
<li><p>和 xgboost binary buffer file</p>
</li>
<li><p>Numpy 2D</p>
</li>
<li><p>scpiy.sparse</p>
</li>
</ul>
<p>其中 Libsvm  和 xgboost binary buffer file 是 以文件的形式的导入，这个一般我再批量导入训练的数据的时候是可以使用，但是线上预测就不可以了，我们总不能一条数据一个文件吧。</p>
<h3 id="使用数据的两种情况"><a href="#使用数据的两种情况" class="headerlink" title="使用数据的两种情况"></a>使用数据的两种情况</h3><p>一般情况下 ，训练模型的时候 ，是用libsvm格式,以文件形式批量导入数据。 离线训练模型以后，特征就确定了，当一个样本需要预测的话，直接提取特征，然后转化成数组，调一下保存的模型，预测。</p>
<p>但是很坑爹的是，xgboost 支持的数据格式 没有一种可以 同时用于 文件形式导入 和 在线数组形式导入 。 利用不同格式的数据导入同一个模型很容易出错， 这就涉及到格式转换，所有我想到了一种通用的格式方法。</p>
<h4 id="训练模型的时候："><a href="#训练模型的时候：" class="headerlink" title="训练模型的时候："></a>训练模型的时候：</h4><p>我们是批量导入数据，利用的是 sklearn 的 load_svmlight_file 模块， 将 svm 格式的数据转换为 sklrearn 常用的数据格式（实际上就是 scipy.sparse.csr.csr_matrix ），   导入 DMatrix</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_svmlight_file</span><br><span class="line">X, y = load_svmlight_file(<span class="string">"./data_set_02"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割数据：</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y,test_size=<span class="number">0.3</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换成 数据 DMatrix</span></span><br><span class="line">xg_train = xgb.DMatrix(X_train, label=y_train)</span><br><span class="line">xg_test = xgb.DMatrix(X_test, label=y_test)</span><br></pre></td></tr></table></figure>
<h4 id="预测模型的时候："><a href="#预测模型的时候：" class="headerlink" title="预测模型的时候："></a>预测模型的时候：</h4><p>将 libsvm 数据在线转换为  csr_matrix  导入到 DMatrix</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">libsvm = <span class="string">"3 2:1 174:1"</span>.split(<span class="string">' '</span>)[<span class="number">1</span>:]</span><br><span class="line">shape = <span class="number">25024</span></span><br><span class="line">vec = np.zeros((<span class="number">1</span>, shape))</span><br><span class="line"><span class="keyword">for</span> kv <span class="keyword">in</span> libsvm:</span><br><span class="line">    k, v = kv.split(<span class="string">':'</span>)</span><br><span class="line">    vec[<span class="number">0</span>][int(k)] = int(v)</span><br><span class="line">vec = csr_matrix(vec)</span><br><span class="line">xg_data = xgb.DMatrix(vec)</span><br><span class="line"></span><br><span class="line">pred = int(bst.predict(xg_data)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="这种转化方式的优点："><a href="#这种转化方式的优点：" class="headerlink" title="这种转化方式的优点："></a>这种转化方式的优点：</h3><ul>
<li><p>数据格式统一:  保存都是  libsvm 格式， 导入 DMatrix 都是 csr_matrix</p>
</li>
<li><p>节省空间和内存： 这两种都是常用且相当好的 稀疏向量压缩方法。</p>
</li>
<li><p>效率高：利用 sklearn.datasets.load_svmlight_file 和 numpy 极大的提高了效率</p>
</li>
<li><p>易于迁移： csr_matrix 格式的数据以后也可以直接用于sklearn库的模型的训练</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 数据挖掘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> xgboost </tag>
            
            <tag> 训练数据 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[时间序列预测（ARIMA）原理]]></title>
      <url>/2016/09/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/DM-%E6%80%BB%E7%BB%93-ARIMA%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>短期预测是时间序列分析的主要目的。时间序列分析的理论基础很简单：设若时间序列（或随机过程）的任一元素yt与其前期元素（yt-1、yt-2等）之间存在着某种关联，则我们可以根据该时间序列的既往观测值来预测其在未来的取值。</p>
<a id="more"></a>
<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="AR模型"><a href="#AR模型" class="headerlink" title="AR模型"></a>AR模型</h3><p>自回归模型（英语：Autoregressive model，简称AR模型），是统计上一种处理时间序列的方法，用同一变数例如x的之前各期，亦即 X1至 X(t-1)来预测本期Xt的表现，并假设它们为一线性关系。因为这是从回归分析中的线性回归发展而来，只是不用  x预测 {\displaystyle y} y，而是用 x预测x（自己）；所以叫做自回归。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>自回归方法的优点是所需资料不多，可用自身变数数列来进行预测。但是这种方法受到一定的限制。</li>
<li>必须具有自相关，自相关系数是关键。如果自相关系数(R)小于0.5，则不宜采用，否则预测结果极不准确。</li>
<li>自回归只能适用于预测与自身前期相关的经济现象，即受自身历史因素影响较大的经济现象，如矿的开采量，各种自然资源产量等；对于受社会因素影响较大的经济现象，不宜采用自回归，而应改采可纳入其他变数的向量自回归模型。</li>
</ul>
<h3 id="MA-模型"><a href="#MA-模型" class="headerlink" title="MA 模型"></a>MA 模型</h3><p>滑动平均模型（简称MA模型）,滑动平均模型描述的是自回归部分的误差累计。<br>为简化估计参数的工作量，我们当然希望模型当中的参数尽可能地少。于是便有了引进移动平均过程MA（q）的必要。</p>
<h3 id="ARMA模型"><a href="#ARMA模型" class="headerlink" title="ARMA模型"></a>ARMA模型</h3><p>ARMA模型的全称是自回归移动平均(auto regression moving average)模型，它是目前最常用的拟合平稳序列的模型，由自回归模型（简称AR模型）与滑动平均模型（简称MA模型）为基础“混合”构成。</p>
<h3 id="ARIMA模型"><a href="#ARIMA模型" class="headerlink" title="ARIMA模型"></a>ARIMA模型</h3><p>差分整合移动平均自回归模型，又称整合移动平均自回归模型（移动也可称作滑动）(Autoregressive Integrated Moving Average Model,简记ARIMA)<br>ARIMA（p，d，q）中，AR是”自回归”，p为自回归项数；MA为”滑动平均”，q为滑动平均项数，d为使之成为平稳序列所做的差分次数（阶数）。“差分”一词虽未出现在ARIMA的英文名称中，却是关键步骤。</p>
<p>当时间序列本身不是平稳的时候，如果它的增量，即的一次差分，稳定在零点附近，可以将看成是平稳序列。在实际的问题中，所遇到的多数非平稳序列可以通过一次或多次差分后成为平稳时间序列，则可以建立模型.</p>
<p>这说明任何非平稳序列只要通过适当阶数的差分运算实现差分后平稳，就可以对差分后序列进行ARIMA模型拟合了。</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>差分:<br>自回归<br>移动平均</p>
<h2 id="ARIMA模型运用的流程"><a href="#ARIMA模型运用的流程" class="headerlink" title="ARIMA模型运用的流程"></a>ARIMA模型运用的流程</h2><ol>
<li>根据时间序列的散点图、自相关函数和偏自相关函数图识别其平稳性。</li>
<li>对非平稳的时间序列数据进行平稳化处理。直到处理后的自相关函数和偏自相关函数的数值非显著非零。</li>
<li>根据所识别出来的特征建立相应的时间序列模型。平稳化处理后，若偏自相关函数是截尾的，而自相关函数是拖尾的，则建立AR模型；若偏自相关函数是拖尾的，而自相关函数是截尾的，则建立MA模型；若偏自相关函数和自相关函数均是拖尾的，则序列适合ARMA模型。</li>
<li>参数估计，检验是否具有统计意义。</li>
<li>假设检验，判断（诊断）残差序列是否为白噪声序列。</li>
<li>利用已通过检验的模型进行预测。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 数据挖掘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ARIMA </tag>
            
            <tag> 时间序列预测 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TF-IDF介绍及python实例]]></title>
      <url>/2016/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ML-%E6%80%BB%E7%BB%93-TF-IDF%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="TF-IDF介绍"><a href="#TF-IDF介绍" class="headerlink" title="TF-IDF介绍"></a>TF-IDF介绍</h2><p>TF-IDF（Term Frequency–Inverse Document Frequency）是一种用于资讯检索与文本挖掘的常用加权技术。TF-IDF是一种统计方法，用以评估一个字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。<a id="more"></a><br>TF-IDF的主要思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。TF-IDF实际上是：<code>TF * IDF</code>。</p>
<h3 id="词频（Term-Frequency，TF）"><a href="#词频（Term-Frequency，TF）" class="headerlink" title="词频（Term Frequency，TF）"></a>词频（Term Frequency，TF）</h3><p>词频指的是某一个给定的词语在该文件中出现的频率。即词w在文档d中出现的次数count(w, d)和文档d中总词数size(d)的比值。<br><code>tf(w,d) = count(w, d) / size(d)</code><br>这个数字是对词数(term count)的归一化，以防止它偏向长的文件。（同一个词语在长文件里可能会比短文件有更高的词数，而不管该词语重要与否。）</p>
<h3 id="逆向文件频率（Inverse-Document-Frequency，IDF）"><a href="#逆向文件频率（Inverse-Document-Frequency，IDF）" class="headerlink" title="逆向文件频率（Inverse Document Frequency，IDF）"></a>逆向文件频率（Inverse Document Frequency，IDF）</h3><p>逆向文件频率是一个词语普遍重要性的度量。某一特定词语的IDF，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取对数得到。即文档总数n与词w所出现文件数docs(w, D)比值的对数。　　<br><code>idf = log(n / docs(w, D))</code></p>
<p>某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于过滤掉常见的词语，保留重要的词语。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>TF-IDF权重计算方法经常会和余弦相似性（cosine similarity）一同使用于向量空间模型中，用以判断两份文件之间的相似性。</p>
<h2 id="TFIDF的理论依据及不足"><a href="#TFIDF的理论依据及不足" class="headerlink" title="TFIDF的理论依据及不足"></a>TFIDF的理论依据及不足</h2><p>TFIDF算法是建立在这样一个假设之上的：对区别文档最有意义的词语应该是那些在文档中出现频率高，而在整个文档集合的其他文档中出现频率少的词语，所以如果特征空间坐标系取TF词频作为测度，就可以体现同类文本的特点。另外考虑到单词区别不同类别的能力，TFIDF法认为一个单词出现的文本频数越小，它区别不同类别文本的能力就越大。因此引入了逆文本频度IDF的概念，以TF和IDF的乘积作为特征空间坐标系的取值测度，并用它完成对权值TF的调整，调整权值的目的在于突出重要单词，抑制次要单词。但是在本质上IDF是一种试图抑制噪声的加权，并且单纯地认为文本频率小的单词就越重要，文本频率大的单词就越无用，显然这并不是完全正确的。IDF的简单结构并不能有效地反映单词的重要程度和特征词的分布情况，使其无法很好地完成对权值调整的功能，所以TFIDF法的精度并不是很高。</p>
<p>此外，在TFIDF算法中并没有体现出单词的 <strong>位置信息</strong>，对于Web文档而言，权重的计算方法应该体现出HTML的结构特征。特征词在不同的标记符中对文章内容的反映程度不同，其权重的计算方法也应不同。因此应该对于处于网页不同位置的特征词分别赋予不同的系数，然后乘以特征词的词频，以提高文本表示的效果。</p>
<h2 id="Python中计算TF-IDF-实例"><a href="#Python中计算TF-IDF-实例" class="headerlink" title="Python中计算TF-IDF 实例"></a>Python中计算TF-IDF 实例</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>scikit-learn包</p>
<p>jieba 分词包</p>
<h3 id="计算TF-IDF"><a href="#计算TF-IDF" class="headerlink" title="计算TF-IDF"></a>计算TF-IDF</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> jieba.posseg <span class="keyword">as</span> pseg</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> feature_extraction</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br><span class="line"><span class="comment">#获取文件列表（该目录下放着100份文档）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFilelist</span><span class="params">(argv)</span> :</span></span><br><span class="line">    path = argv[<span class="number">1</span>]</span><br><span class="line">    filelist = []</span><br><span class="line">    files = os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files :</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">0</span>] == <span class="string">'.'</span>) :</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            filelist.append(f)</span><br><span class="line">    <span class="keyword">return</span> filelist,path</span><br><span class="line"><span class="comment">#对文档进行分词处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fenci</span><span class="params">(argv,path)</span> :</span></span><br><span class="line">    <span class="comment">#保存分词结果的目录</span></span><br><span class="line">    sFilePath = <span class="string">'./segfile'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(sFilePath) :</span><br><span class="line">        os.mkdir(sFilePath)</span><br><span class="line">    <span class="comment">#读取文档</span></span><br><span class="line">    filename = argv</span><br><span class="line">    f = open(path+filename,<span class="string">'r+'</span>)</span><br><span class="line">    file_list = f.read()</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#对文档进行分词处理，采用默认模式</span></span><br><span class="line">    seg_list = jieba.cut(file_list,cut_all=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#对空格，换行符进行处理</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> seg <span class="keyword">in</span> seg_list :</span><br><span class="line">　　　　 seg = <span class="string">''</span>.join(seg.split())</span><br><span class="line">        <span class="keyword">if</span> (seg != <span class="string">''</span> <span class="keyword">and</span> seg != <span class="string">"\n"</span> <span class="keyword">and</span> seg != <span class="string">"\n\n"</span>) :</span><br><span class="line">            result.append(seg)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将分词后的结果用空格隔开，保存至本地。比如"我来到北京清华大学"，分词结果写入为："我 来到 北京 清华大学"</span></span><br><span class="line">    f = open(sFilePath+<span class="string">"/"</span>+filename+<span class="string">"-seg.txt"</span>,<span class="string">"w+"</span>)</span><br><span class="line">    f.write(<span class="string">' '</span>.join(result))</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取100份已分词好的文档，进行TF-IDF计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Tfidf</span><span class="params">(filelist)</span> :</span></span><br><span class="line">　　path = <span class="string">'./segfile／'</span></span><br><span class="line">    corpus = []  <span class="comment">#存取100份文档的分词结果</span></span><br><span class="line">    <span class="keyword">for</span> ff <span class="keyword">in</span> filelist :</span><br><span class="line">        fname = path + ff</span><br><span class="line">        f = open(fname,<span class="string">'r+'</span>)</span><br><span class="line">        content = f.read()</span><br><span class="line">        f.close()</span><br><span class="line">        corpus.append(content)    </span><br><span class="line"></span><br><span class="line">    vectorizer = CountVectorizer()    </span><br><span class="line">    transformer = TfidfTransformer()</span><br><span class="line">    tfidf = transformer.fit_transform(vectorizer.fit_transform(corpus))</span><br><span class="line"></span><br><span class="line">    word = vectorizer.get_feature_names() <span class="comment">#所有文本的关键字</span></span><br><span class="line">    weight = tfidf.toarray()              <span class="comment">#对应的tfidf矩阵</span></span><br><span class="line"></span><br><span class="line">    sFilePath = <span class="string">'./tfidffile'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(sFilePath) :</span><br><span class="line">        os.mkdir(sFilePath)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里将每份文档词语的TF-IDF写入tfidffile文件夹中保存</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(weight)) :</span><br><span class="line">　　　　 <span class="keyword">print</span> <span class="string">u"--------Writing all the tf-idf in the"</span>,i,<span class="string">u" file into "</span>,sFilePath+<span class="string">'/'</span>+string.zfill(i,<span class="number">5</span>)+<span class="string">'.txt'</span>,<span class="string">"--------"</span></span><br><span class="line">        f = open(sFilePath+<span class="string">'/'</span>+string.zfill(i,<span class="number">5</span>)+<span class="string">'.txt'</span>,<span class="string">'w+'</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(word)) :</span><br><span class="line">            f.write(word[j]+<span class="string">"    "</span>+str(weight[i][j])+<span class="string">"\n"</span>)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span> :</span><br><span class="line">    (allfile,path) = getFilelist(sys.argv)</span><br><span class="line">　　<span class="keyword">for</span> ff <span class="keyword">in</span> allfile :</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Using jieba on "</span>+ff</span><br><span class="line">        fenci(ff,path)</span><br><span class="line"></span><br><span class="line">    Tfidf(allfile)</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> TF-IDF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用一个流程解决所有机器学习难题的学习]]></title>
      <url>/2016/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ML-%E6%80%BB%E7%BB%93-%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A1%86%E6%9E%B6%E8%A7%A3%E5%86%B3%E6%89%80%E6%9C%89%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%9A%BE%E9%A2%98%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.kaggle.com/2016/07/21/approaching-almost-any-machine-learning-problem-abhishek-thakur/" target="_blank" rel="noopener">Approaching (Almost) Any Machine Learning Problem | Abhishek Thakur</a><br><a id="more"></a></p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="保持训练数据和检验数据中标签的一致性-："><a href="#保持训练数据和检验数据中标签的一致性-：" class="headerlink" title="保持训练数据和检验数据中标签的一致性 ："></a>保持训练数据和检验数据中标签的一致性 ：</h3><p>就是在模型训练的时候，训练的数据和测试的数据label的分布是一样的。也就是是分层抽样的意思， 好处是：在训练中不会有倾向。</p>
<h3 id="one-hot-编码"><a href="#one-hot-编码" class="headerlink" title="one-hot 编码 :"></a>one-hot 编码 :</h3><p>又称一位有效编码，其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候，其中只有一位有效。<br>可以这样理解，对于每一个特征，如果它有m个可能值，那么经过独热编码后，就变成了m个二元特征。并且，这些特征互斥，每次只有一个激活。因此，数据会变成稀疏的。</p>
<p>这样做的好处主要有：</p>
<ul>
<li><p>解决了分类器不好处理属性数据的问题</p>
</li>
<li><p>在一定程度上也起到了扩充特征的作用<br>我们基于python和Scikit-learn写一个简单的例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line">enc = preprocessing.OneHotEncoder()</span><br><span class="line">enc.fit([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br><span class="line">enc.transform([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>]]).toarray()</span><br><span class="line"></span><br><span class="line">---out---</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>在采用机器学习模型前， 数据必须要转化成一个列表（Tabular）的形式。这是最消耗时间，也是最困难的，其过程如下：<br><img src="01.png" alt=""></p>
<h2 id="标签的类型"><a href="#标签的类型" class="headerlink" title="标签的类型"></a>标签的类型</h2><p>这些标签定义了所要解决的问题，可以有不同的形式：</p>
<ul>
<li>单行，二进制值（分类问题，一个样本只属于一个种类，且种类总数只有2个）</li>
<li>单行，真值（回归问题，预测唯一值）</li>
<li>多行，二进制值（分类问题，一个样本属于一个分类，但是有2个或者多个种类）</li>
<li>多行，真值（回归问题，预测多值）</li>
<li>多个标签（分类问题，一个样本可以属于不同的种类）</li>
</ul>
<h2 id="评估价值"><a href="#评估价值" class="headerlink" title="评估价值"></a>评估价值</h2><p>对于任何机器学习难题，我们必须知道要怎样评估自己的研究结果，或者说，评估的价值和对象是什么。为了防止二进制分类中的 <strong>负偏（skewed）的问题</strong> ，我们通常会选择在运行特征曲线（ROC AUC 或者简单的 AUC）的接收器（receiver）下方区域进行评估。</p>
<p>在多标签和多类型分类难题中，我们通常选择分类交互熵，或者多类型的 log loss ，以及在回归问题中降低平方误差。</p>
<h2 id="资料库"><a href="#资料库" class="headerlink" title="资料库"></a>资料库</h2><p>观看和进行数据处理：Pandas<br>各种机器学习模型：Scikit-learn<br>最好的梯度渐进数据库看：xgboots<br>神经网络：keras<br>绘图数据：matplotlib<br>监控进度：tqdm</p>
<h2 id="机器学习框架"><a href="#机器学习框架" class="headerlink" title="机器学习框架"></a>机器学习框架</h2><p><img src="02.png" alt=""></p>
<h3 id="定义问题。"><a href="#定义问题。" class="headerlink" title="定义问题。"></a>定义问题。</h3><p>这可以通过标签确定。研究者首先要明确，你的问题是二进制的、多种类的、多标签分类的还是回归问题。在定义了问题之后，我们可以把数据分为两个不同的部分，如下文描述，一部分是训练数据，另一部分是检验数据。</p>
<h3 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h3><p>把数据进行“训练”和“检验”的区分，必须要根据数据标签进行。在所有的分类问题中，都要试用分层分割。在Python中，你可以使用Scikit-learn来轻易地做到。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">form sklearn.cross_validation <span class="keyword">import</span> StratifiedKFold</span><br><span class="line">eval_size = <span class="number">0.10</span></span><br><span class="line">kf = StratifiedKFold(y, round(<span class="number">1.</span> / eval_size))</span><br><span class="line">train_indices, valid_indices = next(iter(kf))</span><br><span class="line">X_train, y_train = X[train_indices], y[train_indices]</span><br><span class="line">X_valid, y_valid = X[valid_indices], y[valid_indices]</span><br></pre></td></tr></table></figure>
<p>在回归任务中，一个简单的K-Fold分割应该就足够了。但是，有一些复杂的方法，倾向于 <strong>保持训练数据和检验数据中标签的一致性</strong>。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">form sklearn.cross_validation <span class="keyword">import</span> KFold</span><br><span class="line">eval_size = <span class="number">0.10</span></span><br><span class="line">kf = KFold(y, round(<span class="number">1.</span> / eval_size))</span><br><span class="line">train_indices, valid_indices = next(iter(kf))</span><br><span class="line">X_train, y_train = X[train_indices], y[train_indices]</span><br><span class="line">X_valid, y_valid = X[valid_indices], y[valid_indices]</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，我选择 eval_size 或者 size of the validation set作为全部数据的10%，但是，你可以根据自己拥有的数据选择赋值。</p>
<p>在数据分层完成后，先把它们搁在一旁不要碰。在训练数据集上的任何操作都要保存，最后会运用到检验数据集中。而检验数据集，在任何情况下都不应该跟训练数据集混淆。如果能做到这样，就会得到非常好的分数。否则，你可能建立的是一个没多大用，且过度拟合的模型。</p>
<h3 id="不同变量的处理"><a href="#不同变量的处理" class="headerlink" title="不同变量的处理"></a>不同变量的处理</h3><h4 id="数据变量"><a href="#数据变量" class="headerlink" title="数据变量"></a>数据变量</h4><p>首先把数据变量排除。这些变量并不需要任何的处理，我们可以使用标准的机器学习模型来处理。</p>
<h4 id="种类变量"><a href="#种类变量" class="headerlink" title="种类变量"></a>种类变量</h4><p>在种类变量的处理上，我们有两个方式：</p>
<p>把种类数据变成标签:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"></span><br><span class="line">lbl_enc = LabelEncoder()</span><br><span class="line">lbl_enc.fit(catagorical_features)</span><br><span class="line">xtrain_cat = lbl_enc.trainsform(x.train[catagorical_features])</span><br></pre></td></tr></table></figure></p>
<p>把标签转化成二进制变量（one-hot 编码<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"></span><br><span class="line">lbl_ohe = OneHotEncoder()</span><br><span class="line">lbl_ohe.fit(catagorical_features)</span><br><span class="line">xtrain_cat = llbl_ohe.trainsform(x.train[catagorical_features])</span><br></pre></td></tr></table></figure></p>
<h4 id="文本变量"><a href="#文本变量" class="headerlink" title="文本变量"></a>文本变量</h4><p>可以使用<code>CountVectorizer</code>或<code>TfidfVectorizer</code> ：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line">ctv = CountVectorizer()</span><br><span class="line">text_data_train = ctv.fit_transtrom(text_data_train)</span><br></pre></td></tr></table></figure>
<p>TfidfVectorizer的表现一直都比其他工具要好，据我观察，以下的参数几乎每次都有效：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line">tfv = TfidfVectorizer(min_df=<span class="number">3</span>, max_features=<span class="keyword">None</span>, strip_accents=<span class="string">'unicode'</span>, analyzer=<span class="string">'word'</span>, token_pattern=<span class="string">r'\w&#123;1,&#125;'</span>,ngram_range=(<span class="number">1</span>, <span class="number">2</span>), use_id=<span class="number">1</span>, sublinear_tf=<span class="number">1</span>, stop_words=<span class="string">'english'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="stacker"><a href="#stacker" class="headerlink" title="stacker"></a>stacker</h3><p>叠式储存器（stacker） 模块。Stacker并不是一个模型stacker，而是一个特征stacker。在上文提到的处理步骤完成后，不同的特征可以被结合起来，用到Stacker模块中。</p>
<p>你可以使用numpyhstack或者sparse hstack把所有的特征水平堆叠起来，这取决你拥有的是稀疏或者紧密特征。</p>
<p>注意，此时数据没有被标准化，我们在上面的特征中不能使用线性模型。要使用线性模型，你可以从scikit-learn上使用Normalizer或StandardScaler。这些规范化的方法只有在紧密特征中才起作用，在稀疏特征中不会有好的效果。</p>
<h3 id="特征的选择"><a href="#特征的选择" class="headerlink" title="特征的选择"></a>特征的选择</h3><p>特征的选择，有多种方式可以实现。最常见的是贪婪特征的选择（正向或反向）。在贪婪特征的选择上，我们选择一个特征，训练一个模型并用一个修正的评估值来评估模型的性能。我们不断增加或者移除一个又一个特征，并逐步记录模型的表现。随后，我们选出得分最高的特征。必须说明的是，这种方法并不是完美的，需要根据要求改变或修正。</p>
<p>其他更快的特征选择方法包括：从一个模型中选择最佳的特征。我们可以观察一个逻辑模型的稀疏，或者训练一个随机森林，来选择最佳的特征，然后在其他的机器学习模型上使用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">form sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"></span><br><span class="line">clf = RandomForestClassifer(n_estimators=<span class="number">100</span>, n_jobs=<span class="number">-1</span>)</span><br><span class="line">clf.fit(X, y)</span><br><span class="line">X_selected = clf.transform(X)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"></span><br><span class="line">params=&#123;&#125;</span><br><span class="line">model = xgb.train(params, dtrain, num_bost_rund=<span class="number">100</span>)</span><br><span class="line">sorted(model.get_fscore().items(), key=<span class="keyword">lambda</span> t: =-t[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>记得保持较少数量的Estimator，并对超参数进行最小优化，这样你就不会过度拟合。</p>
<p>特征的选择也可以通过Gradient Boosting Machines来实现。如果我们使用xgboost而不是在 scikit-learn中使用GBM时，效果会很好。因为xgboost速度更快、可扩展性更高。</p>
<p>我们也可以使用RandomForestClassifier 、RandomForestRegressor 和xgboost，在稀疏数据集中进行特征选择。</p>
<p>另一个较为流行的方法是基于chi-2的特征选择。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在这儿，我们使用Chi2和 SelectKBes从数据中选择20个特征。这也变成了我们希望优化，来提升机器学习模型结果的超参数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line"></span><br><span class="line">skb = SelectKBest(chi2, k=<span class="number">20</span>)</span><br><span class="line">skb.fit_transfrom(X,y)</span><br></pre></td></tr></table></figure></p>
<h3 id="模型的选择"><a href="#模型的选择" class="headerlink" title="模型的选择"></a>模型的选择</h3><p><img src="scikit-learn algorithm cheat sheet copy.png" alt=""></p>
<h3 id="超参数优化"><a href="#超参数优化" class="headerlink" title="超参数优化"></a>超参数优化</h3><p>我该优化哪些参数？我怎样才能选到最匹配的参数？这是人们考虑得最多的两个问题。没有在大量的数据库上体验过不同的模型和参数，是无法回答这一问题的。还有一点，许多人并不愿意分享这方面的经验。所幸我还有一点经验，也愿意分享：</p>
<p><img src="03.png" alt="RS*指不能确定合适的值"></p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> scikit-learn </tag>
            
            <tag> kaggle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于决策树的组合算法之GBRT]]></title>
      <url>/2016/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ML-%E6%80%BB%E7%BB%93-GBRT/</url>
      <content type="html"><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><h2 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h2><h2 id="提升树"><a href="#提升树" class="headerlink" title="提升树"></a>提升树</h2><h2 id="梯度提升树"><a href="#梯度提升树" class="headerlink" title="梯度提升树"></a>梯度提升树</h2><h2 id="xgboost"><a href="#xgboost" class="headerlink" title="xgboost"></a>xgboost</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.52cs.org/?p=429" target="_blank" rel="noopener">Boosted Tree</a><br><a href="http://www.jianshu.com/p/005a4e6ac775" target="_blank" rel="noopener">GBDT：梯度提升决策树</a><br><a href="http://blog.csdn.net/dream_angel_z/article/details/48085889" target="_blank" rel="noopener">机器学习算法-梯度树提升GTB（GBRT</a><br><a href="https://xgboost.readthedocs.io/en/latest/" target="_blank" rel="noopener">XGBoost</a><br><a href="http://www.cnblogs.com/liuwu265/p/4693113.html" target="_blank" rel="noopener">提升树算法 详解</a></p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> GBRT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用scikit-learn进行数据挖掘入门]]></title>
      <url>/2016/07/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/DM-%E6%80%BB%E7%BB%93-%E4%BD%BF%E7%94%A8scikit-learn%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p><a href="http://scikit-learn.org/stable/tutorial/basic/tutorial.html" target="_blank" rel="noopener">An introduction to machine learning with scikit-learn</a></p>
<a id="more"></a>
<h2 id="导入sklearn自带的数据"><a href="#导入sklearn自带的数据" class="headerlink" title="导入sklearn自带的数据"></a>导入sklearn自带的数据</h2><p>数据集是一个类字典对象，包括了全部的数据和该数据的元数据。数据保存在.data 成员中，该成员是（n个向量*m个特征）的数组。在有监督学习中，类别变量存储在.target成员中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line">digits = datasets.load_digits()</span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="keyword">print</span> (digits.data)</span><br><span class="line"><span class="keyword">print</span> (digits.target)</span><br><span class="line"><span class="keyword">print</span> (digits.data.shape)</span><br><span class="line"><span class="keyword">print</span> (digits.target.shape)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">    [[  <span class="number">0.</span>   <span class="number">0.</span>   <span class="number">5.</span> ...,   <span class="number">0.</span>   <span class="number">0.</span>   <span class="number">0.</span>]</span><br><span class="line">     [  <span class="number">0.</span>   <span class="number">0.</span>   <span class="number">0.</span> ...,  <span class="number">10.</span>   <span class="number">0.</span>   <span class="number">0.</span>]</span><br><span class="line">     [  <span class="number">0.</span>   <span class="number">0.</span>   <span class="number">0.</span> ...,  <span class="number">16.</span>   <span class="number">9.</span>   <span class="number">0.</span>]</span><br><span class="line">     ...,</span><br><span class="line">     [  <span class="number">0.</span>   <span class="number">0.</span>   <span class="number">1.</span> ...,   <span class="number">6.</span>   <span class="number">0.</span>   <span class="number">0.</span>]</span><br><span class="line">     [  <span class="number">0.</span>   <span class="number">0.</span>   <span class="number">2.</span> ...,  <span class="number">12.</span>   <span class="number">0.</span>   <span class="number">0.</span>]</span><br><span class="line">     [  <span class="number">0.</span>   <span class="number">0.</span>  <span class="number">10.</span> ...,  <span class="number">12.</span>   <span class="number">1.</span>   <span class="number">0.</span>]]</span><br><span class="line">    [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> ..., <span class="number">8</span> <span class="number">9</span> <span class="number">8</span>]</span><br><span class="line">    (<span class="number">1797</span>, <span class="number">64</span>)</span><br><span class="line">    (<span class="number">1797</span>,)</span><br></pre></td></tr></table></figure>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>数据集总是一个二维数组，格式为（n个向量 * m个特征）,尽管原始数据可能是其他不同的格式。在digits数据集中，每个原始数据是用(8,8)表示的图像(在digits.data中被压缩到一行)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">digits.images[<span class="number">0</span>]</span><br><span class="line">---</span><br><span class="line">    array([[  <span class="number">0.</span>,   <span class="number">0.</span>,   <span class="number">5.</span>,  <span class="number">13.</span>,   <span class="number">9.</span>,   <span class="number">1.</span>,   <span class="number">0.</span>,   <span class="number">0.</span>],</span><br><span class="line">           [  <span class="number">0.</span>,   <span class="number">0.</span>,  <span class="number">13.</span>,  <span class="number">15.</span>,  <span class="number">10.</span>,  <span class="number">15.</span>,   <span class="number">5.</span>,   <span class="number">0.</span>],</span><br><span class="line">           [  <span class="number">0.</span>,   <span class="number">3.</span>,  <span class="number">15.</span>,   <span class="number">2.</span>,   <span class="number">0.</span>,  <span class="number">11.</span>,   <span class="number">8.</span>,   <span class="number">0.</span>],</span><br><span class="line">           [  <span class="number">0.</span>,   <span class="number">4.</span>,  <span class="number">12.</span>,   <span class="number">0.</span>,   <span class="number">0.</span>,   <span class="number">8.</span>,   <span class="number">8.</span>,   <span class="number">0.</span>],</span><br><span class="line">           [  <span class="number">0.</span>,   <span class="number">5.</span>,   <span class="number">8.</span>,   <span class="number">0.</span>,   <span class="number">0.</span>,   <span class="number">9.</span>,   <span class="number">8.</span>,   <span class="number">0.</span>],</span><br><span class="line">           [  <span class="number">0.</span>,   <span class="number">4.</span>,  <span class="number">11.</span>,   <span class="number">0.</span>,   <span class="number">1.</span>,  <span class="number">12.</span>,   <span class="number">7.</span>,   <span class="number">0.</span>],</span><br><span class="line">           [  <span class="number">0.</span>,   <span class="number">2.</span>,  <span class="number">14.</span>,   <span class="number">5.</span>,  <span class="number">10.</span>,  <span class="number">12.</span>,   <span class="number">0.</span>,   <span class="number">0.</span>],</span><br><span class="line">           [  <span class="number">0.</span>,   <span class="number">0.</span>,   <span class="number">6.</span>,  <span class="number">13.</span>,  <span class="number">10.</span>,   <span class="number">0.</span>,   <span class="number">0.</span>,   <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="学习和预测"><a href="#学习和预测" class="headerlink" title="学习和预测"></a>学习和预测</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建SVM的实例，并设置参数</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line">clf = svm.SVC(gamma = <span class="number">0.001</span>, C = <span class="number">100.</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># train</span></span><br><span class="line"><span class="comment"># 用除了最后一个图像的digits数据集作为训练数据集，</span></span><br><span class="line">clf.fit(digits.data[:<span class="number">-1</span>],digits.target[:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">SVC(C=<span class="number">100.0</span>, cache_size=<span class="number">200</span>, class_weight=<span class="keyword">None</span>, coef0=<span class="number">0.0</span>,decision_function_shape=<span class="keyword">None</span>, degree=<span class="number">3</span>, gamma=<span class="number">0.001</span>, kernel=<span class="string">'rbf'</span>,max_iter=<span class="number">-1</span>, probability=<span class="keyword">False</span>, random_state=<span class="keyword">None</span>, shrinking=<span class="keyword">True</span>,tol=<span class="number">0.001</span>, verbose=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对最后一个数据进行预测</span></span><br><span class="line">clf.predict(digits.data[<span class="number">-1</span>:])</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">array([<span class="number">8</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 真实类别</span></span><br><span class="line">digits.target[<span class="number">-1</span>:]</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">array([<span class="number">8</span>])</span><br></pre></td></tr></table></figure>
<h2 id="使用pickle持久化训练好的模型"><a href="#使用pickle持久化训练好的模型" class="headerlink" title="使用pickle持久化训练好的模型"></a>使用pickle持久化训练好的模型</h2><p>在文件中, 字符串可以很方便的读取写入. 数字可能稍微麻烦一些, 因为 read() 方法只返回字符串, 我们还需要将其传给 int() 这样的函数, 使其将如 ‘123’ 的字符串转为数字 123. 但是, 如果要保存更复杂的数据类型, 如列表, 字典, 或者类的实例, 那么就会更复杂了.</p>
<p>为了让用户在时常的编程和测试时保存复杂的数据类型, Python 提供了标准模块, 称为 pickle. 这个模块可以将几乎任何的 Python 对象 (甚至是 Python 的代码), 转换为字符串表示; 这个过程称为 pickling. 而要从里面重新构造回原来的对象, 则称为 unpickling. 在 pickling 和 unpickling 之间, 表示这些对象的字符串表示, 可以存于一个文件, 也可以通过网络在远程机器间传输.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment"># 持久化到内存（字符串）</span></span><br><span class="line">s = pickle.dumps(clf)</span><br><span class="line">clf2 = pickle.loads(s)</span><br><span class="line"><span class="comment"># 持久化到文件</span></span><br><span class="line">pickle.dump(clf, open(<span class="string">'bayes.pk'</span>, <span class="string">'wb'</span>))</span><br><span class="line">clf2 = pickle.load(open(<span class="string">'bayes.pk'</span>, <span class="string">'rb'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="使用joblib持久化训练好的模型"><a href="#使用joblib持久化训练好的模型" class="headerlink" title="使用joblib持久化训练好的模型"></a>使用joblib持久化训练好的模型</h2><p>joblib是scikit-learn自带的工具，为<code>numpy array</code>做了优化。<br>joblib在大数据上表现更加高效，但只能序列化到磁盘中，而非字符串。<br>joblib.dump方法在当前目录产生了多个文件，<code>*.npy</code>文件用于保存<code>numpy array</code> 类型的变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line">joblib.dump(clf, <span class="string">'filename.pkl'</span>)</span><br><span class="line">clf2 = joblib.load(<span class="string">'filename.pkl'</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 数据挖掘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> scikit-learn </tag>
            
            <tag> ML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十分钟理解交叉验证]]></title>
      <url>/2016/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ML-%E6%80%BB%E7%BB%93-%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>交叉验证(Cross-validation)主要用于模型训练或建模应用中，如分类预测、PCR、PLS回归建模等。在给定的样本空间中，拿出大部分样本作为训练集来训练模型，剩余的小部分样本使用刚建立的模型进行预测，并求这小部分样本的预测误差或者预测精度，同时记录它们的加和平均值。这个过程迭代K次，即K折交叉。其中，把每个样本的预测误差平方加和，称为PRESS(predicted Error Sum of Squares)。<a id="more"></a></p>
<p>我们使用交叉验证方法的目的主要有3个：</p>
<ul>
<li>从有限的学习数据中获取尽可能多的有效信息；</li>
<li>交叉验证从多个方向开始学习样本的，可以有效的避免陷入局部最小值；</li>
<li>可以在一定程度上避免过拟合问题。</li>
</ul>
<h2 id="交叉验证包含以下步骤："><a href="#交叉验证包含以下步骤：" class="headerlink" title="交叉验证包含以下步骤："></a>交叉验证包含以下步骤：</h2><ul>
<li>保留一个样本数据集。</li>
<li>用剩余部分训练模型。</li>
<li>用保留的数据集验证模型。这样做有助于了解模型的有效性。</li>
</ul>
<h2 id="交叉验证的注意点"><a href="#交叉验证的注意点" class="headerlink" title="交叉验证的注意点"></a>交叉验证的注意点</h2><ul>
<li>应该使用较大比例的数据集来训练模型，否则会导致失败，最终得到偏误很大的模型。</li>
<li>验证用的数据点，其比例应该恰到好处。如果太少，会导致验证模型有效性时，得到的结果波动较大。</li>
<li>训练和验证过程应该重复多次。训练集和验证集不能一成不变。这样有助于验证模型有效性。</li>
</ul>
<h2 id="交叉验证的常用方法"><a href="#交叉验证的常用方法" class="headerlink" title="交叉验证的常用方法"></a>交叉验证的常用方法</h2><p>交叉验证有很多方法。下面介绍其中几种：</p>
<h3 id="“验证集”法"><a href="#“验证集”法" class="headerlink" title="“验证集”法"></a>“验证集”法</h3><p>保留 50% 的数据集用作验证，剩下 50% 训练模型。之后用验证集测试模型表现。不过，这个方法的主要缺陷是，由于只使用了 50% 数据训练模型，原数据中一些重要的信息可能被忽略。也就是说，会有较大偏误。</p>
<h3 id="留一法交叉验证-LOOCV"><a href="#留一法交叉验证-LOOCV" class="headerlink" title="留一法交叉验证 ( LOOCV )"></a>留一法交叉验证 ( LOOCV )</h3><p>这种方法只保留一个数据点用作验证，用剩余的数据集训练模型。然后对每个数据点重复这个过程。这个方法有利有弊：</p>
<p>由于使用了所有数据点，所以偏差较低。</p>
<p>验证过程重复了 n 次（ n 为数据点个数），导致执行时间很长。</p>
<p>由于只使用一个数据点验证，这个方法导致模型有效性的差异更大。得到的估计结果深受此点的影响。如果这是个离群点，会引起较大偏差。</p>
<h3 id="K-层交叉验证-K-fold-cross-validation"><a href="#K-层交叉验证-K-fold-cross-validation" class="headerlink" title="K 层交叉验证 (K- fold cross validation)"></a>K 层交叉验证 (K- fold cross validation)</h3><p><strong>这个是最常用的方法！</strong></p>
<ul>
<li><p>把整个数据集随机分成 K“层”</p>
</li>
<li><p>用其中 K-1 层训练模型，然后用第K层验证。</p>
</li>
<li><p>记录从每个预测结果获得的误差。</p>
</li>
<li><p>重复这个过程，直到每“层”数据都作过验证集。</p>
</li>
<li><p>记录下的 k 个误差的平均值，被称为交叉验证误差（cross-validation error）。可以被用做衡量模型表现的标准。</p>
</li>
</ul>
<h2 id="如何确定合适的k值"><a href="#如何确定合适的k值" class="headerlink" title="如何确定合适的k值"></a>如何确定合适的k值</h2><ul>
<li>K 值越小，偏误越大，所以越不推荐。(K 值小，则会变得像“验证集法”)</li>
<li>K 值太大，所得结果会变化多端。(K 值大，则会变得像“留一法”（LOOCV)）</li>
<li>通常建议的值是 k=10 。</li>
</ul>
<h2 id="如何衡量模型的偏误-变化程度？"><a href="#如何衡量模型的偏误-变化程度？" class="headerlink" title="如何衡量模型的偏误/变化程度？"></a>如何衡量模型的偏误/变化程度？</h2><p>K 层交叉检验之后，我们得到 K 个不同的模型误差估算值（e1, e2 …..ek）。理想的情况是，这些误差值相加得 0 。要计算模型的偏误，我们把所有这些误差值相加。平均值越低，模型越优秀。</p>
<p>模型表现变化程度的计算与之类似。取所有误差值的标准差，标准差越小说明模型随训练数据的变化越小。</p>
<h2 id="小的例子"><a href="#小的例子" class="headerlink" title="小的例子"></a>小的例子</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> cross_validation</span><br><span class="line">model = RandomForestClassifier(n_estimators=<span class="number">100</span>)</span><br><span class="line"><span class="comment">#简单K层交叉验证，10层。</span></span><br><span class="line">cv = cross_validation.KFold(len(train), n_folds=<span class="number">10</span>, indices=<span class="keyword">False</span>)</span><br><span class="line">results = []</span><br><span class="line"><span class="comment"># "Error_function" 可由你的分析所需的error function替代</span></span><br><span class="line"><span class="keyword">for</span> traincv, testcv <span class="keyword">in</span> cv:</span><br><span class="line">        probas = model.fit(train[traincv], target[traincv]).predict_proba(train[testcv])</span><br><span class="line">        results.append( Error_function )</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Results: "</span> + str( np.array(results).mean() )</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://datartisan.com/article/detail/62.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">用交叉验证改善模型的预测表现(适用于 Python 和 R)</a><br><a href="http://scikit-learn.org/dev/modules/cross_validation.html#cross-validation" target="_blank" rel="noopener">scikit-learn官网crossvalidation文档</a></p>
<p>我们应该试图在偏误和变化程度间找到一种平衡。降低变化程度、控制偏误可以达到这个目的。这样会得到更好的预测模型。进行这个取舍，通常会得出复杂程度较低的预测模型。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 交叉验证 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习基本工作流程]]></title>
      <url>/2016/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ML-%E6%80%BB%E7%BB%93-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="抽象成数学问题"><a href="#抽象成数学问题" class="headerlink" title="抽象成数学问题"></a>抽象成数学问题</h2><p>明确问题是进行机器学习的第一步。机器学习的训练过程通常都是一件非常耗时的事情，胡乱尝试时间成本是非常高的。</p>
<p>这里的抽象成数学问题，指的我们明确我们可以获得什么样的数据，目标是一个分类还是回归或者是聚类的问题，如果都不是的话，如果划归为其中的某类问题。<br><a id="more"></a></p>
<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><p>数据决定了机器学习结果的上限，而算法只是尽可能逼近这个上限。</p>
<p>数据要有代表性，否则必然会过拟合。</p>
<p>而且对于分类问题，数据偏斜不能过于严重，不同类别的数据数量不要有数个数量级的差距。</p>
<p>而且还要对数据的量级有一个评估，多少个样本，多少个特征，可以估算出其对内存的消耗程度，判断训练过程中内存是否能够放得下。如果放不下就得考虑改进算法或者使用一些降维的技巧了。如果数据量实在太大，那就要考虑分布式了。</p>
<h2 id="特征预处理与特征选择"><a href="#特征预处理与特征选择" class="headerlink" title="特征预处理与特征选择"></a>特征预处理与特征选择</h2><p>良好的数据要能够提取出良好的特征才能真正发挥效力。</p>
<p>特征预处理、数据清洗是很关键的步骤，往往能够使得算法的效果和性能得到显著提高。归一化、离散化、因子化、缺失值处理、去除共线性等，数据挖掘过程中很多时间就花在它们上面。这些工作简单可复制，收益稳定可预期，是机器学习的基础必备步骤。</p>
<p>筛选出显著特征、摒弃非显著特征，需要机器学习工程师反复理解业务。这对很多结果有决定性的影响。特征选择好了，非常简单的算法也能得出良好、稳定的结果。这需要运用特征有效性分析的相关技术，如相关系数、卡方检验、平均互信息、条件熵、后验概率、逻辑回归权重等方法。</p>
<h2 id="训练模型与调优"><a href="#训练模型与调优" class="headerlink" title="训练模型与调优"></a>训练模型与调优</h2><p>直到这一步才用到我们上面说的算法进行训练。现在很多算法都能够封装成黑盒供人使用。但是真正考验水平的是调整这些算法的（超）参数，使得结果变得更加优良。这需要我们对算法的原理有深入的理解。理解越深入，就越能发现问题的症结，提出良好的调优方案。</p>
<h2 id="模型诊断"><a href="#模型诊断" class="headerlink" title="模型诊断"></a>模型诊断</h2><p>如何确定模型调优的方向与思路呢？这就需要对模型进行诊断的技术。</p>
<p>过拟合、欠拟合 判断是模型诊断中至关重要的一步。常见的方法如交叉验证，绘制学习曲线等。过拟合的基本调优思路是增加数据量，降低模型复杂度。欠拟合的基本调优思路是提高特征数量和质量，增加模型复杂度。</p>
<p>误差分析 也是机器学习至关重要的步骤。通过观察误差样本，全面分析误差产生误差的原因:是参数的问题还是算法选择的问题，是特征的问题还是数据本身的问题……<br>诊断后的模型需要进行调优，调优后的新模型需要重新进行诊断，这是一个反复迭代不断逼近的过程，需要不断地尝试， 进而达到最优状态。</p>
<h2 id="模型融合"><a href="#模型融合" class="headerlink" title="模型融合"></a>模型融合</h2><p>一般来说，模型融合后都能使得效果有一定提升。而且效果很好。</p>
<p>工程上，主要提升算法准确度的方法是分别在模型的前端（特征清洗和预处理，不同的采样模式）与后端（模型融合）上下功夫。因为他们比较标准可复制，效果比较稳定。而直接调参的工作不会很多，毕竟大量数据训练起来太慢了，而且效果难以保证。</p>
<h2 id="上线运行"><a href="#上线运行" class="headerlink" title="上线运行"></a>上线运行</h2><p>这一部分内容主要跟工程实现的相关性比较大。工程上是结果导向，模型在线上运行的效果直接决定模型的成败。 不单纯包括其准确程度、误差等情况，还包括其运行的速度(时间复杂度)、资源消耗程度（空间复杂度）、稳定性是否可接受。</p>
<p>这些工作流程主要是工程实践上总结出的一些经验。并不是每个项目都包含完整的一个流程。这里的部分只是一个指导性的说明，只有大家自己多实践，多积累项目经验，才会有自己更深刻的认识。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://blog.csdn.net/longxinchen_ml/article/details/50749614" target="_blank" rel="noopener">机器学习系列(7)_机器学习路线图(附资料) </a></p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kaggle比赛团队协作入门]]></title>
      <url>/2016/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ML-%E6%80%BB%E7%BB%93-MeetingRecord/</url>
      <content type="html"><![CDATA[<p>本文根据陈驰大神在tigger kaggle小组中的关于kaggle比赛的微讲座整理的。</p>
<blockquote>
<p>陈驰，NYU CS硕士毕业，现在在纽约一间创业公司负责全栈开发和数据分析的工作，主要背景是概率图谱和自然处理以及深度学习。</p>
</blockquote>
<a id="more"></a>
<h2 id="1-Kaggle组队比赛的项目管理特性问题的解决方案"><a href="#1-Kaggle组队比赛的项目管理特性问题的解决方案" class="headerlink" title="1 Kaggle组队比赛的项目管理特性问题的解决方案"></a>1 Kaggle组队比赛的项目管理特性问题的解决方案</h2><p>在组队参加Kaggle比赛和一般软件工程项目管理有共性问题,也有特性问题。</p>
<h3 id="1-1-共性问题："><a href="#1-1-共性问题：" class="headerlink" title="1.1 共性问题："></a>1.1 共性问题：</h3><ol>
<li>成员的知识背景不足以完成任务</li>
<li>时间的协调</li>
<li>项目进度的把控</li>
</ol>
<h3 id="1-2-特性问题"><a href="#1-2-特性问题" class="headerlink" title="1.2 特性问题:"></a>1.2 特性问题:</h3><ol>
<li>研究的性质</li>
<li>不容易明确分工和协调合作</li>
</ol>
<h2 id="2-BestPractise文件"><a href="#2-BestPractise文件" class="headerlink" title="2 BestPractise文件"></a>2 BestPractise文件</h2><p>那么怎么解决上面说的特性问题呢？ 在我们现在DS项目的试行中有个方法还不错:<br>建立一个叫BestPractise.md文件（举个例子）去解决。<br>这个文件由分析报告和资源整合两部分组成：</p>
<h3 id="2-1-分析报告部分："><a href="#2-1-分析报告部分：" class="headerlink" title="2.1 分析报告部分："></a>2.1 分析报告部分：</h3><p>由队长把所有队员的每次分析根据Data Science Pipeline（稍后会说）整合到里面。</p>
<p>这个有几个好处：</p>
<ol>
<li>提供统一的入口看到所有人的分析情况;</li>
<li>变无序为有序，理清大家分析之间的联系;</li>
<li>避免重复别人的工作;</li>
<li>更好地把握进度;</li>
</ol>
<h3 id="2-2-资源整合部分："><a href="#2-2-资源整合部分：" class="headerlink" title="2.2 资源整合部分："></a>2.2 资源整合部分：</h3><p>这个部分很简单，类似于FAQ，把大家经常需要用到的资源放在这里，各取所需。常用的资源包括:</p>
<ul>
<li>语言入门（例如Python数据分析的一页文档）</li>
<li>Git基本操作、</li>
<li>Machine Learning基本概念，等等</li>
</ul>
<h2 id="3-Data-Science-Pipeline"><a href="#3-Data-Science-Pipeline" class="headerlink" title="3 Data Science Pipeline"></a>3 Data Science Pipeline</h2><p>在带DS项目过程中，我们觉得特别需要明确这个流程，尤其是新生，不知道如何入手的时候，DS Pipeline可以帮助大家更好的了解流程:</p>
<h3 id="3-1-读入数据"><a href="#3-1-读入数据" class="headerlink" title="3.1. 读入数据"></a>3.1. 读入数据</h3><p>这个一般不会有太大的问题，但是在Kaggle比赛中，我们有时也会遇到数据量太大不能全部读入的问题，解决呢的方法有：</p>
<ul>
<li>抽样 - 关键点我暂时了解是一个，是抽样平均，使得数据有代表性</li>
<li>一般我不会建议用分布式.</li>
</ul>
<h3 id="3-2-数据预处理（数据转换、数据清理、空值处理"><a href="#3-2-数据预处理（数据转换、数据清理、空值处理" class="headerlink" title="3.2. 数据预处理（数据转换、数据清理、空值处理)"></a>3.2. 数据预处理（数据转换、数据清理、空值处理)</h3><ul>
<li>譬如 <strong>Normalization</strong> 这种预处理是可以有助于加快训练速度,具体原因可以看一下Coursera ML Standford的视频.</li>
<li>数据清洗在自然语言里用的就特别多，信号也是 譬如Tweet里面有这样的词<code>loooooove you</code></li>
<li>空值处理也是，不过空值处理也是分情况的，一般可以说可以用统一的值譬如0代替，尤其空值不是很多的时候，还可以用插值的方法来代替.</li>
</ul>
<h3 id="3-3-探索性分析（提出问题、建立假设、数据可视化、数据挖掘-总结"><a href="#3-3-探索性分析（提出问题、建立假设、数据可视化、数据挖掘-总结" class="headerlink" title="3.3. 探索性分析（提出问题、建立假设、数据可视化、数据挖掘/总结)"></a>3.3. 探索性分析（提出问题、建立假设、数据可视化、数据挖掘/总结)</h3><p>很多时候我们看到数据时候不是直接埋头分析，而是往往问合适的问题，然后提出假设。<br>譬如你头发稀疏的程度与你取得好成绩会不会有负相关关系。然后可以分别从数据的可视化（直观上）和特定的数字特征譬如平均值来看一它们的关系.<br>个人经验是: 很多时候 <strong>可视化</strong> 能带来很多很有用的信息,譬如一个商品在一些节假日就卖出特别多，画出图就很明显.</p>
<h3 id="3-4-特征工程（提取特征、特征处理、特征选取）"><a href="#3-4-特征工程（提取特征、特征处理、特征选取）" class="headerlink" title="3.4. 特征工程（提取特征、特征处理、特征选取）"></a>3.4. 特征工程（提取特征、特征处理、特征选取）</h3><p>主元素分析（PCA) 这是特征选取的一种方法。<br>当然大家也可以根据模型的好坏来对特征进行选取（迭代速度慢）。</p>
<h3 id="3-5-模型工程（模型建立、模型选取、模型集成）"><a href="#3-5-模型工程（模型建立、模型选取、模型集成）" class="headerlink" title="3.5. 模型工程（模型建立、模型选取、模型集成）"></a>3.5. 模型工程（模型建立、模型选取、模型集成）</h3><p>模型建立一般需要你对模型的特性熟悉.<br>譬如Naive Bayesian Network.,它假设字与字之间是没有联系的（事实当然不是），但这是它的特性。除了Spam filter，它在处理其他需要考虑字与字之间联系的问题时，效果会明显不好.<br>而对于模型的选取，除了刚才对于所说对于模型的了解上，就会有些指标，譬如从模型预测的结果来判断模型的好坏.</p>
<p><strong>模型的集成</strong> (ensembling method)我要说的是Kaggle比赛经常用的一个技巧,可以比普通水平弱的预测器或分类器做出比他们效果好不少的模型.实际上很多库本身就实现了模型的集成。</p>
<h3 id="3-6-参数选取"><a href="#3-6-参数选取" class="headerlink" title="3.6. 参数选取"></a>3.6. 参数选取</h3><p><strong>Cross Validation</strong> 是常用的方法，另外还可以通过选取不同的参数值来比较结果的好坏.</p>
<h3 id="3-7-模型测试（数据划分、测量确定、分析结果、修正假设）"><a href="#3-7-模型测试（数据划分、测量确定、分析结果、修正假设）" class="headerlink" title="3.7.模型测试（数据划分、测量确定、分析结果、修正假设）"></a>3.7.模型测试（数据划分、测量确定、分析结果、修正假设）</h3><h2 id="4-队伍管理"><a href="#4-队伍管理" class="headerlink" title="4 队伍管理"></a>4 队伍管理</h2><p>我们觉的比较可行的过程是:</p>
<ol>
<li>最开始大家各自分析</li>
<li>各自的水平会呈现和产生问题（适合分工的时机）</li>
<li>“牛的人应该提供思路和问题—-入门的人去完成—-牛人再帮忙”（需要分析报告部分）</li>
<li>为了解决常见的问题（需要资源整合部分）</li>
<li>还有一个痛点：实时回答问题（Stackoverflow或者Github的Issue）</li>
</ol>
<h2 id="4-项目管理的注意事项-开会、评估、语言）"><a href="#4-项目管理的注意事项-开会、评估、语言）" class="headerlink" title="4 项目管理的注意事项(开会、评估、语言）"></a>4 项目管理的注意事项(开会、评估、语言）</h2><h3 id="4-1-开会"><a href="#4-1-开会" class="headerlink" title="4.1 开会"></a>4.1 开会</h3><p>暂时在DS项目组我们开会的内容基本只有一个，就是根据之前说的BestPractise对没解决的问题查漏补缺，共同解决，然后根据分析的结果产生新的思路。</p>
<h3 id="4-2-评估"><a href="#4-2-评估" class="headerlink" title="4.2 评估"></a>4.2 评估</h3><p>评估方面主要有两个方面的评估：人员和工具。之所以要评估，是为了更好计算每个小任务完成的时间，并在没完成的时候对评估的角度思考解决的方法.</p>
<h4 id="4-2-1-队员评估"><a href="#4-2-1-队员评估" class="headerlink" title="4.2.1 队员评估"></a>4.2.1 队员评估</h4><ol>
<li>工具不熟练</li>
<li>知识背景不够</li>
</ol>
<h4 id="4-2-2-工具评估"><a href="#4-2-2-工具评估" class="headerlink" title="4.2.2 工具评估"></a>4.2.2 工具评估</h4><ol>
<li>工具的学习曲线</li>
<li>工具提高的效率</li>
</ol>
<h3 id="4-3-语言"><a href="#4-3-语言" class="headerlink" title="4.3 语言"></a>4.3 语言</h3><p>编程语言要统一。之前有出现过一组，因为大家使用不同语言，而是希望直接看分析结果，这个其实是要求每个人都有独立分析的能力，最后进展不是很顺利的情况。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kaggle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[推荐系统算法概述]]></title>
      <url>/2016/06/%E5%BE%85%E6%95%B4%E7%90%86/Recommender-%E6%80%BB%E7%BB%93-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在算法模型上大体可以分基于内容的推荐、基于协同过滤的推荐。</p>
<ul>
<li><p>基于人口统计学的推荐: 利用User Profile计算其它用户与其之间的相似度，然后挑选出与其最相似的前K个用户，之后利用这些用户的购买和打分信息进行推荐。</p>
</li>
<li><p>基于内容推荐，即通过内容本身的属性，然后计算内容的相似性，找到与某物品属性相似的物品。</p>
</li>
<li><p>协同过滤: 即不依赖于物品本身的物品属性，而是通过其他相关特征，例如人参与的行为数据，来达到推荐物品的目的。</p>
</li>
</ul>
<a id="more"></a>
<p>关于协同过滤，又分为以下几个类别：</p>
<ul>
<li>基于物品的协同，即ItemCF；</li>
<li>基于用于的协同，即UserCF；</li>
<li>基于模型的协同，即ModelCF。</li>
</ul>
<p>其中，基于模型的协同又可以分为以下几种类型：</p>
<ul>
<li>基于距离的协同过滤；</li>
<li>基于矩阵分解的协同过滤，即Latent Factor Model(SVD)；</li>
<li>基于图模型协同，即Graph，也叫社会网络图模型。</li>
</ul>
<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="冷启动-cold-start"><a href="#冷启动-cold-start" class="headerlink" title="冷启动 cold start"></a>冷启动 cold start</h3><p>即在推荐系统初期时，没有任何用户与物品的交集信息，无用户的行为信息，无法通过类似协同的方式进行过滤推荐，这种时候，我们就称推荐 <strong>系统冷启动</strong> 状态。 除此以外，还有 <strong>用户冷启动</strong>，和 <strong>物品冷启动</strong>.</p>
<p>解决方法：</p>
<ol>
<li>用户信息—— 主要是人口统计学信息,注册信息</li>
<li>利用物品信息</li>
<li>基于内容的推荐</li>
</ol>
<h3 id="长尾效益、马太效益"><a href="#长尾效益、马太效益" class="headerlink" title="长尾效益、马太效益"></a>长尾效益、马太效益</h3><p>在推荐系统中的体现即，部分优质物品，购买的人数较多，即与其相关的的用户行为轨迹会较多。—强者愈强，弱者愈弱。</p>
<p>数据体现：<br>物品流行度数据在双对数曲线上呈直线 。</p>
<p>解决方法：<br>给热点物品适当的降权。</p>
<h2 id="相似度计算"><a href="#相似度计算" class="headerlink" title="相似度计算"></a>相似度计算</h2><p>常用的有：<strong>皮尔逊系数</strong> <strong>Jaccard相似度</strong> 和 <strong>余相似度</strong><br>一般来说，在基于用户的推荐系统中，皮尔逊相关系数效果要好一些。基于物品的推荐中，余弦相似度方法比皮尔逊的表现更好。</p>
<h3 id="用户相识度计算"><a href="#用户相识度计算" class="headerlink" title="用户相识度计算"></a>用户相识度计算</h3><p>基础公式：<br><img src="./001.png" alt=""><br>N(u)为用户u经有正反馈的物品集合, N(v)为用户v经有正反馈的物品集合.</p>
<p>改进公式：<br><img src="./001-1.png" alt=""><br>其中<img src="./002.png" alt=""> 惩罚了热门物品。</p>
<h3 id="物品相识度计算"><a href="#物品相识度计算" class="headerlink" title="物品相识度计算"></a>物品相识度计算</h3><p>基础公式：<br><img src="./003.png" alt=""><br>分母是喜欢物品i 的用户数，分子是同时喜欢i 和 j的用户数</p>
<p>改进公式：<br><img src="./004.png" alt=""><br>其中<code>N(i)</code> 惩罚了热门物品</p>
<h2 id="ALS的理解"><a href="#ALS的理解" class="headerlink" title="ALS的理解"></a>ALS的理解</h2><p>ALS 是spark 中唯一实现的协同过滤算法，也是我学习的重点。</p>
<p>对于一个users-products-rating的评分数据集，ALS会建立一个的<code>m*n</code>的矩阵。其中，m为users的数量，n为products的数量，值为评分。但是在这个数据集中，并不是每个用户都对每个产品进行过评分，所以这个矩阵是 <strong>稀疏</strong> 的，用户i对产品j的评分往往是空的.</p>
<p>ALS所做的事情就是将这个稀疏矩阵通过一定的规律填满，这样就可以从矩阵中得到任意一个user对任意一个product的评分，也就是传说中的预测得分。</p>
<p>ALS算法的核心:</p>
<ul>
<li>就是将稀疏评分矩阵分解为用户特征向量矩阵和产品特征向量矩阵的乘积</li>
<li>交替使用最小二乘法逐步计算用户/产品特征向量，使得差平方和最小</li>
<li>通过用户/产品特征向量的矩阵来预测某个用户对某个产品的评分</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Recommender </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ALS </tag>
            
            <tag> CF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[钢条切割问题-动态规划InAction]]></title>
      <url>/2016/06/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E6%80%BB%E7%BB%93%20-%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98-PDInAction/</url>
      <content type="html"><![CDATA[<blockquote>
<p>动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
</blockquote>
<p>动态规划其实质上是通过开辟记录表，记录已求解过的结果，当再次需要求解的时候，可以直接到那个记录表中去查找，从而避免重复计算子问题来达到降低时间复杂度的效果。实际上是一个 <strong>空间换时间的算法</strong>。动态规划，通常可以把指数级的复杂度降低到多项式级别。<br><a id="more"></a><br>动态规划很像分治法，都是通过分解成子问题并结合其结果来得到原问题的解。区别在于法的子问题不相交，但是动态规划的子问题是重叠的。<br>所以动态规划算法的有效性依赖于待求解问题本身具有的两个重要性质：最优子结构性质和子问题重叠性质。</p>
<p>动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。</p>
<p>动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。</p>
<h2 id="钢条切割问题"><a href="#钢条切割问题" class="headerlink" title="钢条切割问题"></a>钢条切割问题</h2><p>将长度为n的钢条切割成若干短钢条出售，切割成本不计，钢条长度与售价关系如下，求一种售价最大的切割法。<br>p={0:0,1:1,2:5,3:8,4:9,5:10,6:17,7:17,8:20,9:24,10:30}</p>
<h2 id="常用的递归求解"><a href="#常用的递归求解" class="headerlink" title="常用的递归求解"></a>常用的递归求解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">p=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">17</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">30</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_rod</span><span class="params">(n,p)</span>:</span></span><br><span class="line">    <span class="comment"># 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    q = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        tmp = p[i] +cut_rod(n-i, p)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录最大值</span></span><br><span class="line">        <span class="keyword">if</span> tmp &gt; q :</span><br><span class="line">            q = tmp</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line">%timeit x = cut_rod(<span class="number">8</span>,p)</span><br><span class="line">%timeit y = cut_rod(<span class="number">9</span>,p)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"n=9的结果:"</span>,y)</span><br></pre></td></tr></table></figure>
<p>1000 loops, best of 3: 165 µs per loop<br>1000 loops, best of 3: 308 µs per loop<br>n=9的结果: 25</p>
<p>但是这种方法对同样的规模的问题进行了多次重复的运算，即对2^(n-1)种切割都进行了计算，规模越小的问题重复次数越多，性能很差，时间性能为O(2^n).</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划对每个子问题只求解一次，将结果保存，用额外的空间换取时间。有两种等价的实现方式：</p>
<h3 id="带备忘的自顶向下"><a href="#带备忘的自顶向下" class="headerlink" title="带备忘的自顶向下"></a>带备忘的自顶向下</h3><p>仍然按自然的递归形式编写过程，但过程中保存每个子问题的解，遇到子问题时先从存档中查找，若无记录再计算。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memoized_cut_rod</span><span class="params">(n, p)</span> :</span></span><br><span class="line">    <span class="comment"># 记录结果用的</span></span><br><span class="line">    mem = [<span class="number">-1</span>]*(n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_aux</span> <span class="params">(n,p)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果结果有了，就不用再次递归了</span></span><br><span class="line">        <span class="keyword">if</span> mem[n] &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> mem[n]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            q = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            q = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            tmp = p[i] +inner_aux(n-i, p)</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; q :</span><br><span class="line">                q = tmp</span><br><span class="line"></span><br><span class="line">        mem[n] = q</span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner_aux(n, p)</span><br><span class="line">%timeit t = memoized_cut_rod(<span class="number">8</span>, p)</span><br><span class="line">%timeit d = memoized_cut_rod(<span class="number">9</span>, p)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"n=9的结果:"</span>, memoized_cut_rod(<span class="number">9</span>, p))</span><br></pre></td></tr></table></figure></p>
<p>10000 loops, best of 3: 23.3 µs per loop<br>10000 loops, best of 3: 27.9 µs per loop<br>n=9的结果: 25</p>
<h3 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h3><p>可以将子问题按规模排序，由小到进行求解，确保每次求解更小的子问题已有存档。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bottom_up_cut_rod</span><span class="params">(n,p)</span>:</span></span><br><span class="line">    r = [<span class="number">-1</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        q = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">            tmp = p[j] + r[i-j]</span><br><span class="line">            <span class="keyword">if</span> tmp &gt;q :</span><br><span class="line">                q = tmp</span><br><span class="line">        r[j] = q</span><br><span class="line">    <span class="keyword">return</span> r[n]</span><br><span class="line">%timeit e = bottom_up_cut_rod(<span class="number">8</span>,p)</span><br><span class="line">%timeit f = bottom_up_cut_rod(<span class="number">9</span>,p)</span><br><span class="line">print(<span class="string">"n=9的结果"</span>,f)</span><br></pre></td></tr></table></figure>
<p>100000 loops, best of 3: 14.3 µs per loop<br>100000 loops, best of 3: 17.1 µs per loop<br>n=9的结果 25</p>
<p>以上两种方法的渐近时间是一样的，为多项式级性能，只在特定的情形下有差异。由于bottom up的方法没有递归中频繁的函数调用开销，性能更好。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithms </tag>
            
            <tag> DP </tag>
            
            <tag> Action </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python-list常用操作]]></title>
      <url>/2016/06/%E5%BE%85%E6%95%B4%E7%90%86/Python3-%E6%80%BB%E7%BB%93-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-list/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>list是一种有序的集合，可以随时添加和删除其中的元素。<br>本节的笔记主要是：各种我遇到的list操作，不断更新ing；<br><a id="more"></a></p>
<h2 id="create-list"><a href="#create-list" class="headerlink" title="create list"></a>create list</h2><p><strong>注意：定义用的是方括号！！！</strong></p>
<h4 id="空白list"><a href="#空白list" class="headerlink" title="空白list"></a>空白list</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mylist =[]</span><br><span class="line">mylist = list()</span><br></pre></td></tr></table></figure>
<h3 id="有限元素创建"><a href="#有限元素创建" class="headerlink" title="有限元素创建"></a>有限元素创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="指定长度创建"><a href="#指定长度创建" class="headerlink" title="指定长度创建"></a>指定长度创建</h3><p>注意 <code>[]*n</code>还是<code>[]</code> ,无意义。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mylist = [element]*mylen</span><br></pre></td></tr></table></figure></p>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>1.可以用<code>len()</code>函数可以获得list元素的个数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(classmates)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="访问指定元素"><a href="#访问指定元素" class="headerlink" title="访问指定元素"></a>访问指定元素</h3><p>2.用索引来访问list中每一个位置的元素，记得<strong>索引是从0开始</strong>的：，要确保索引不要越界，记得最后一个元素的索引是<code>len(classmates) - 1</code>。</p>
<p>3.如果要取最后一个元素，除了计算索引位置外，还可以用<code>-1</code>做索引，直接获取最后一个元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">0</span>]</span><br><span class="line"><span class="string">'Michael'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-1</span>]</span><br><span class="line"><span class="string">'Tracy'</span></span><br></pre></td></tr></table></figure>
<h3 id="添加、插入、删除、替换元素"><a href="#添加、插入、删除、替换元素" class="headerlink" title="添加、插入、删除、替换元素"></a>添加、插入、删除、替换元素</h3><p>4.list是一个可变的有序表，所以，可以往list中追加元素到末尾：使用<code>listname.append(&#39;要加入的&#39;)</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">'Adam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</span><br></pre></td></tr></table></figure></p>
<p>5.也可以把元素插入到指定的位置，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.insert(<span class="number">1</span>, <span class="string">'Jack'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</span><br></pre></td></tr></table></figure></p>
<p>6.要删除指定位置的元素，用<code>pop(i)</code>方法，其中i是索引位置;要删除list末尾的元素，用<code>pop()</code>方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">1</span>)</span><br><span class="line"><span class="string">'Jack'</span></span><br></pre></td></tr></table></figure></p>
<p>7.要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>] = <span class="string">'Sarah'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="多维列表"><a href="#多维列表" class="headerlink" title="多维列表"></a>多维列表</h3><p>8.list里面的元素的数据类型也可以不同; list也可以是空的，那他的长度为0；list元素也可以是另一个list（可以看成是一个二维数组）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = [<span class="string">'asp'</span>, <span class="string">'php'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, p, <span class="string">'scheme'</span>]</span><br></pre></td></tr></table></figure></p>
<p>1) <strong>要注意，S的长度是4个单位</strong>，不是5个。<strong><em>(易错点）</em></strong><br>2)要拿到<code>&#39;php&#39;</code>可以写<code>p[1]</code>或者<code>s[2][1]</code>;<br>3)我们也可以通过<code>s[2][1]</code>拿到<code>‘java’</code>中的<code>a</code>;（python果然很随便啊）<br>4)这样写一个二维数组也是合法的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, [<span class="string">'asp'</span>, <span class="string">'php'</span>], <span class="string">'scheme'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python3 </tag>
            
            <tag> list </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark上数据预处理常用技巧]]></title>
      <url>/2016/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/spark-%E6%80%BB%E7%BB%93-Spark%E4%B8%8A%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>我常用用到的数据处理技巧的总结，<br><a id="more"></a></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><p>使用<code>sc.textFile()</code></p>
<h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><ol>
<li>是从hdfs读取文件(默认)，也可以指定sc.textFile(“路径”).在路径前面加上<code>hdfs://</code>表示从hdfs文件系统上读<h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3></li>
<li>本地文件读取 sc.textFile(“路径”).在路径前面加上<code>file://</code> 表示从本地文件系统读.<br>如：<code>data = sc.textFile(&quot;file:///Users/wente/SparkTest/python-spark-app/data/UserPurchaseHistory.csv&quot;)</code><h3 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h3>sc.parallelize<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">distData = sc.parallelize(data)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><h3 id="缺失值的过滤——填充-删除"><a href="#缺失值的过滤——填充-删除" class="headerlink" title="缺失值的过滤——填充/删除"></a>缺失值的过滤——填充/删除</h3><h3 id="异常值的处理"><a href="#异常值的处理" class="headerlink" title="异常值的处理"></a>异常值的处理</h3><h2 id="特征的提取"><a href="#特征的提取" class="headerlink" title="特征的提取"></a>特征的提取</h2><h3 id="数据特征"><a href="#数据特征" class="headerlink" title="数据特征"></a>数据特征</h3><p>比如时间、位置等的原始数据是直接用是没有意思的。所以需要转换。<br>下面以时间戳为例子，进行类别化</p>
<h4 id="时间戳–-gt-类别特征"><a href="#时间戳–-gt-类别特征" class="headerlink" title="时间戳–&gt; 类别特征"></a>时间戳–&gt; 类别特征</h4><p>原始时间数据——&gt;为发生的小时数——&gt;时间段—–&gt;编号—-&gt;向量化</p>
<h3 id="类别特征"><a href="#类别特征" class="headerlink" title="类别特征"></a>类别特征</h3><p>类别特征—&gt; 编号（数字化）—–&gt;向量化</p>
<h3 id="派生特征"><a href="#派生特征" class="headerlink" title="派生特征"></a>派生特征</h3><p>常见的有 平均数、中位数、方差、标准差、和、差、最大值、最小值.</p>
<h3 id="文本特征"><a href="#文本特征" class="headerlink" title="文本特征"></a>文本特征</h3><p>原始文本也是不能直接使用的。<br>处理步骤：<br>文本过滤—&gt; 分词—&gt; 删除停词—&gt; 提取词干 —&gt; 生成词袋 —&gt; 编号—-&gt;向量化</p>
<h4 id="文本过滤"><a href="#文本过滤" class="headerlink" title="文本过滤"></a>文本过滤</h4><p>有很多处理细节：</p>
<ol>
<li>大小写的处理</li>
<li>特殊字符</li>
</ol>
<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><h4 id="正则化特征"><a href="#正则化特征" class="headerlink" title="正则化特征"></a>正则化特征</h4><h4 id="正则化特征向量"><a href="#正则化特征向量" class="headerlink" title="正则化特征向量"></a>正则化特征向量</h4><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="编号-使用Python"><a href="#编号-使用Python" class="headerlink" title="编号 - 使用Python"></a>编号 - 使用Python</h2><p>编号是很常用特征处理技巧<br><script src="//gist.github.com/d21467627cde8bae58a10295c047bacd.js"></script></p>
<h2 id="编号-使用spark自带"><a href="#编号-使用spark自带" class="headerlink" title="编号 - 使用spark自带"></a>编号 - 使用spark自带</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_terms_dict2 = title_terms.flatMap(<span class="keyword">lambda</span> x : x).distinct().zipWithIndex().collectAsMap()</span><br></pre></td></tr></table></figure>
<h2 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h2><script src="//gist.github.com/3a065e160b2c61e26d98e1985876b910.js"></script>
]]></content>
      
        <categories>
            
            <category> Spark </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spark </tag>
            
            <tag> DATA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark算子：RDD常用操作]]></title>
      <url>/2016/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/spark-%E6%80%BB%E7%BB%93-RDD%E5%B8%B8%E7%94%A8%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>我总结的spark常用的操作，不短更新ing.<br><a id="more"></a></p>
<h2 id="sc-parallelize-从集合创建RDD"><a href="#sc-parallelize-从集合创建RDD" class="headerlink" title="sc.parallelize 从集合创建RDD"></a>sc.parallelize 从集合创建RDD</h2><p><code>def parallelize[T](seq: Seq[T], numSlices: Int = defaultParallelism)</code></p>
<ul>
<li>参数1：Seq集合，必须。</li>
<li>参数2：分区数，默认为该Application分配到的资源的CPU核数</li>
</ul>
<h2 id="distinct-去重"><a href="#distinct-去重" class="headerlink" title="distinct() 去重"></a>distinct() 去重</h2><p>对RDD中的元素进行去重操作。</p>
<h2 id="reduceByKey"><a href="#reduceByKey" class="headerlink" title="reduceByKey"></a>reduceByKey</h2><p><code>reduceByKey(func, numPartitions=None, partitionFunc=&lt;function portable_hash at 0x7f1ac7340578&gt;)</code></p>
<p>该函数用于将RDD[K,V]中每个K对应的V值根据映射函数来运算。<br>参数numPartitions用于指定分区数；<br>参数partitioner用于指定分区函数；</p>
<p>Merge the values for each key using an associative reduce function.<br>This will also perform the merging locally on each mapper before sending results to a reducer, similarly to a “combiner” in MapReduce.<br>Output will be partitioned with numPartitions partitions, or the default parallelism level if numPartitions is not specified. Default partitioner is hash-partition.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd = sc.parallelize([(<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">1</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(rdd.reduceByKey(add).collect())</span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'b'</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></p>
<h2 id="collect-数组化"><a href="#collect-数组化" class="headerlink" title="collect() 数组化"></a>collect() 数组化</h2><p>collect用于将一个RDD转换成数组。</p>
<h2 id="collectAsMap"><a href="#collectAsMap" class="headerlink" title="collectAsMap()"></a>collectAsMap()</h2><p>将一个RDD转换成map。</p>
<h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h2><p>和map比 返回的是一个单个RDD</p>
]]></content>
      
        <categories>
            
            <category> Spark </category>
            
        </categories>
        
        
        <tags>
            
            <tag> saprk </tag>
            
            <tag> RDD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[lazy evaluation & map's change in py3.X]]></title>
      <url>/2016/06/%E5%BE%85%E6%95%B4%E7%90%86/Python-%E6%80%BB%E7%BB%93-lazyMvaluationMapsChangeInpy3/</url>
      <content type="html"><![CDATA[<h2 id="问题的引入"><a href="#问题的引入" class="headerlink" title="问题的引入"></a>问题的引入</h2><p>有一个list of tuple ，我想对他进行计算 ，<br>由 <code>[(x0 , y0)]</code> 得出 <code>[func(x0) ,func(y0)]</code><br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li = [(<span class="number">2</span>, <span class="number">62</span>), (<span class="number">4</span>, <span class="number">24</span>), (<span class="number">6</span>, <span class="number">211</span>), (<span class="number">8</span>, <span class="number">59</span>), (<span class="number">10</span>, <span class="number">184</span>)]</span><br></pre></td></tr></table></figure></p>
<p>但时我们在py2.X 中常用的map 在py3中 <strong>报错</strong> 了！！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map(<span class="keyword">lambda</span> (x, y) : (x, -y) , li)</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line">      File <span class="string">"&lt;ipython-input-20-ec98f456c680&gt;"</span>, line <span class="number">1</span></span><br><span class="line">        map(<span class="keyword">lambda</span> (x, y) : (x, -y) , li)</span><br><span class="line">                   ^</span><br><span class="line">    SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure></p>
<p>那我们将<code>（）</code>去掉 “”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map1 = map( (<span class="keyword">lambda</span> x, y : (x, -y)) , li)</span><br><span class="line"><span class="keyword">print</span> (map1)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">    &lt;map object at <span class="number">0x1043c5be0</span>&gt;</span><br></pre></td></tr></table></figure>
<p>貌似可以了！ 这里要说一下 py3 py2 在返回值上的区别：<br><strong>py3更多的操作后返回的都是一个 object  ，而不是py2 那样直接返回一个list</strong><br>那下面 ，就转换成 list ,查看一下结果！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list (map1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    TypeError                                 Traceback (most recent call last)</span><br><span class="line"></span><br><span class="line">    &lt;ipython-input<span class="number">-22</span><span class="number">-150e13</span>fece81&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">    ----&gt; 1 list (map1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TypeError: &lt;<span class="keyword">lambda</span>&gt;() missing <span class="number">1</span> required positional argument: <span class="string">'y'</span></span><br></pre></td></tr></table></figure>
<p>噢噢~~</p>
<p>为什么呢？</p>
<p>和群里的 @悉达超 老师 和@ا就去拯救地球了ا小石头 老师讨论后，我们认为：</p>
<blockquote>
<p>由于<strong>Python3 map的lazy属性</strong>，你即便一上来没把参数给全，由于它没有evaluate，所以不报错，只返回一个map object。<br>如果不给y的默认值，它这时候也能通过，返回一个没有evaluate的map object，但由于你没有把参数给全，它一旦evaluate，就会报错，说明Python 3天然不支持函数partial application。</p>
</blockquote>
<p>怎样不报错呢？</p>
<p>当然是给y赋一个值：向下面这个样子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map3 = map( (<span class="keyword">lambda</span> x, y = <span class="number">1</span> : (x, -y)) , li)</span><br><span class="line"><span class="keyword">print</span> (map3)</span><br><span class="line">list(map3)</span><br><span class="line">-----------------------</span><br><span class="line">&lt;map object at <span class="number">0x1043be898</span>&gt;</span><br><span class="line"></span><br><span class="line">[((<span class="number">2</span>, <span class="number">62</span>), <span class="number">-1</span>), ((<span class="number">4</span>, <span class="number">24</span>), <span class="number">-1</span>), ((<span class="number">6</span>, <span class="number">211</span>), <span class="number">-1</span>), ((<span class="number">8</span>, <span class="number">59</span>), <span class="number">-1</span>), ((<span class="number">10</span>, <span class="number">184</span>), <span class="number">-1</span>)]</span><br></pre></td></tr></table></figure>
<p>但这不是我要的结果！</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map2 = map((<span class="keyword">lambda</span> tuple : (tuple[<span class="number">0</span>] ,-tuple[<span class="number">1</span>])),li)</span><br><span class="line"><span class="keyword">print</span> (map2)</span><br><span class="line">list(map2)</span><br><span class="line">------------------------</span><br><span class="line">&lt;map object at <span class="number">0x1043be668</span>&gt;</span><br><span class="line">[(<span class="number">2</span>, <span class="number">-62</span>), (<span class="number">4</span>, <span class="number">-24</span>), (<span class="number">6</span>, <span class="number">-211</span>), (<span class="number">8</span>, <span class="number">-59</span>), (<span class="number">10</span>, <span class="number">-184</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>我们都觉得Python还是List comprehension最Pythonic：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(x, -y) <span class="keyword">for</span> (x, y) <span class="keyword">in</span> li]</span><br><span class="line">---------------------------</span><br><span class="line">    [(<span class="number">2</span>, <span class="number">-62</span>), (<span class="number">4</span>, <span class="number">-24</span>), (<span class="number">6</span>, <span class="number">-211</span>), (<span class="number">8</span>, <span class="number">-59</span>), (<span class="number">10</span>, <span class="number">-184</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="学到的东西"><a href="#学到的东西" class="headerlink" title="学到的东西"></a>学到的东西</h2><h3 id="python3-X-返回值的改变"><a href="#python3-X-返回值的改变" class="headerlink" title="python3.X 返回值的改变"></a>python3.X 返回值的改变</h3><ul>
<li>这也说明了py3的一个趋势， 就是更 argument passing,的规范化的体现，比如说 ，现在更多的操作后返回的都是一个 bject ，而不是向以前直接返回一个list @Wente</li>
<li>实际上我觉得这是编译器的退化的体现 @悉达超</li>
<li>我觉的的是 lazy evaluation in py 3 的体现@小石头</li>
</ul>
<h3 id="lazy计算的特点"><a href="#lazy计算的特点" class="headerlink" title="lazy计算的特点"></a>lazy计算的特点</h3><ul>
<li>某些语言里面一切计算都是lazy的，缺点就是你不太容易预测内存的开销，可能一直运行着不太占内存，突然一下就占满了</li>
<li>python3大概是针对python太慢的批评做出的回应，代价是编码的效率牺牲 @DIY</li>
<li>spark说官网上说惰性计算更加有利于并行，</li>
<li>函数的惰性使用让您能够得到更高效的代码  <a href="http://cr.openjdk.java.net/~briangoetz/lambda/collections-overview.html?cm_mc_uid=32079073833014609461378&amp;cm_mc_sid_50200000=1465540856" target="_blank" rel="noopener">“State of the Lambda: Libraries Edition</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python3 </tag>
            
            <tag> map </tag>
            
            <tag> lazy evaluation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark使用的一些小问题的解决]]></title>
      <url>/2016/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/spark-%E6%80%BB%E7%BB%93-%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3/</url>
      <content type="html"><![CDATA[<p>主要是我使用spark 中的各种错误及解决方案的的整理，不断更新ing<a id="more"></a></p>
<h2 id="不同位置文件的访问"><a href="#不同位置文件的访问" class="headerlink" title="不同位置文件的访问"></a>不同位置文件的访问</h2><p>错误提示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">py4j.protocol.Py4JJavaError: An error occurred while calling z:org.apache.spark.api.python.PythonRDD.collectAndServe.</span><br><span class="line">: org.apache.hadoop.mapred.InvalidInputException: Input path does not exist: hdfs://WenteMBP:9000/user/wente/data/UserPurchaseHistory.csv</span><br></pre></td></tr></table></figure></p>
<p>Spark 默认是访问hadoop上的文件 ：<br>默认是从hdfs读取文件，也可以指定sc.textFile(“路径”).在路径前面加上<code>hdfs://</code>表示从hdfs文件系统上读<br>本地文件读取 sc.textFile(“路径”).在路径前面加上<code>file://</code> 表示从本地文件系统读.<br>如：<code>data = sc.textFile(&quot;file:///Users/wente/SparkTest/python-spark-app/data/UserPurchaseHistory.csv&quot;)</code></p>
<h2 id="端口被占用的解决"><a href="#端口被占用的解决" class="headerlink" title="端口被占用的解决"></a>端口被占用的解决</h2><p>错误提示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16/06/08 15:18:41 WARN component.AbstractLifeCycle: FAILED SelectChannelConnector@0.0.0.0:4040: java.net.BindException: Address already in use</span><br><span class="line">java.net.BindException: Address already in use</span><br></pre></td></tr></table></figure></p>
<p>When a spark context is created, it starts an application UI on port 4040 by default. When the UI starts, it checks to see if the port is in use, if so it should increment to 4041. Looks like you have something running on port 4040 there. The application should show you the warning, then try to start the UI on 4041.</p>
<p>This should not stop your application from running. If you really want to get around the WARNING, you can manually specify which port for the UI to start on, but I would strongly advise against doing so.</p>
<p>To manually specify the port, add this to your spark-submit:</p>
<p><code>--conf spark.ui.port=your_port</code></p>
<p>exmple:<code>/usr/local/spark/bin/spark-submit pythonapp.py --conf spark.ui.port=4000</code></p>
]]></content>
      
        <categories>
            
            <category> Spark </category>
            
        </categories>
        
        
        <tags>
            
            <tag> saprk </tag>
            
            <tag> set </tag>
            
            <tag> bug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Spark中使用IPython notebook —— 超简单配置]]></title>
      <url>/2016/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/Spark-%E6%80%BB%E7%BB%93-%E5%9C%A8Spark%E4%B8%AD%E4%BD%BF%E7%94%A8IPythonNotebook/</url>
      <content type="html"><![CDATA[<p>当搜索有用的Spark小技巧时，我发现了一些文章提到在PySpark中配置IPython notebook。<br>IPython notebook对数据科学家来说是个交互地呈现科学和理论工作的必备工具，它集成了文本和Python代码。对很多数据科学家，IPython notebook是他们的Python入门，并且使用非常广泛，反正我是每天用的。<a id="more"></a></p>
<p>网上的的大部分说明都来改编自IPython notebook: 在PySpark中设置IPython。<br>但是非常繁琐。且配置不成功！</p>
<p>我的系统是:</p>
<ul>
<li>os x 11</li>
<li>spark 1.6.1x</li>
<li>hadoop 2.7.2</li>
<li>系统默认 python 2.7</li>
<li>想用的python 3.5.1</li>
</ul>
<p>操作十分的简单 在启动 pyspark 的命令前添加三个环境配置 <code>PYSPARK_PYTHON</code>  <code>PYSPARK_DRIVER_PYTHON</code> ;<code>PYSPARK_DRIVER_PYTHON</code> 就Ok啦！<br>比如我的配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYSPARK_PYTHON=~/anaconda3/bin/python3 PYSPARK_DRIVER_PYTHON=~/anaconda3/bin/ipython PYSPARK_DRIVER_PYTHON_OPTS=&quot;notebook&quot; /usr/local/spark/bin/pyspark</span><br></pre></td></tr></table></figure></p>
<p>其中要注意的是<code>PYSPARK_PYTHON</code>  <code>PYSPARK_DRIVER_PYTHON</code>两个版本要一样！</p>
<p>当然了，你要想偷懒 将就这三个环境配置 添加到 <code>~/.zshrc</code> 然后 <code>source ~/.zshrc</code> .<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># use IPython notebook in spark?</span><br><span class="line">export PYSPARK_PYTHON=~/anaconda3/bin/python3 # 你的python 路径</span><br><span class="line">export PYSPARK_DRIVER_PYTHON=~/anaconda3/bin/ipython # 你的ipython 路径</span><br><span class="line">export PYSPARK_DRIVER_PYTHON_OPTS=&quot;notebook&quot;</span><br></pre></td></tr></table></figure></p>
<p>那每次输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/spark/bin/pyspark</span><br></pre></td></tr></table></figure></p>
<p>就可以了！</p>
]]></content>
      
        <categories>
            
            <category> Spark </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> saprk </tag>
            
            <tag> IPython notebook </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[重启后ssh免密登陆失效]]></title>
      <url>/2016/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/Hadoop-%E6%80%BB%E7%BB%93-%E9%87%8D%E5%90%AF%E5%90%8Essh%E5%85%8D%E5%AF%86%E5%A4%B1%E6%95%88/</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>今天在配置hadoop开发环境 配置了ssh免密登陆可是还要密码，很是诧异，我不是配置过了吗？怎么没用……然后根据网上的教程：使用 <code>ssh-add</code>将私钥加入 ssh代理，搞定！<br>你以为这就完了吗？直到有一天重启了下hadoop，发现log里面竟然打出，需要让重新输入本机器密码的提示。我去！经过几次实验我现每次重启/开机必须<code>ssh-add</code>一次…………很烦的对不对？<a id="more"></a></p>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>查资料后发现：<br><code>ssh-add</code>这个命令不是用来永久性的记住你所使用的私钥的。实际上，它的作用只是把你指定的私钥添加到 <code>ssh-agent</code> 所管理的一个 session 当中。而 ssh-agent 是一个用于存储私钥的临时性的 session 服务，也就是说当你重启之后，ssh-agent 服务也就重置了。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><strong>使用持久化的安全的秘钥管理机制</strong><br>比如我用的Mac系统内置了一个 Keychain 的服务及其管理程序，可以方便的帮你管理各种秘钥，其中包括 ssh 秘钥。ssh-add 默认将制定的秘钥添加在当前运行的 ssh-agent 服务中，但是你可以改变这个默认行为让它添加到 keychain 服务中，让 Mac 来帮你记住、管理并保障这些秘钥的安全性。</p>
<p>你所要做的就是执行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add -K [path/to/your/ssh-key]</span><br></pre></td></tr></table></figure></p>
<p>之后，其他的程序请求 ssh 秘钥的时候，会通过 Keychain 服务来请求。</p>
]]></content>
      
        <categories>
            
            <category> hadoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> hadoop </tag>
            
            <tag> linux </tag>
            
            <tag> 安装 </tag>
            
            <tag> SSH </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop安装遇到的各种异常及解决办法]]></title>
      <url>/2016/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/Hadoop-%E6%80%BB%E7%BB%93-Hadoop%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%82%E5%B8%B8%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>这里是我总结 的几种Hadoop安装遇到的各种异常及解决办法 ，当然了，不断更新ing <a id="more"></a></p>
<h2 id="datanode-无法启动"><a href="#datanode-无法启动" class="headerlink" title="datanode 无法启动"></a>datanode 无法启动</h2><p>在集群模式下更改节点后，启动集群发现 datanode一直启动不起来。</p>
<h3 id="datanode启动日志："><a href="#datanode启动日志：" class="headerlink" title="datanode启动日志："></a>datanode启动日志：</h3><p><strong>话说查看日志是个好习惯！~</strong><br><a href="http://localhost:50070/logs/hadoop-wente-datanode-WenteMBP.local.log" target="_blank" rel="noopener">http://localhost:50070/logs/hadoop-wente-datanode-WenteMBP.local.log</a><br>查看日志发现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2016-05-30 18:23:05,353 WARN org.apache.hadoop.hdfs.server.common.Storage: java.io.IOException: Incompatible clusterIDs in /usr/local/hadoop/tmp/dfs/data: namenode clusterID = CID-67462a41-8696-4a84-872a-9ca9f2d761a4; datanode clusterID = CID-ffd63e83-81d6-4ee4-9752-ee7175a4f1b1</span><br><span class="line">2016-05-30 18:23:05,354 FATAL org.apache.hadoop.hdfs.server.datanode.DataNode: Initialization failed for Block pool &lt;registering&gt; (Datanode Uuid unassigned) service to WenteMBP/10.5.57.180:9000. Exiting.</span><br><span class="line">java.io.IOException: All specified directories are failed to load.</span><br><span class="line">	at org.apache.hadoop.hdfs.server.datanode.DataStorage.recoverTransitionRead(DataStorage.java:478)</span><br><span class="line">	at org.apache.hadoop.hdfs.server.datanode.DataNode.initStorage(DataNode.java:1358)</span><br><span class="line">	at org.apache.hadoop.hdfs.server.datanode.DataNode.initBlockPool(DataNode.java:1323)</span><br><span class="line">	at org.apache.hadoop.hdfs.server.datanode.BPOfferService.verifyAndSetNamespaceInfo(BPOfferService.java:317)</span><br><span class="line">	at org.apache.hadoop.hdfs.server.datanode.BPServiceActor.connectToNNAndHandshake(BPServiceActor.java:223)</span><br><span class="line">	at org.apache.hadoop.hdfs.server.datanode.BPServiceActor.run(BPServiceActor.java:802)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在<code>hdfs-site.xml</code>配置文件中，配置了<code>dfs.namenode.name.dir</code>，在master/slave中,该配置的目录下有个<code>dfs/name/current</code>文件夹，里面有个VERSION文件,操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">⇒   cd /usr/local/hadoop/tmp/dfs/name/current</span><br><span class="line">wente@WenteMBP:/usr/local/hadoop/tmp/dfs/name/current|master</span><br><span class="line">⇒  cat VERSION</span><br><span class="line">#Mon May 30 18:22:27 CST 2016</span><br><span class="line">namespaceID=746102010</span><br><span class="line">clusterID=CID-67462a41-8696-4a84-872a-9ca9f2d761a4</span><br><span class="line">cTime=0</span><br><span class="line">storageType=NAME_NODE</span><br><span class="line">blockpoolID=BP-320758889-10.5.57.180-1464603747179</span><br><span class="line">layoutVersion=-63</span><br></pre></td></tr></table></figure></p>
<p>2、在<code>core-site.xml</code>配置文件中，配置了<code>hadoop.tmp.dir</code>，在<code>master/slave</code>中,该配置的目录下有个<code>dfs/data/current</code>目录，里面也有一个VERSION文件，内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">⇒  cd /usr/local/hadoop/tmp/dfs/data/current</span><br><span class="line">wente@WenteMBP:/usr/local/hadoop/tmp/dfs/data/current|master</span><br><span class="line">⇒  cat VERSION</span><br><span class="line">#Mon May 30 11:22:41 CST 2016</span><br><span class="line">storageID=DS-a0978acf-4e59-4882-933b-4f74779cf076</span><br><span class="line">clusterID=CID-ffd63e83-81d6-4ee4-9752-ee7175a4f1b1</span><br><span class="line">cTime=0</span><br><span class="line">datanodeUuid=808e6f95-d172-4f12-9816-e4ef47c04e4f</span><br><span class="line">storageType=DATA_NODE</span><br><span class="line">layoutVersion=-56</span><br></pre></td></tr></table></figure></p>
<p>3、一目了然，两个内容不一样，导致的。删除master/slave中的错误内容，重启，搞定！</p>
<h2 id="SSH免密码登录失效的问题"><a href="#SSH免密码登录失效的问题" class="headerlink" title="SSH免密码登录失效的问题"></a>SSH免密码登录失效的问题</h2><p>在master已经把公钥复制到slave1的authorized_keys的情况下，master登录slave1每次仍然需要输入密码。</p>
<p>我TMD郁闷了一把。<br>试了好多办法，成功的是：<br>使用ssh-add 添加master的私钥到代理，这个很重要，不然每次登陆仍会输入密码，这大概就是一些人指的ssh-agent有关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wente@WenteMBP:~|master⚡⇒  ssh-add ./.ssh/hadoop_rsa</span><br><span class="line">Identity added: ./.ssh/hadoop_rsa (./.ssh/hadoop_rsa)</span><br><span class="line">wente@WenteMBP:~|master⚡⇒  ssh slave1</span><br><span class="line">Welcome to Ubuntu 12.04.2 LTS (GNU/Linux 3.5.0-23-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com/</span><br><span class="line"></span><br><span class="line">New release &apos;14.04.4 LTS&apos; available.</span><br><span class="line">Run &apos;do-release-upgrade&apos; to upgrade to it.</span><br><span class="line"></span><br><span class="line">Last login: Tue May 31 09:31:13 2016 from wentembp.local</span><br><span class="line">wente@Slaver1:~|⇒</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> hadoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> hadoop </tag>
            
            <tag> linux </tag>
            
            <tag> 安装 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中List的几种排序的辨析]]></title>
      <url>/2016/05/%E5%BE%85%E6%95%B4%E7%90%86/Python-%E6%80%BB%E7%BB%93-List%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BE%A8%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><a id="more"></a>
<h2 id="List的内建函数list-sort"><a href="#List的内建函数list-sort" class="headerlink" title="List的内建函数list.sort"></a>List的内建函数list.sort</h2><p><code>list.sort(func=None, key=None, reverse=False)</code><br>注意：<br> 序列类型函数sorted(list)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list  </span><br><span class="line">[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="序列类型函数sorted-list"><a href="#序列类型函数sorted-list" class="headerlink" title="序列类型函数sorted(list)"></a>序列类型函数sorted(list)</h2><p><code>sorted(iterable，cmp，key，reverse</code>）<br>参数：</p>
<ul>
<li>iterable可以是list或者iterator；</li>
<li>cmp是带两个参数的比较函数；</li>
<li>key 是带一个参数的函数；</li>
<li>reverse为False或者True(代表升序或者降序)</li>
</ul>
<h3 id="对第二个关键字排序"><a href="#对第二个关键字排序" class="headerlink" title="对第二个关键字排序"></a>对第二个关键字排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L = [(&apos;b&apos;,6),(&apos;a&apos;,1),(&apos;c&apos;,3),(&apos;d&apos;,4)]</span><br><span class="line">&gt;&gt;&gt;L.sort(lambda x,y:cmp(x[1],y[1]))</span><br><span class="line">&gt;&gt;&gt;L</span><br><span class="line">&gt;&gt;&gt;[(&apos;a&apos;, 1), (&apos;c&apos;, 3), (&apos;d&apos;, 4), (&apos;b&apos;, 6)]</span><br></pre></td></tr></table></figure>
<h3 id="对第二个关键字排序，方法二"><a href="#对第二个关键字排序，方法二" class="headerlink" title="对第二个关键字排序，方法二"></a>对第二个关键字排序，方法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L = [(&apos;b&apos;,2),(&apos;a&apos;,1),(&apos;c&apos;,3),(&apos;d&apos;,4)]</span><br><span class="line">&gt;&gt;&gt;import operator</span><br><span class="line">&gt;&gt;&gt;L.sort(key=operator.itemgetter(1))</span><br><span class="line">&gt;&gt;&gt;L</span><br><span class="line">&gt;&gt;&gt;[(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3), (&apos;d&apos;, 4)]</span><br></pre></td></tr></table></figure>
<h3 id="DSU方法-Decorate-Sort-Undercorate"><a href="#DSU方法-Decorate-Sort-Undercorate" class="headerlink" title="(DSU方法:Decorate-Sort-Undercorate)"></a>(DSU方法:Decorate-Sort-Undercorate)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L = [(&apos;b&apos;,2),(&apos;a&apos;,1),(&apos;c&apos;,3),(&apos;d&apos;,4)]</span><br><span class="line">&gt;&gt;&gt;A = [(x[1],i,x) for i,x in enumerate(L)] #i can confirm the stable sort</span><br><span class="line">&gt;&gt;&gt;A.sort()</span><br><span class="line">&gt;&gt;&gt;L = [s[2] for s in A]</span><br><span class="line">&gt;&gt;&gt;L</span><br><span class="line">&gt;&gt;&gt;[(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3), (&apos;d&apos;, 4)]</span><br></pre></td></tr></table></figure>
<h3 id="效率比较："><a href="#效率比较：" class="headerlink" title="效率比较："></a>效率比较：</h3><p>cmp &lt; DSU &lt; key</p>
<h2 id="sort-amp-sorted的区别"><a href="#sort-amp-sorted的区别" class="headerlink" title="sort &amp; sorted的区别"></a>sort &amp; sorted的区别</h2><p>sorted(list)返回一个对象。<strong>原来的list不变</strong>，生成一个新的排好序的list对象。<br>list.sort() 不会返回对象，<strong>改变原有的list</strong>。<br>sort函数是list列表中的函数，而sorted可以对list或者iterator进行排序（不是list也可以）</p>
<h2 id="argsort函数"><a href="#argsort函数" class="headerlink" title="argsort函数:"></a>argsort函数:</h2><p>返回的是数组值从小到大的索引值</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> Python3 </tag>
            
            <tag> 区别 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python2 / python3的区别-map & dict]]></title>
      <url>/2016/05/%E5%BE%85%E6%95%B4%E7%90%86/Python-%E6%80%BB%E7%BB%93-python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B9%8Bmap&amp;dict/</url>
      <content type="html"><![CDATA[<p>文章的主要内容有：（严肃脸）</p>
<ul>
<li>map函数返回值的不同</li>
<li>dict查找键值是否存在的方法的不同<a id="more"></a>
</li>
</ul>
<h2 id="map函数返回值的不同"><a href="#map函数返回值的不同" class="headerlink" title="map函数返回值的不同"></a>map函数返回值的不同</h2><p>python 2.X 中返回的是一个list<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>     <span class="keyword">return</span> x * x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure></p>
<p>python 3.X 中返回的是一个对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">&lt;map object at <span class="number">0x101d07278</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(r)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="dict查找键值是否存在的方法的不同："><a href="#dict查找键值是否存在的方法的不同：" class="headerlink" title="dict查找键值是否存在的方法的不同："></a>dict查找键值是否存在的方法的不同：</h2><p>有大神这么说：</p>
<blockquote>
<p><code>in</code> is definitely more pythonic.In fact <code>has_key()</code> was removed in Python 3.x.</p>
</blockquote>
<p>所以原来是这个样子的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line">d.has_key(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>在python3中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> Python3 </tag>
            
            <tag> 区别 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在各种编译器中设置用用空格替换tab键]]></title>
      <url>/2016/05/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-%E5%85%B6%E4%BB%96-%E5%9C%A8%E5%90%84%E7%A7%8D%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%94%A8%E7%94%A8%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2tab%E9%94%AE%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>制表符，又爱又恨的。因为这个东西只用一个字符却能代替一个空间。<br>但是有的开发工具却将制表符替换成空格，这样一来，我修改的代码别人的工具编辑后，就会出现很多不符的问题。导致代码混乱难以阅读。这时候，最好的方法就是将制表符统一。<br>更关键的是如果你在写Python代码，那么会出现很多问题，Python是以严格的缩进和对齐来标识代码段的，但是混合使用空格和tab键，就会出现诸多问题，报各种各样的格式错误，为了防止这种混乱，大多数情况下，良好的Coder会用空格来代替tab键<br>一般，我们会将制表符用4个空格代替，也有的人习惯2个空格。但实际2个空格空间太狭小了，不容易阅读。4个更好一点。<br><a id="more"></a></p>
<h2 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h2><p>当你启用了 Soft Tabs, Atom 将会在你按 tab 键时用空格来替代真正的制表符，Tab Length 则指定了一个制表符代表多少个空格，或者当 Soft Tabs 被禁用时多少个空格相当于一个制表符。</p>
<p>如果开启了 Soft Wrap 选项，Atom 会在一行中的文本超出屏幕显示范围时将其折为两行，如果禁用了这个选项，过长的行将简单地超出屏幕显示范围，你必须要横向移动滚动条才能看到剩余的部分。如果 Soft Wrap At Preferred Line Length 选项被开启，则总是会在 80 个字符处折行，你也可以设置一个自定义的长度来替换掉默认的 80 个字符。</p>
<h2 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h2><p>方法一，修改用户配置文件<br>打开默认配置文件 Preference -&gt; Settings-User(首选项 / 设置-用户)，添加或者修改如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// The number of spaces a tab is considered equal to  </span><br><span class="line">&quot;tab_size&quot;: 4,  </span><br><span class="line">// Set to true to insert spaces when tab is pressed  </span><br><span class="line">&quot;translate_tabs_to_spaces&quot;: true,</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Atom </tag>
            
            <tag> TAB键 </tag>
            
            <tag> Sublime Text </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pandas DataFrame如何选取并修改指定行列的某个数值（value）]]></title>
      <url>/2016/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ML-%E6%80%BB%E7%BB%93-pandas%E4%B8%ADDataFrame%E5%A6%82%E4%BD%95%E9%80%89%E5%8F%96%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E8%A1%8C%E5%88%97%E7%9A%84%E6%9F%90%E4%B8%AA%E6%95%B0%E5%80%BC/</url>
      <content type="html"><![CDATA[<h3 id="我的问题"><a href="#我的问题" class="headerlink" title="我的问题"></a>我的问题</h3><p>DataFrame的操作有好多的教程，但我好找了好久，大多是仿《用python 进行数据 分析》这本书的结构，大篇幅的将对行和列的操作，以至于我想找 <strong>如何选取单个数值的时候</strong>，死活没有人说怎么做，是我问的忒基础了，还是pandas不支持？<br>同时还有第二个问题：<strong>如何更改某个值</strong>？DataFrame的选取操作返回的都是原数据的一个切片，当你选取以后进行了操作，发现原数据并没有改变。当然人有说你可以去覆盖，但是实践发现，当选取是的非整个行（列）时，问题又回到了原点。所以 <strong>先选取再修改是不对的思路</strong>，正确的是 <strong>定位+修改</strong><br><a id="more"></a></p>
<h3 id="我们先构造一个testDF"><a href="#我们先构造一个testDF" class="headerlink" title="我们先构造一个testDF"></a>我们先构造一个testDF</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'a'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">'b'</span>:[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="string">'c'</span>:[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]&#125;)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p><img src="/01.png" alt="png"></p>
<h3 id="单纯的只是想get-一个值"><a href="#单纯的只是想get-一个值" class="headerlink" title="单纯的只是想get 一个值"></a>单纯的只是想get 一个值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.get_value(<span class="number">0</span>,<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>
<p>1</p>
<h3 id="方法1：set-value（行名称，列名称，新值）"><a href="#方法1：set-value（行名称，列名称，新值）" class="headerlink" title="方法1：set_value（行名称，列名称，新值）"></a>方法1：set_value（行名称，列名称，新值）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.set_value(<span class="number">0</span>,<span class="string">'a'</span>,<span class="number">9</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p><img src="/02.png" alt="png"></p>
<h3 id="方法2：-iloc-行标-列标"><a href="#方法2：-iloc-行标-列标" class="headerlink" title="方法2： iloc [行标] [列标]"></a>方法2： iloc [行标] [列标]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">88</span></span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p><img src="/03.png" alt="png"></p>
<h3 id="方法3：-loc-行名称，列名称"><a href="#方法3：-loc-行名称，列名称" class="headerlink" title="方法3： loc [行名称，列名称]"></a>方法3： loc [行名称，列名称]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.loc[<span class="number">2</span>,<span class="string">'c'</span>] = <span class="number">66</span></span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p><img src="/04.png" alt="png"></p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据操作 </tag>
            
            <tag> pandas </tag>
            
            <tag> DataFram </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python花式读取数据]]></title>
      <url>/2016/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ML-%E6%80%BB%E7%BB%93-python%E8%8A%B1%E5%BC%8F%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>我总结的的几种常用的读取数据的方法，和技巧。<br>不断更新Ing<a id="more"></a></p>
<h2 id="genfromtxt"><a href="#genfromtxt" class="headerlink" title="genfromtxt"></a>genfromtxt</h2><p>注意：读取出来的的一个矩阵，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> genfromtxt, zeros</span><br><span class="line">data = genfromtxt(<span class="string">'./data/mars_tianchi_user_actions.csv'</span>,delimiter=<span class="string">','</span>,usecols=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure></p>
<h2 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">songData =[]</span><br><span class="line">artists = []</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./data/mars_tianchi_songs.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.reader(f)</span><br><span class="line">    <span class="comment"># headers = next(f_csv)</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> f_csv:</span><br><span class="line">        songData.append(row)</span><br><span class="line">        artists.append(row[<span class="number">1</span>])</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<h2 id="pandas-Df"><a href="#pandas-Df" class="headerlink" title="pandas Df"></a>pandas Df</h2><p>这里要注意的是怎么加载列标签：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">names = [<span class="string">'song_id'</span>, <span class="string">'artist_id'</span>, <span class="string">'publish_time'</span>,<span class="string">'song_init_plays'</span>,<span class="string">'Language'</span>,<span class="string">'Gender'</span>]</span><br><span class="line">song_data = pd.read_csv(<span class="string">'./data/mars_tianchi_songs.csv'</span>,names=names)</span><br><span class="line"><span class="keyword">print</span> song_data.head()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\n Data Types:'</span></span><br><span class="line"><span class="keyword">print</span> song_data.dtypes</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 读取数据 </tag>
            
            <tag> CSV </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用Python练习数据挖掘实例]]></title>
      <url>/2016/05/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/DM-%E6%80%BB%E7%BB%93-%E5%88%A9%E7%94%A8Python%E7%BB%83%E4%B9%A0%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p>参考：<a href="https://dzone.com/refcardz/data-mining-discovering-and" target="_blank" rel="noopener">https://dzone.com/refcardz/data-mining-discovering-and</a><br>主要内容有（嘿嘿，手动严肃）：<br>导入和可视化数据；数据分类；使用回归分析和相关测量法发现数据之间的关系；数据降维以压缩和可视化数据带来的信息</p>
<p>文章中的代码基于四个主要的Python数据分析和处理的类库：numpy，matplotlib，sklearn和networkx。<br><a id="more"></a></p>
<h2 id="数据导入和可视化"><a href="#数据导入和可视化" class="headerlink" title="数据导入和可视化"></a>数据导入和可视化</h2><h3 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从网上下载数据并保存</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line">url = <span class="string">'http://aima.cs.berkeley.edu/data/iris.csv'</span></span><br><span class="line">u = urllib2.urlopen(url)</span><br><span class="line">localFile = open(<span class="string">'iris.csv'</span>,<span class="string">'w'</span>)</span><br><span class="line">localFile.write(u.read())</span><br><span class="line">localFile.close()</span><br></pre></td></tr></table></figure>
<p>数据集以CSV(逗号分割值）的格式存储。CSV文件可以很方便的转化并把其中的信息存储为适合的数据结构。此数据集有5列，前4列包含着特征值，最后一列代表着样本类型。CSV文件很容易被numpy类库的genfromtxt方法解析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建了一个包含特征值的矩阵以及一个包含样本类型的向量。</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> genfromtxt, zeros</span><br><span class="line"><span class="comment"># read the first 4 columns</span></span><br><span class="line">data = genfromtxt(<span class="string">'iris.csv'</span>,delimiter=<span class="string">','</span>,usecols=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># read the fifth column</span></span><br><span class="line">target = genfromtxt(<span class="string">'iris.csv'</span>,delimiter=<span class="string">','</span>,usecols=(<span class="number">4</span>),dtype=str)</span><br></pre></td></tr></table></figure>
<p>在上面的例子中我们创建了一个包含特征值的矩阵以及一个包含样本类型的向量。我们可以通过查看我们加载的数据结构的shape值来确认数据集的大小：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过查看我们加载的数据结构的shape值来确认数据集的大小：</span></span><br><span class="line"><span class="keyword">print</span> data.dtype</span><br><span class="line"><span class="keyword">print</span> data.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span> target.shape</span><br><span class="line">(<span class="number">150</span>,)</span><br><span class="line"><span class="comment"># 查看我们有多少种样本类型以及它们的名字：</span></span><br><span class="line"><span class="keyword">print</span> set(target) <span class="comment"># build a collection of unique elements</span></span><br></pre></td></tr></table></figure>
<pre><code>float64
(150, 4)
(150,)
set([&apos;setosa&apos;, &apos;versicolor&apos;, &apos;virginica&apos;])
</code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>当我们处理新数据的时候，一项很重要的任务是尝试去理解数据包含的信息以及它的组织结构。可视化可以灵活生动的展示数据，帮助我们深入理解数据。</p>
<p>使用pylab类库（matplotlib的接口）的plotting方法可以建一个二维散点图让我们在两个维度上分析数据集的两个特征值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一个二维散点图让我们在两个维度上分析数据集的两个特征值：</span></span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> plot, show</span><br><span class="line">% matplotlib inline</span><br><span class="line">plot(data[target==<span class="string">'setosa'</span>,<span class="number">0</span>],data[target==<span class="string">'setosa'</span>,<span class="number">2</span>],<span class="string">'bo'</span>)</span><br><span class="line">plot(data[target==<span class="string">'versicolor'</span>,<span class="number">0</span>],data[target==<span class="string">'versicolor'</span>,<span class="number">2</span>],<span class="string">'ro'</span>)</span><br><span class="line">plot(data[target==<span class="string">'virginica'</span>,<span class="number">0</span>],data[target==<span class="string">'virginica'</span>,<span class="number">2</span>],<span class="string">'go'</span>)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<p><img src="/output_8_0.png" alt="png"></p>
<p>在上图中有150个点，不同的颜色代表不同的类型；蓝色点代表山鸢尾，红色点代表变色鸢尾，绿色点代表维吉尼亚鸢尾。</p>
<p>另一种常用的查看数据的方法是分特性绘制直方图。在本例中，既然数据被分为三类，我们就可以比较每一类的分布特征。下面这个代码可以绘制数据中每一类型的第一个特性（花萼的长度）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> figure, subplot, hist, xlim, show</span><br><span class="line">xmin = min(data[:,<span class="number">0</span>])</span><br><span class="line">xmax = max(data[:,<span class="number">0</span>])</span><br><span class="line">figure()</span><br><span class="line">subplot(<span class="number">411</span>) <span class="comment"># distribution of the setosa class (1st, on the top)</span></span><br><span class="line">hist(data[target==<span class="string">'setosa'</span>,<span class="number">0</span>],color=<span class="string">'b'</span>,alpha=<span class="number">.7</span>)</span><br><span class="line">xlim(xmin,xmax)</span><br><span class="line">subplot(<span class="number">412</span>) <span class="comment"># distribution of the versicolor class (2nd)</span></span><br><span class="line">hist(data[target==<span class="string">'versicolor'</span>,<span class="number">0</span>],color=<span class="string">'r'</span>,alpha=<span class="number">.7</span>)</span><br><span class="line">xlim(xmin,xmax)</span><br><span class="line">subplot(<span class="number">413</span>) <span class="comment"># distribution of the virginica class (3rd)</span></span><br><span class="line">hist(data[target==<span class="string">'virginica'</span>,<span class="number">0</span>],color=<span class="string">'g'</span>,alpha=<span class="number">.7</span>)</span><br><span class="line">xlim(xmin,xmax)</span><br><span class="line">subplot(<span class="number">414</span>) <span class="comment"># global histogram (4th, on the bottom)</span></span><br><span class="line">hist(data[:,<span class="number">0</span>],color=<span class="string">'y'</span>,alpha=<span class="number">.7</span>)</span><br><span class="line">xlim(xmin,xmax)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<p><img src="/output_11_0.png" alt="png"></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>sklearn类库包含很多分类器的实现，我们将会用高斯朴素贝叶斯来分析我们在第一章载入的鸢尾花数据，包含山鸢尾、变色鸢尾和维吉尼亚鸢尾。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把字符串数组转型成整型数据：</span></span><br><span class="line">t = zeros(len(target))</span><br><span class="line">t[target == <span class="string">'setosa'</span>] = <span class="number">1</span></span><br><span class="line">t[target == <span class="string">'versicolor'</span>] = <span class="number">2</span></span><br><span class="line">t[target == <span class="string">'virginica'</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 分类器实例化和训练分类器的准备了：</span></span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line">classifier = GaussianNB()</span><br><span class="line">classifier.fit(data,t) <span class="comment"># training on the iris dataset</span></span><br></pre></td></tr></table></figure>
<pre><code>GaussianNB()
</code></pre><p>很简单的检测：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 很简单的检测：</span></span><br><span class="line"><span class="comment"># 分类器可以由predict方法完成，并且只要输出一个样例就可以很简单的检测：</span></span><br><span class="line"><span class="keyword">print</span> classifier.predict(data[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">print</span> t[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<pre><code>[ 1.]
1.0


/Users/wente/anaconda/lib/python2.7/site-packages/sklearn/utils/validation.py:386: DeprecationWarning: Passing 1d arrays as data is deprecated in 0.17 and willraise ValueError in 0.19. Reshape your data either using X.reshape(-1, 1) if your data has a single feature or X.reshape(1, -1) if it contains a single sample.
  DeprecationWarning)
</code></pre><h3 id="拆分训练集和测试集"><a href="#拆分训练集和测试集" class="headerlink" title="拆分训练集和测试集"></a>拆分训练集和测试集</h3><p>上面的测试使用了训练集的数据，但是在广泛的样本上评估分类器并且使用非训练环节的数据测试是很重要的。最终我们通过从源数据集中随机抽取样本把数据分为训练集和测试集。我们将会使用训练集的数据来训练分类器，并使用测试集的数据来测试分类器。train_test_split方法正是实现此功能的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从样本中随机的按比例选取train data和test data。</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> cross_validation</span><br><span class="line">train, test, t_train, t_test = cross_validation.train_test_split(data, t, test_size=<span class="number">0.4</span>, random_state=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>数据集被分一分为二，测试集被指定为源数据的40%（命名为test_size），random_state是随机数的种子。不同的种子会造成不同的随机采样结果。相同的种子采样结果相同。</p>
<p>下面就是利用其反复训练我们的分类器并输出精确度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.fit(train,t_train) <span class="comment"># train</span></span><br></pre></td></tr></table></figure>
<pre><code>GaussianNB()
</code></pre><h3 id="评价：精确度"><a href="#评价：精确度" class="headerlink" title="评价：精确度"></a>评价：精确度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> classifier.score(test,t_test) <span class="comment"># test</span></span><br></pre></td></tr></table></figure>
<pre><code>0.933333333333
</code></pre><p>上面得出精确度为93%。一个分类器的精确度是通过正确分类样本的数量除以总样本的数量得出的。也就是说，它意味着我们正确预测的比例。</p>
<h3 id="评价：混淆矩阵"><a href="#评价：混淆矩阵" class="headerlink" title="评价：混淆矩阵"></a>评价：混淆矩阵</h3><p>另一个估计分类器表现的工具叫做混淆矩阵。在此矩阵中每列代表一个预测类的实例，每行代表一个实际类的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">print</span> confusion_matrix(classifier.predict(test),t_test)</span><br></pre></td></tr></table></figure>
<pre><code>[[16  0  0]
 [ 0 23  4]
 [ 0  0 17]]
</code></pre><p>混淆矩阵的评价：所有正确的预测都在表格的对角线上，的错误就即对角线以外的非零值。<br>在这个混淆矩阵中我们可以看到所有山鸢尾和维吉尼亚鸢尾都被正确的分类了，但是实际上应该是26个的变色鸢尾，系统却预测其中4个是维吉尼亚鸢尾。如果</p>
<h3 id="评价：分类器性能报告"><a href="#评价：分类器性能报告" class="headerlink" title="评价：分类器性能报告"></a>评价：分类器性能报告</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">print</span> classification_report(classifier.predict(test), t_test, target_names=[<span class="string">'setosa'</span>, <span class="string">'versicolor'</span>, <span class="string">'virginica'</span>])</span><br></pre></td></tr></table></figure>
<pre><code>             precision    recall  f1-score   support

     setosa       1.00      1.00      1.00        16
 versicolor       1.00      0.85      0.92        27
  virginica       0.81      1.00      0.89        17

avg / total       0.95      0.93      0.93        60
</code></pre><p>以下是该报告使用到的方法总结：<br>Precision：正确预测的比例<br>Recall（或者叫真阳性率）：正确识别的比例<br>F1-Score：precision和recall的调和平均数</p>
<h3 id="评价：交叉验证"><a href="#评价：交叉验证" class="headerlink" title="评价：交叉验证"></a>评价：交叉验证</h3><p>思想：多次将数据分为不同的训练集和测试集，最终分类器评估选取多次预测的平均值。方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="comment"># cross validation with 6 iterations</span></span><br><span class="line">scores = cross_val_score(classifier, data, t, cv=<span class="number">6</span>)</span><br><span class="line"><span class="keyword">print</span> scores</span><br></pre></td></tr></table></figure>
<pre><code>[ 0.92592593  1.          0.91666667  0.91666667  0.95833333  1.        ]
</code></pre><p>输出是每次模型迭代产生的精确度的数组。我们可以很容易计算出平均精确度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> mean</span><br><span class="line"><span class="keyword">print</span> mean(scores)</span><br></pre></td></tr></table></figure>
<pre><code>0.952932098765
</code></pre><h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><p>是一种无监督数据分析，下面就是最著名的聚类工具k-means算法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">3</span>, init=<span class="string">'random'</span>) <span class="comment"># initialization</span></span><br><span class="line">kmeans.fit(data) <span class="comment"># actual execution</span></span><br></pre></td></tr></table></figure>
<pre><code>KMeans(copy_x=True, init=&apos;random&apos;, max_iter=300, n_clusters=3, n_init=10,
    n_jobs=1, precompute_distances=&apos;auto&apos;, random_state=None, tol=0.0001,
    verbose=0)
</code></pre><p>上面运行k-measn算法并把数据分为三个群集（参数n_clusters所指定的）。下面使用模型把每一个样本分配到三个群集中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = kmeans.predict(data)</span><br></pre></td></tr></table></figure>
<h3 id="评估：完整性得分、同质性得分"><a href="#评估：完整性得分、同质性得分" class="headerlink" title="评估：完整性得分、同质性得分"></a>评估：完整性得分、同质性得分</h3><p>估计群集的结果，与使用完整性得分和同质性得分计算而得的标签作比较：</p>
<p>大部分数据点属于一个给定的类并且属于同一个群集，那么完整性得分就趋向于1。<br>当所有群集都几乎只包含某个单一类的数据点时同质性得分就趋向于1.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> completeness_score, homogeneity_score</span><br><span class="line"><span class="keyword">print</span> completeness_score(t,c)</span><br><span class="line"><span class="keyword">print</span> homogeneity_score(t,c)</span><br></pre></td></tr></table></figure>
<pre><code>0.764986151449
0.751485402199
</code></pre><h3 id="评估：结果可视化"><a href="#评估：结果可视化" class="headerlink" title="评估：结果可视化"></a>评估：结果可视化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">figure()</span><br><span class="line">subplot(<span class="number">211</span>) <span class="comment"># top figure with the real classes</span></span><br><span class="line">plot(data[t==<span class="number">1</span>,<span class="number">0</span>],data[t==<span class="number">1</span>,<span class="number">2</span>],<span class="string">'bo'</span>)</span><br><span class="line">plot(data[t==<span class="number">2</span>,<span class="number">0</span>],data[t==<span class="number">2</span>,<span class="number">2</span>],<span class="string">'ro'</span>)</span><br><span class="line">plot(data[t==<span class="number">3</span>,<span class="number">0</span>],data[t==<span class="number">3</span>,<span class="number">2</span>],<span class="string">'go'</span>)</span><br><span class="line">subplot(<span class="number">212</span>) <span class="comment"># bottom figure with classes assigned automatically</span></span><br><span class="line">plot(data[c==<span class="number">2</span>,<span class="number">0</span>],data[c==<span class="number">2</span>,<span class="number">2</span>],<span class="string">'bo'</span>,alpha=<span class="number">.7</span>)</span><br><span class="line">plot(data[c==<span class="number">1</span>,<span class="number">0</span>],data[c==<span class="number">1</span>,<span class="number">2</span>],<span class="string">'go'</span>,alpha=<span class="number">.7</span>)</span><br><span class="line">plot(data[c==<span class="number">0</span>,<span class="number">0</span>],data[c==<span class="number">0</span>,<span class="number">2</span>],<span class="string">'mo'</span>,alpha=<span class="number">.7</span>)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<p><img src="/output_41_0.png" alt="png"></p>
<p>观察此图我们可以看到，底部左侧的群集可以被k-means完全识别，然而顶部的两个群集有部分识别错误。</p>
<h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>回归是一个用于预测变量之间函数关系调查的方法。例如，我们有两个变量，一个被认为是解释，一个被认为是依赖。我们希望使用模型描述两者的关系。当这种关系是一条线的时候就称为线性回归。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建数据集</span></span><br><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> rand</span><br><span class="line">x = rand(<span class="number">40</span>,<span class="number">1</span>) <span class="comment"># explanatory variable</span></span><br><span class="line">y = x*x*x+rand(<span class="number">40</span>,<span class="number">1</span>)/<span class="number">5</span> <span class="comment"># depentend variable</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">linreg = LinearRegression()</span><br><span class="line">linreg.fit(x,y)</span><br></pre></td></tr></table></figure>
<pre><code>LinearRegression(copy_X=True, fit_intercept=True, n_jobs=1, normalize=False)
</code></pre><h3 id="评估：结果可视化-1"><a href="#评估：结果可视化-1" class="headerlink" title="评估：结果可视化"></a>评估：结果可视化</h3><p>把拟合线和实际数据点画在同一幅图上来评估结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> linspace, matrix</span><br><span class="line">xx = linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">40</span>) <span class="comment"># 产生0-1之间40个数，步长相等</span></span><br><span class="line">plot(x,y,<span class="string">'go'</span>)</span><br><span class="line">plot(xx,linreg.predict(matrix(xx).T),<span class="string">'--r'</span>)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<p><img src="/output_47_0.png" alt="png"></p>
<h3 id="评估：均方误差"><a href="#评估：均方误差" class="headerlink" title="评估：均方误差"></a>评估：均方误差</h3><p>使用均方误差来量化模型和原始数据的拟合度：<br>该指标度量了预期的拟合线和真实数据之间的距离平方。当拟合线很完美时该值为0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">print</span> mean_squared_error(linreg.predict(x),y)</span><br></pre></td></tr></table></figure>
<pre><code>0.00967543840746
</code></pre><h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p>最著名的降维技术之一就是主成分分析（PCA）。该技术把数据变量转换为等量或更少的不相关变量，称为主成分（PCs）。</p>
<p>下面我们实例化了一个PCA对象，用于计算前两个主成分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="转换计算如下："><a href="#转换计算如下：" class="headerlink" title="转换计算如下："></a>转换计算如下：</h3><p>将原来的四维数据转换为两维</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcad = pca.fit_transform(data)</span><br></pre></td></tr></table></figure>
<h3 id="结果可视化"><a href="#结果可视化" class="headerlink" title="结果可视化"></a>结果可视化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 原来的数据</span></span><br><span class="line">subplot(<span class="number">121</span>)  </span><br><span class="line">plot(data[target==<span class="string">'setosa'</span>,<span class="number">0</span>],data[target==<span class="string">'setosa'</span>,<span class="number">2</span>],<span class="string">'bo'</span>)</span><br><span class="line">plot(data[target==<span class="string">'versicolor'</span>,<span class="number">0</span>],data[target==<span class="string">'versicolor'</span>,<span class="number">2</span>],<span class="string">'ro'</span>)</span><br><span class="line">plot(data[target==<span class="string">'virginica'</span>,<span class="number">0</span>],data[target==<span class="string">'virginica'</span>,<span class="number">2</span>],<span class="string">'go'</span>)</span><br><span class="line"><span class="comment">## 降维后的数据</span></span><br><span class="line">subplot(<span class="number">122</span>)</span><br><span class="line">plot(pcad[target==<span class="string">'setosa'</span>,<span class="number">0</span>],pcad[target==<span class="string">'setosa'</span>,<span class="number">1</span>],<span class="string">'bo'</span>)</span><br><span class="line">plot(pcad[target==<span class="string">'versicolor'</span>,<span class="number">0</span>],pcad[target==<span class="string">'versicolor'</span>,<span class="number">1</span>],<span class="string">'ro'</span>)</span><br><span class="line">plot(pcad[target==<span class="string">'virginica'</span>,<span class="number">0</span>],pcad[target==<span class="string">'virginica'</span>,<span class="number">1</span>],<span class="string">'go'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[&lt;matplotlib.lines.Line2D at 0x108e44210&gt;]
</code></pre><p><img src="/output_55_1.png" alt="png"></p>
<p>两个图有些相似，降维后，变色鸢尾（红色的）和维吉尼亚鸢尾（绿色的）的间隔更清晰了。</p>
<h3 id="信息量判断"><a href="#信息量判断" class="headerlink" title="信息量判断"></a>信息量判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方差比判断PCs包含的信息量：</span></span><br><span class="line"><span class="keyword">print</span> pca.explained_variance_ratio_</span><br></pre></td></tr></table></figure>
<pre><code>[ 0.92461621  0.05301557]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出在转化过程中丢失的信息量</span></span><br><span class="line"><span class="keyword">print</span> <span class="number">1</span>-sum(pca.explained_variance_ratio_)</span><br></pre></td></tr></table></figure>
<pre><code>0.0223682249752
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过改变主成分的数值来计算我们能够覆盖多少信息量</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    pca = PCA(n_components=i)</span><br><span class="line">    pca.fit(data)</span><br><span class="line">    <span class="keyword">print</span> sum(pca.explained_variance_ratio_) * <span class="number">100</span>,<span class="string">'%'</span></span><br></pre></td></tr></table></figure>
<pre><code>92.4616207174 %
97.7631775025 %
99.481691455 %
100.0 %
</code></pre><p>可以发现PCs用得越多，信息覆盖就越全，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 数据挖掘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> ML </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> DM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[几种常见的回归算法]]></title>
      <url>/2016/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ML-%E6%80%BB%E7%BB%93-%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>重点总结了应该掌握的线性回归、逻辑回归、多项式回归、逐步回归、岭回归、套索回归、ElasticNet回归等七种最常用的回归技术及其关键要素，最后介绍了选择正确的回归模型的关键因素。<a id="more"></a></p>
<h2 id="什么是回归分析？"><a href="#什么是回归分析？" class="headerlink" title="什么是回归分析？"></a>什么是回归分析？</h2><p>回归分析是一种预测性的建模技术，它研究的是因变量（目标）和自变量（预测器）之间的关系。回归分析通常用于预测分析，时间序列模型以及发现变量之间的因果关系。例如，司机的鲁莽驾驶与道路交通事故数量之间的关系，最好的研究方法就是回归。</p>
<h2 id="Linear-Regression线性回归"><a href="#Linear-Regression线性回归" class="headerlink" title="Linear Regression线性回归"></a>Linear Regression线性回归</h2><p>线性回归通常是人们在学习预测模型时首选的技术之一。在这种技术中，因变量是连续的，自变量可以是连续的也可以是离散的，回归线的性质是线性的。</p>
<p>线性回归使用最佳的拟合直线（也就是回归线）在因变量（Y）和一个或多个自变量（X）之间建立一种关系。<br>用一个方程式来表示它，即Y=a+b*X + e，其中a表示截距，b表示直线的斜率，e是误差项。这个方程可以根据给定的预测变量（s）来预测目标变量的值。</p>
<h3 id="如何获得最佳拟合线（a和b的值）？"><a href="#如何获得最佳拟合线（a和b的值）？" class="headerlink" title="如何获得最佳拟合线（a和b的值）？"></a>如何获得最佳拟合线（a和b的值）？</h3><p>使用最小二乘法,最小二乘法也是用于拟合回归线最常用的方法.</p>
<p>最小二乘法对于观测数据，它通过最小化每个数据点到线的垂直偏差平方和来计算最佳拟合线。因为在相加时，偏差先平方，所以正值和负值没有抵消。</p>
<h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><ul>
<li>自变量与因变量之间必须有线性关系</li>
<li>多元回归存在多重共线性，自相关性和异方差性。</li>
<li>线性回归对异常值非常敏感。它会严重影响回归线，最终影响预测值。</li>
<li>多重共线性会增加系数估计值的方差，使得在模型轻微变化下，估计非常敏感。结果就是系数估计值不稳定</li>
<li>在多个自变量的情况下，我们可以使用向前选择法，向后剔除法和逐步筛选法来选择最重要的自变量。</li>
</ul>
<h2 id="Logistic-Regression逻辑回归"><a href="#Logistic-Regression逻辑回归" class="headerlink" title="Logistic Regression逻辑回归"></a>Logistic Regression逻辑回归</h2><p>逻辑回归是用来计算“事件=Success”和“事件=Failure”的概率。<br>当因变量的类型属于 <strong>二元（1 / 0，真/假，是/否）变量</strong> 时，我们就应该使用逻辑回归。</p>
<h3 id="要点：-1"><a href="#要点：-1" class="headerlink" title="要点："></a>要点：</h3><ul>
<li>它广泛的用于分类问题。</li>
<li>辑回归不要求自变量和因变量是线性关系。它可以处理各种类型的关系，因为它对预测的相对风险指数OR使用了一个非线性的log转换。</li>
<li>为了避免过拟合和欠拟合，我们应该包括所有重要的变量。有一个很好的方法来确保这种情况，就是使用逐步筛选方法来估计逻辑回归。</li>
<li>它需要 <strong>大的样本量</strong>，因为在样本数量较少的情况下，极大似然估计的效果比普通的最小二乘法差。</li>
<li>自变量不应该相互关联的，即不具有多重共线性。然而，在分析和建模中，我们可以选择包含分类变量相互作用的影响。</li>
<li>如果因变量的值是定序变量，则称它为 <strong>序逻辑回归</strong>。</li>
<li>如果因变量是多类的话，则称它为 <strong>多元逻辑回归</strong>。</li>
</ul>
<h2 id="Polynomial-Regression多项式回归"><a href="#Polynomial-Regression多项式回归" class="headerlink" title="Polynomial Regression多项式回归"></a>Polynomial Regression多项式回归</h2><p>对于一个回归方程，如果自变量的指数大于1，那么它就是多项式回归方程。<br>多项式回归中最佳拟合线不是直线。而是一个用于拟合数据点的 <strong>曲线</strong>。</p>
<h2 id="Stepwise-Regression逐步回归"><a href="#Stepwise-Regression逐步回归" class="headerlink" title="Stepwise Regression逐步回归"></a>Stepwise Regression逐步回归</h2><p>在处理多个自变量时，我们可以使用这种形式的回归。在这种技术中，自变量的选择是在一个自动的过程中完成的，其中包括非人为操作。<br>算法的目标使用最少的预测变量数来最大化预测能力。这也是<strong>处理高维数据集</strong> 的方法之一。</p>
<h2 id="实现方法原理是："><a href="#实现方法原理是：" class="headerlink" title="实现方法原理是："></a>实现方法原理是：</h2><p>通过观察统计的值，如R-square，t-stats和AIC指标，来识别重要的变量。逐步回归通过同时添加/删除基于指定标准的协变量来拟合模型。下面列出了一些最常用的逐步回归方法：</p>
<ul>
<li>标准逐步回归法做两件事情。即增加和删除每个步骤所需的预测。</li>
<li>向前选择法从模型中最显著的预测开始，然后为每一步添加变量。</li>
<li>向后剔除法与模型的所有预测同时开始，然后在每一步消除最小显着性的变量。</li>
</ul>
<h2 id="Ridge-Regression岭回归"><a href="#Ridge-Regression岭回归" class="headerlink" title="Ridge Regression岭回归"></a>Ridge Regression岭回归</h2><p>岭回归分析是一种用于存在多重共线性（自变量高度相关）数据的技术。在多重共线性情况下，尽管最小二乘法（OLS）对每个变量很公平，但它们的差异很大，使得观测值偏移并远离真实值。岭回归通过给回归估计上增加一个偏差度，来降低标准误差。<br>#</p>
<h2 id="要点：-2"><a href="#要点：-2" class="headerlink" title="要点："></a>要点：</h2><ul>
<li>除常数项以外，这种回归的假设与最小二乘回归类似；</li>
<li>它收缩了相关系数的值，但没有达到零，这表明它<strong>没有特征选择功能</strong></li>
<li>这是一个正则化方法，并且使用的是L2正则化。</li>
</ul>
<h2 id="Lasso-Regression套索回归"><a href="#Lasso-Regression套索回归" class="headerlink" title="Lasso Regression套索回归"></a>Lasso Regression套索回归</h2><p>类似于岭回归，Lasso （Least Absolute Shrinkage and Selection Operator）也会惩罚回归系数的绝对值大小。此外，它能够减少变化程度并提高线性回归模型的精度。</p>
<p>如果预测的一组变量是高度相关的，Lasso 会选出其中一个变量并且将其它的收缩为零。</p>
<h3 id="要点：-3"><a href="#要点：-3" class="headerlink" title="要点："></a>要点：</h3><ul>
<li>除常数项以外，这种回归的假设与最小二乘回归类似；</li>
<li>它收缩系数接近零（等于零），这确实 <strong>有助于特征选择</strong>；</li>
<li>这是一个正则化方法，使用的是L1正则化；</li>
</ul>
<h2 id="ElasticNet回归"><a href="#ElasticNet回归" class="headerlink" title="ElasticNet回归"></a>ElasticNet回归</h2><p>ElasticNet是Lasso和Ridge回归技术的混合体。它使用L1来训练并且L2优先作为正则化矩阵。当有多个相关的特征时，ElasticNet是很有用的。Lasso 会随机挑选他们其中的一个，而ElasticNet则会选择两个。</p>
<p>Lasso和Ridge之间的实际的优点是，它允许ElasticNet继承循环状态下Ridge的一些 <strong>稳定性</strong>。</p>
<p>要点：</p>
<ul>
<li>在高度相关变量的情况下，它会产生群体效应；</li>
<li>选择变量的数目没有限制；</li>
<li>它可以承受双重收缩。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> ML </tag>
            
            <tag> 回归 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习中回归类算法的理解]]></title>
      <url>/2016/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ML-%E6%80%BB%E7%BB%93-%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>回归算法是后面若干强大算法的基石，如果不理解回归算法，无法学习那些强大的算法。这也就是为什么在大部分机器学习课程中，回归算法都是介绍的第一个算法。<br>而回归又分为 线性回归和逻辑回归。<a id="more"></a></p>
<h2 id="线性回归："><a href="#线性回归：" class="headerlink" title="线性回归："></a>线性回归：</h2><p>线性回归目的就是： <strong>拟合出一条直线最佳匹配我所有的数据</strong>。<br>这个直线怎么求呢？最经典的算法就是： <strong>最小二乘法</strong>。<br>最小二乘法的思想就是：假设我们拟合出的直线代表数据的真实值，而观测到的数据代表拥有误差的值。为了尽可能减小误差的影响，需要求解一条直线使所有误差的平方和最小。也就是说 假设在一个 2维坐标上，有很多个点，我们划一条 直线，直线满足：坐标上所有的点到直线上的距离和最小。（注意，这个距离不是 过点在该直线上做垂线，而是 过该点 做一条与Y轴平行的线，形成的距离） 。 这样最小二乘法将最优问题转化为求函数极值问题。</p>
<p>怎么求这些 <strong>极值</strong> 呢？ 函数极值在数学上我们一般会采用求导数为0的方法。但这种做法并不适合计算机，可能求解不出来，也可能计算量太大。 这就要用到著名的“<strong>梯度下降</strong>”以及“<strong>牛顿法</strong>”来处理求解函数极值的问题。其中 <strong>梯度下降法</strong> 是解决回归模型中最简单且有效的方法之一。（从严格意义上来说，神经网络和推荐算法中都有线性回归的因子，因此梯度下降法在这些算法实现中也有应用。）</p>
<h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>逻辑回归是一种与线性回归非常类似的算法，区别是处理的问题不一致。线性回归处理的是<strong>数值问题</strong>，也就是最后预测出的结果是数字，例如房价。而逻辑回归属于 <strong>分类算法</strong>，也就是说，逻辑回归预测结果是离散的分类，例如判断这封邮件是否是垃圾邮件，以及用户是否会点击此广告等等。</p>
<p>具体实现上逻辑回归只是对对线性回归的计算结果加上了一个 <strong>Sigmoid函数</strong>。</p>
<p>Sigmoid函数就是：将数值结果转化为了0到1之间的概率(可以理解为：数值越大，函数越逼近1，数值越小，函数越逼近0)，然后根据这个概率可以做预测，例如概率大于0.5，则这封邮件就是垃圾邮件，或者肿瘤是否是恶性的等等。<br>从图像上来说，逻辑回归就是在平面上画出了一条分类线。</p>
<h2 id="神经网络-amp-SVM"><a href="#神经网络-amp-SVM" class="headerlink" title="神经网络 &amp; SVM"></a>神经网络 &amp; SVM</h2><p>逻辑回归算法划出的分类线基本都是 <strong>线性的</strong> (也有划出非线性分类线的逻辑回归，不过那样的模型在处理数据量较大的时候效率会很低)，这意味着当两类之间的界线不是线性时，逻辑回归的表达能力就不足。</p>
<p>一些强力所以发展出更加强大的算法来 <strong>拟合出复杂的非线性模型</strong>，用来反映一些不是直线所能表达的情况。这就是就是 神经网络 &amp; SVM 的 特点。</p>
<p>在 <strong>神经网络</strong> 中，每个处理单元事实上就是一个逻辑回归模型，逻辑回归模型接收上层的输入，把模型的预测结果作为输出传输到下一个层次。通过这样的过程，神经网络可以完成非常复杂的非线性分类。</p>
<p>在 <strong>SVM</strong> 中，通过跟高斯“<strong>核函数</strong>”的结合，支持向量机可以表达出非常复杂的分类界线，从而达成很好的的分类效果。<br>而 <strong>核函数</strong>，最典型的特征就是可以将低维的空间映射到高维的空间。例如：我们如何在二维平面划分出一个圆形的分类界线？在二维平面可能会很困难，但是通过“核”可以将二维空间映射到三维空间，然后使用一个线性平面就可以达成类似效果。也就是说，二维平面划分出的非线性分类界线可以等价于三维平面的线性分类界线。于是，我们可以通过在三维空间中进行简单的线性划分就可以达到在二维平面中的非线性划分效果。</p>
<p>但是SVM中要证明，即将数据从低维映射到高维不会带来最后计算复杂性的提升。只有满足这个条件，通过支持向量机算法，既可以保持计算效率，又可以获得非常好的分类效果。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> ML </tag>
            
            <tag> 回归 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[scrapy 安装及使用]]></title>
      <url>/2016/04/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-Scrapy%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下面是我的安装过程，有点坎坷，花了一个下午，，本人环境是OS X EI Capitan<br><a id="more"></a></p>
<h3 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h3><p>pip用来管理python的各种包，类似于Redhat的yum<br><code>sudo easy_install pip</code></p>
<h3 id="安装scrapy"><a href="#安装scrapy" class="headerlink" title="安装scrapy"></a>安装scrapy</h3><p><code>sudo pip install scrapy</code><br>报错如下，表明uninstall six出错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Found existing installation: six 1.4.1</span><br><span class="line">    DEPRECATION: Uninstalling a distutils installed project (six) has been deprecated and will be removed in a future version. This is due to the fact that uninstalling a distutils project will only partially uninstall the project.</span><br><span class="line">    Uninstalling six-1.4.1:</span><br><span class="line">Exception:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/pip/basecommand.py&quot;, line 209, in main</span><br><span class="line">    status = self.run(options, args)</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/pip/commands/install.py&quot;, line 317, in run</span><br><span class="line">    prefix=options.prefix_path,</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/pip/req/req_set.py&quot;, line 726, in install</span><br><span class="line">    requirement.uninstall(auto_confirm=True)</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/pip/req/req_install.py&quot;, line 746, in uninstall</span><br><span class="line">    paths_to_remove.remove(auto_confirm)</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/pip/req/req_uninstall.py&quot;, line 115, in remove</span><br><span class="line">    renames(path, new_path)</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/pip/utils/__init__.py&quot;, line 267, in renames</span><br><span class="line">    shutil.move(old, new)</span><br><span class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 302, in move</span><br><span class="line">    copy2(src, real_dst)</span><br><span class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 131, in copy2</span><br><span class="line">    copystat(src, dst)</span><br><span class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 103, in copystat</span><br><span class="line">    os.chflags(dst, st.st_flags)</span><br><span class="line">OSError: [Errno 1] Operation not permitted: &apos;/var/folders/zp/nmslxw4n5hjcrrjn76cfg76h0000gn/T/pip-Nj5qTp-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="安装six-1-10-0"><a href="#安装six-1-10-0" class="headerlink" title="安装six 1.10.0"></a>安装six 1.10.0</h3><p>上面的问题是需要安装six 1.10.0，目前机器环境是six 1.4.0，然后卸载six 1.4.0出错</p>
<p>six的官网地址如右：<a href="https://pypi.python.org/pypi/six/1.10.0#downloads" target="_blank" rel="noopener">https://pypi.python.org/pypi/six/1.10.0#downloads</a></p>
<p>下载包直接<code>python setup.py install</code>即可</p>
<h3 id="再次安装scrapy"><a href="#再次安装scrapy" class="headerlink" title="再次安装scrapy"></a>再次安装scrapy</h3><p>再次执行<code>sudo pip install scrapy</code>即可安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Successfully installed Twisted-15.4.0 characteristic-14.3.0 lxml-3.4.4 pyasn1-0.1.9 pyasn1-modules-0.0.8 scrapy-1.0.3 service-identity-14.0.0 w3lib-1.13.0</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> scrapy </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据挖掘的分类算法的优势及对比]]></title>
      <url>/2016/04/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/DM-%E6%80%BB%E7%BB%93-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9A%84%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<h2 id="朴素贝叶斯-Naive-Bayes-NB"><a href="#朴素贝叶斯-Naive-Bayes-NB" class="headerlink" title="朴素贝叶斯(Naive Bayes, NB)"></a>朴素贝叶斯(Naive Bayes, NB)</h2><p>超级的简洁。如果条件独立假设成立的话，NB将比鉴别模型（如Logistic回归）收敛的更快，所以你只需要少量的训练数据。即使条件独立假设不成立，NB在实际中仍然表现出惊人的好。特别是在文本处理中。适用于类似半监督学习，或者是既要模型简单又要性能好的地。<a id="more"></a></p>
<h2 id="Logistic回归-Logistic-Regression-LR"><a href="#Logistic回归-Logistic-Regression-LR" class="headerlink" title="Logistic回归(Logistic Regression, LR)"></a>Logistic回归(Logistic Regression, LR)</h2><p>LR有很多方法来对模型正则化。比起NB的条件独立性假设，LR不需要考虑样本是否是相关的。与决策树与支持向量机（SVM）不同，NB有很好的概率解释，且很容易利用新的训练数据来更新模型（在线梯度下降法）。<br>适用于：想要一些概率信息（如，为了更容易的调整分类阈值，得到分类的不确定性，得到置信区间），或者希望将来有更多数据时能方便的更新改进模型，LR是值得使用的。</p>
<h2 id="决策树（Decision-Tree-DT）-amp-随机森林（Random-Forest-RF）"><a href="#决策树（Decision-Tree-DT）-amp-随机森林（Random-Forest-RF）" class="headerlink" title="决策树（Decision Tree, DT）&amp; 随机森林（Random Forest, RF）"></a>决策树（Decision Tree, DT）&amp; 随机森林（Random Forest, RF）</h2><p>DT容易理解与解释。DT是非参数的，所以你不需要担心离群点和数据是否线性可分的问题。<br>DT的主要缺点是容易过拟合，这也正是随机森林（Random Forest, RF）（或者Boosted树）等集成学习算法被提出来的原因。此外，RF在很多分类问题中经常表现得最好（一般比SVM稍好），且速度快可扩展，也不像SVM那样需要调整大量的参数，所以最近RF是一个非常流行的算法。</p>
<h2 id="支持向量机（Support-Vector-Machine-SVM）"><a href="#支持向量机（Support-Vector-Machine-SVM）" class="headerlink" title="支持向量机（Support Vector Machine, SVM）"></a>支持向量机（Support Vector Machine, SVM）</h2><p>很高的分类正确率，对过拟合有很好的理论保证，选取合适的核函数，面对特征线性不可分的问题也可以表现得很好。<br>SVM适用于：在维数通常很高的文本分类（很流行）。<br>缺点：较大的内存需求和繁琐的调参，。</p>
<h2 id="根据训练集"><a href="#根据训练集" class="headerlink" title="根据训练集"></a>根据训练集</h2><p>对于小的训练集，高偏差/低方差的分类器（如朴素贝叶斯）比低偏差/高方差的分类器（如K近邻或Logistic回归）更有优势，因为后者容易过拟合。<br>对于大的训练集：，高偏差的分类器并不能训练出非常准确的模型，所以低偏差/高方差的分类器会静更合适（因为有更小的渐近误差）。</p>
]]></content>
      
        <categories>
            
            <category> 数据挖掘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> ML </tag>
            
            <tag> 分数算法 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> DM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python与java中的参数传递的理解]]></title>
      <url>/2016/04/%E5%BE%85%E6%95%B4%E7%90%86/Python-%E6%80%BB%E7%BB%93-python%E4%B8%8Ejava%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="按值传递VS按引用传递"><a href="#按值传递VS按引用传递" class="headerlink" title="按值传递VS按引用传递"></a>按值传递VS按引用传递</h3><ul>
<li>按值传递意味着当将一个参数传递给一个函数时，函数接收的是原始值的一个副本</li>
<li>按引用传递意味着当将一个参数传递给一个函数时，函数接收的是原始值的内存地址，而不是值的副本<a id="more"></a>
</li>
</ul>
<h3 id="python-传值和传引用"><a href="#python-传值和传引用" class="headerlink" title="python 传值和传引用"></a>python 传值和传引用</h3><p>和其他语言不一样，传递参数的时候，python不允许程序员选择采用传值还是传引用。<br>Python参数传递采用的是“传对象引用”的方式。<br>实际上，这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值“来传递对象。<br>python一般内部赋值变量的话，都是传个引用变量，和C语言的传地址的概念差不多。可以用id()来查询内存地址</p>
<p>易错：<br>对于list 如果a=b的话， a和b的地址是相同的；如果只是想拷贝，那么就得用 a=b[:]。</p>
<h3 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h3><p>在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。</p>
<h3 id="java中的传值和传引用"><a href="#java中的传值和传引用" class="headerlink" title="java中的传值和传引用"></a>java中的传值和传引用</h3><blockquote>
<p>O’Reilly’s Java in a Nutshell by David Flanagan (see Resources) puts it best: “Java manipulates objects ‘by reference,’ but it passes object references to methods ‘by value.’”</p>
</blockquote>
<p>Java 应用程序有且仅有的一种参数传递机制，即 <strong>按值传递</strong>。 但是对象在java中是一个引用 （理解为指针），它的值就是一个内存地址，所以可以如下理解：</p>
<ul>
<li><strong>基本类型</strong> 作为参数传递时，是传递值的拷贝，无论你怎么改变这个拷贝，原值是不会改变的。</li>
<li><strong>对象</strong> 作为参数传递时，是把对象在内存中的地址拷贝了一份传给了参数。(可以理解为引用传递)</li>
<li><strong>String等immutable类型</strong> 因为没有提供自身修改的函数，每次操作都是新生成一个对象，所以要特殊对待。可以认为是传值。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 总结 </tag>
            
            <tag> Python </tag>
            
            <tag> 参数传递 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习中常用计算的实现]]></title>
      <url>/2016/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ML-%E6%80%BB%E7%BB%93-%E5%B8%B8%E7%94%A8%E8%AE%A1%E7%AE%97%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>摘要无<a id="more"></a></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>2016-04-08 统计出现次数&amp;文件的矩阵处理</p>
<h2 id="统计出现次数"><a href="#统计出现次数" class="headerlink" title="统计出现次数"></a>统计出现次数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#统计标签出现次数</span></span><br><span class="line">   labelCounts = &#123;&#125; <span class="comment"># 用来保存标签的出现次数的dict ，标签为key</span></span><br><span class="line">   <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet :</span><br><span class="line">       currentLabel = featVec[<span class="number">-1</span>] <span class="comment"># 获得标签</span></span><br><span class="line">       <span class="comment">#！！！这一步很重，对一个没有定义的变量 += 1 ，系统无法接受！！！</span></span><br><span class="line">       <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys(): <span class="comment"># 如果当前标签没有被统计过</span></span><br><span class="line">           labelCounts[currentLabel] = <span class="number">0</span> <span class="comment"># 刚兴建一个标签、</span></span><br><span class="line">       labelCounts[currentLabel] += <span class="number">1</span> <span class="comment">#标签出现一次，次数就加一</span></span><br><span class="line">    <span class="comment">#按标签出现次数，从最大到最小排序</span></span><br><span class="line">   sortedClassCount = sorted (classsCount.items(), key = operator.itemgetter(<span class="number">1</span>), reverse = <span class="keyword">True</span>)</span><br><span class="line">   <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="文件的矩阵处理"><a href="#文件的矩阵处理" class="headerlink" title="文件的矩阵处理"></a>文件的矩阵处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除开头结尾处的空白符</span></span><br><span class="line"><span class="comment"># 分割</span></span><br><span class="line"><span class="comment"># 保存在一个list</span></span><br><span class="line">fr = open(filename)</span><br><span class="line">Lenses = [inst.strip().split(<span class="string">'\t'</span>) <span class="keyword">for</span> inst <span class="keyword">in</span> fr.readlines()]</span><br></pre></td></tr></table></figure>
<h2 id="计算整个数据集的质心"><a href="#计算整个数据集的质心" class="headerlink" title="计算整个数据集的质心"></a>计算整个数据集的质心</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">centroid0 = mean(DataSet, axis=<span class="number">0</span>).tolist()[<span class="number">0</span>] <span class="comment"># 计算整个数据集的质心</span></span><br></pre></td></tr></table></figure>
<p>这个计算的分解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; cent = numpy.mean(d,axis =0)</span><br><span class="line">&gt;&gt;&gt; cent</span><br><span class="line">matrix([[-0.10361321,  0.0543012 ]])</span><br><span class="line">&gt;&gt;&gt; cent1 = cent.tolist()</span><br><span class="line">&gt;&gt;&gt; cent1</span><br><span class="line">[[-0.10361321250000004, 0.05430119999999998]]</span><br><span class="line">&gt;&gt;&gt; cent2 = cent1[0]</span><br><span class="line">&gt;&gt;&gt; cent2</span><br><span class="line">[-0.10361321250000004, 0.05430119999999998]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> ML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python3中内置dict类型key的返回值的变化]]></title>
      <url>/2016/04/%E5%BE%85%E6%95%B4%E7%90%86/Python-%E6%80%BB%E7%BB%93-Python3%E4%B8%AD%E6%96%B0%E7%89%B9%E6%80%A7-dict%E7%9A%84keys()/</url>
      <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><a id="more"></a>
<h3 id="python3中keys-的返回值"><a href="#python3中keys-的返回值" class="headerlink" title="python3中keys()的返回值"></a>python3中keys()的返回值</h3><p>python2中<code>keys()</code>的返回的是一个值的列表<br>python3中<code>keys()</code>的返回的是一个对象，而不是值的列表。可以像 set 对象那样测试某个元素的成员资格，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = T.keys()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">dict_keys([<span class="string">'no surfacing'</span>])</span><br></pre></td></tr></table></figure></p>
<p>不过，如果您的确想要得到值的列表，可以对所返回的 dict 对象进行<strong>强制类型转换</strong>。比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;keys = list(d.keys())</span><br><span class="line">&gt;&gt;&gt;print(keys)</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p>
<p>易错：<br>python2中的，这个就不能直接用了<br><code>firstStr = dict.keys()[0]</code></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> Python3 </tag>
            
            <tag> 区别 </tag>
            
            <tag> items </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python3字典中items()和python2.x中iteritems()有什么区别]]></title>
      <url>/2016/04/%E5%BE%85%E6%95%B4%E7%90%86/Python-%E6%80%BB%E7%BB%93-Python3%E4%B8%AD%E6%96%B0%E7%89%B9%E6%80%A7-dict%E7%9A%84items()/</url>
      <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><a id="more"></a>
<h2 id="iteritems-amp-items"><a href="#iteritems-amp-items" class="headerlink" title="iteritems()&amp;items()"></a>iteritems()&amp;items()</h2><h3 id="Python2-x中："><a href="#Python2-x中：" class="headerlink" title="Python2.x中："></a>Python2.x中：</h3><p><code>items( )</code>Returns a copy of the list of all items (key/value pairs) in D(用于返回一个字典的拷贝列表)，占额外的内存。<br><code>iteritems()</code>【Returns an iterator on all items(key/value pairs) in D(用于返回本身字典列表操作后的迭代)，不占用额外的内存。</p>
<h3 id="Python-3-x-："><a href="#Python-3-x-：" class="headerlink" title="Python 3.x ："></a>Python 3.x ：</h3><p><code>iteritems()</code>和 <code>viewitems()</code> 这两个方法都已经废除了!<br><code>items()</code>  Return a new view of the dictionary’s items ((key, value) pairs).</p>
<blockquote>
<p>The objects returned by dict.keys(), dict.values() and dict.items() are view objects. They provide a dynamic view on the dictionary’s entries, which means <strong>that when the dictionary changes, the view reflects these changes</strong>.</p>
</blockquote>
<p><code>items()</code> 得到的结果是和 2.x 里面<code>viewitems()</code>一致的。<br>用 <code>items()</code>替换<code>iteritems()</code> ，可以用于 for 来循环遍历。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> Python3 </tag>
            
            <tag> 区别 </tag>
            
            <tag> items </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[转载-The Hadoop Distributed File System(译）]]></title>
      <url>/2016/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/Hadoop-%E8%BD%AC%E8%BD%BD-The%20Hadoop%20Distributed%20File%20System/</url>
      <content type="html"><![CDATA[<p>作者：Konstantin Shvachko, Hairong Kuang etc. 2010-10<br>原文：<a href="http://storageconference.org/2010/Papers/MSST/Shvachko.pdf" target="_blank" rel="noopener">http://storageconference.org/2010/Papers/MSST/Shvachko.pdf</a><br>原文：<a href="http://www.aosabook.org/en/hdfs.html" target="_blank" rel="noopener">http://www.aosabook.org/en/hdfs.html</a><br>译者：phylips@bmy 2011-9-12<br>译文：<a href="http://duanple.blog.163.com/blog/static/70971767201181744412133/" target="_blank" rel="noopener">http://duanple.blog.163.com/blog/static/70971767201181744412133/</a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Hadoop分布式文件系统(HDFS)设计用于为大规模数据集提供可靠性的存储，同时能够将数据集以高带宽的传输速率推送给用户应用程序。在一个大规模集群上，将会有数千台的服务器同时负责数据存储及执行用户应用级的计算任务。通过将存储和计算分布到很多个服务器上，使得存储和计算资源可以在保持低成本的情况下根据数据规模按需增长。在本文中，我们会描述下HDFS的架构，以及我们在Yahoo!使用HDFS来管理25PB的企业数据的相关经验。<a id="more"></a></p>
<h2 id="简介及相关工作"><a href="#简介及相关工作" class="headerlink" title="简介及相关工作"></a>简介及相关工作</h2><p>Hadoop提供了一个分布式文件系统及一个使用MapReduce范式进行大规模数据集分析和转换的框架。Hadoop的一个重要特点是，将数据和计算划分在很多(数千台)主机上，同时直接在这些数据附近并行执行计算应用{!即存储数据的跟执行计算的是同一个节点集合，这就可以很容易地将计算移动到数据附近执行}。一个Hadoop集群可以简单地通过增加服务器来对计算能力、存储能力及IO带宽进行扩展。Yahoo!的Hadoop集群目前已包含25000台服务器，存储了25PB的应用数据，最大的集群目前包含3500台服务器。目前世界上已有上百个组织宣布他们采用了Hadoop。</p>
<p>Hadoop是一个Apache项目；所有的组件都遵循Apache开源许可证。在Hadoop核心组件(HDFS和MapReduce)中，其中80%都是由Yahoo!开发和贡献的。HBase最初是在Powerset开发的，现在它已经是微软的一个部门。Hive最初由Facebook开发。Pig，ZooKeeper，及Chukwa都是由Yahoo!发起并开发的。Avro也是源自Yahoo!，目前Cloudera也在参与它的开发。</p>
<p>HDFS是Hadoop的文件系统组件。它的接口类似于Unix文件系统，但是为了提高应用程序性能，它并没有严格遵从标准。</p>
<p>HDFS将文件系统元数据和应用程序数据分开存储。像其他的一些分布式系统比如PVFS，Lustre及GFS一样，HDFS将元数据存放在一个被称作NameNode的专门的服务器上。应用数据则被存储在称作DataNode的其他服务器上。所有的服务器都是相通的，相互之间通过基于TCP的协议进行通信。</p>
<p>与PVFS和Lustre不同，HDFS的DataNodes没有使用像ACID这样的数据保护机制来保证数据的持久性。而是像GFS那样，通过将文件内容复制到多个DataNodes上来保证可靠性。在保证数据持久性的同时，这种方式也带来了一些额外的好处，比如数据传输带宽变成了原来的几倍，同时提高了将计算移动到数据附近的可能性(locality)。</p>
<p>一些分布式文件系统目前也在探索一些名字空间的真正的分布式实现方式。比如Ceph使用一个具有多个名字空间服务器(MDS-MetaDataServer)的集群，同时使用一个动态的子树划分算法来将名字空间树均匀地映射到MDSs上。GFS也已经演化成一个分布式名字空间的实现。新一代的GFS将会具有数百个名字空间服务器(masters)，其中的每个都能管理100 million的文件。Lustre在2.2版中，已经具有一个集群化的名字空间实现。目的就是为了将一个目录划分到多个元数据服务器(MDS)，让每个服务器负责名字空间的一部分。文件会通过对文件名称使用一个hash函数来分配到特定的MDS上。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h3><p>HDFS名字空间是一个由文件和目录组成的层次性结构。在NameNode上，文件和目录通过inode标识，每个inode会记录像访问权限、修改信息、访问时间、名字空间及磁盘空间qutas这样的一些属性。文件内容会被切分成很多大的blocks(通常是128MB，用户可以为每个文件设定自己的block大小)同时组成文件的每个block会被复制到多个DataNodes上(通常是3，用户也可以为每个文件设定自己的副本数)。NameNode维护一个名字空间树及文件blocks到DataNodes的映射信息(即文件数据的物理位置)。当HDFS Client想读取文件时，必须与NameNode联系以获取组成该文件的blocks的位置信息，然后选择一个离它最近的DataNode去读取block内容。在写数据时，client向NameNode发送请求，让它指定应该由哪三个DataNodes来保存该block的三个副本。之后客户端就会以pipeline的模式将数据写入到DataNodes。当前的设计中，每个集群中只有一个NameNode。但是每个集群可以有数千个DataNodes及数万个HDFS clients，因为每个DataNode可能会同时执行多个应用程序任务{!所以HDFS clients的数目可能比DataNodes多个数量级}。</p>
<p>HDFS会将整个名字空间保存在内存中。由inode数据及每个文件包含的所有blocks列表组成的名字系统元数据叫做image。保存在本机本地文件系统中的该image的一个持久化记录称为一个checkpoint。NameNode也会将称为journal的针对该image的修改日志保存到本机本地文件系统中。为了提高持久性，可以在其他服务器上保存checkpoint和journal的多个副本。在重启的时候，NameNode会通过读取名字空间checkpoint及重放journal来恢复名字空间。Block副本位置信息可能会随着时间而改变，同时它们也不是持久化的checkpoint的组成部分。</p>
<h3 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h3><p>DataNode中的每个block副本由本机本地文件系统中的两个文件组成。第一个文件包含数据本身，第二个文件是该block的元数据包括该block数据的校验和及该block的世代戳(generation stamp)。数据文件大小等于该block的实际长度，同时不需要补上额外的空间以达到标准的块大小{!比如该block只有10MB，那么本地文件系统中的数据文件大小就是10MB，而无需在额外补足让它变成标准的128MB}。因此，如果一个block只有标准大小的一半，那么本地磁盘也只需要半个标准block所需的空间。</p>
<p>在每个DataNode启动时，它会连接到NameNode执行一个握手。握手的目的是为了验证名字空间ID及DataNode的软件版本。如果其中只要有一个无法与NameNode匹配，那么DataNode会自动关闭。</p>
<p>名字空间ID是在文件系统创建时分配给它的实例编号。名字空间ID会持久化存储在集群的所有节点中。具有不同名字空间ID的节点无法加入到集群中，这就保护了文件系统的数据完整性。</p>
<p>软件版本的一致性是非常重要的，因为不兼容的版本可能会导致数据损坏或丢失，同时在一个具有数千个节点的大规模集群上，很容易会在升级期间忽略掉某些节点，比如它没有在升级之前正确的关闭或者在升级时处于不可用的状态。</p>
<p>允许一个新初始化的并且没有任何名字空间ID的DataNode加入到集群中，它会接受集群的名字空间ID。{!这是因为很多情况下我们需要对集群进行扩容，因此HDFS应该允许我们往集群中添加新机器}</p>
<p>在握手过程完成之后，DataNode会与NameNode进行注册。DataNodes会持久化存储它们自己对应的那个唯一的存储ID。存储ID是DataNode的内部标识符，可以保证即使是它更换了IP地址或者端口也能识别出来。存储ID是在DataNode第一次向NameNode进行注册时分配的，之后它就再也不会改变。</p>
<p>DataNode会通过向NameNode发送一个block report来声明它所拥有的block副本。一个block report包含该block的id，世代戳(generation stamp)以及它所持有的block副本长度。当DataNode注册完成之后就会立即发送第一次的block report。之后，会每隔1小时就进行一次block reports发送，从而为NameNode提供关于该集群内的所有block副本的最新位置信息。</p>
<p>在正常情况下，DataNode会向NameNode发送心跳信息以证实它自己正在运行以及它所持有的block副本是可用的。默认的心跳周期是3秒钟。如果NameNode在十分钟内收不到来自某个DataNode的心跳信息，它会认为该DataNode已经不能提供服务，它所持有的block副本就变成了不可用状态。NameNode就会将这些block副本在其他DataNode上创建出来。</p>
<p>来自DataNode的心跳中还会携带一些关于总的存储容量、存储空间使用量及当前正在处理的数据传输量方面的信息。这些统计信息会被用于NameNode的空间分配及负载平衡决定中。</p>
<p>NameNode不会直接联系DataNode，它会通过对心跳的响应信息来向DataNodes发送指令。这些指令包括如下一些命令：</p>
<ul>
<li>复制blocks到其他节点</li>
<li>删除本地的block副本</li>
<li>重新注册或者关闭节点</li>
<li>发送一个即时block report</li>
</ul>
<p>这些命令对于维护整个系统的完整性是十分重要的，因此就算是在大规模的集群中，保持心跳的通畅也是非常重要的。NameNode每秒可以处理数千个心跳请求而不会影响到其他的NameNode操作。</p>
<h3 id="HDFS-Client"><a href="#HDFS-Client" class="headerlink" title="HDFS Client"></a>HDFS Client</h3><p>用户应用程序通过HDFS Client(一个包含HDFS文件系统接口的代码库)来访问文件系统。</p>
<p>类似于大部分的传统文件系统，HDFS支持文件的读写和删除操作，以及针对目录的创建和删除操作。用户通过名字空间里的路径来访问文件和目录。用户应用程序通常并不需要知道文件系统元数据和数据存储是位于不同的服务器上的，或者是一个block是有多个副本的。</p>
<p>当一个应用程序读取一个文件时，HDFS client首先向NameNode询问持有组成该文件的blocks的DataNodes列表。然后直接联系某个DataNode请求对于它所需要的block的传输。当client进行写的时候，它会首先让NameNode选定持有该文件的第一个block的那些DataNodes。客户端会把这些节点组织成一个pipeline，然后发送数据。当第一个block写出后，客户端会继续请求选定持有下一个block的新的DataNodes。新的pipeline会被建立起来，客户端开始发送该文件后面的那些数据。每次选定的DataNodes可能是不同的。NameNode和DataNodes与客户端的交互如图1所示。</p>
<p>与传统文件系统不同，HDFS提供了一个API用于提供某个文件的blocks的位置信息。这就允许应用程序比如MapReduce框架可以将task调度到数据所在的节点上，这就提高了读性能。同时它也允许应用程序对文件的副本数进行设置。默认情况下，文件的副本数是3。对于某些重要文件或者是某些经常被访问的文件，可以增大该参数值以提高容错性及读取带宽。</p>
<h3 id="Image与Journal"><a href="#Image与Journal" class="headerlink" title="Image与Journal"></a>Image与Journal</h3><p>名字空间image是代表应用数据的目录和文件组织方式的文件系统元数据。写入到磁盘中的image的持久化记录称为checkpoint{!image在内存中，checkpoint则是在磁盘中}。Journal是一个记录了那些必须被持久化的文件系统变更的write-ahead commit日志。对于每个客户端发起的事务，变更会被记录到journal中，在变更提交给HDFS客户端之前journal文件必须被flush及sync。checkpoint文件永远不会被NameNode修改；当在重启时创建好新的checkpoint时，或者在管理员或下一节描述的CheckpointNode发出请求时，它会被整个替换掉。在NameNode启动时，会根据checkpoint初始化名字空间image，然后重放journal中的变更直到image更新到文件系统的最终状态。在NameNode提供服务之前，一个新的checkpoint和空的journal会被写回到存储目录下。</p>
<p>如果checkpoint或者是journal丢失或者损坏了，名字空间信息将会部分地或者整个地丢失。为了对关键信息进行保护，可以将HDFS配置成将checkpoint和journal在多个存储目录下存放。推荐性的做法是将这些目录放在不同的逻辑卷上，或者是在远程NFS服务器上的某个存储目录下。第一种做法可以防止单个逻辑卷的损坏造成数据丢失，第二种做法可以应付整个节点失败的情况。如果NameNode在将journal写入到某个存储目录下的过程中出错，那么它会自动地将该目录从存储目录列表中排除。如果没有存储目录可用，NameNode会自动地停止运行。</p>
<p>NameNode是一个多线程系统，可以同时处理来自多个客户端的请求。将事务日志保存到磁盘就成了系统的瓶颈，因为所有的线程都必须等到其中某个线程发起的flush-and-sync调用结束。为了优化该处理过程，NameNode会将由不同客户端产生的多个事务批量进行处理。当其中某个NameNode线程发起flush-and-sync调用时，堆积在此刻的所有事务会一块进行提交。其他线程只需要检查下它们的事务是否被写入了而不需要再发起一个flush-and-sync调用。</p>
<h3 id="CheckpointNode"><a href="#CheckpointNode" class="headerlink" title="CheckpointNode"></a>CheckpointNode</h3><p>HDFS中的NameNode，除了可以担任客户端请求服务者这一首要角色外，还可以担任其他的一些角色比如CheckpointNode或者是BackupNode。节点可以在启动时设置它的角色。</p>
<p>CheckpointNode会周期性地合并现有的checkpoint和journal，创建一个新的checkpoint和一个空的journal。CheckpointNode通常运行在与NameNode不同的一个节点上，因为它需要与NameNode等同的内存空间。它会从NameNode下载当前的checkpoint和journal文件，然后在本地对它们进行合并，然后将新的checkpoint返回给NameNode。</p>
<p>创建周期性的checkpoints是保护文件系统元数据的一种方式。如果名字空间image的所有持久化拷贝或者journal不可用了，系统就可以从最近的那个checkpoint处恢复。</p>
<p>当新的checkpoint上传到NameNode后，checkpoint的创建需要NameNode在journal的尾部进行截断{!即此时若要创建checkpoint应该截断当前journal，而新的修改日志应该写入到新的journal中，当前的journal会跟旧的checkpoint一起用于新checkpoint的创建}。HDFS集群如果长期运行而不重启的话，那么在此期间journal会持续增长。如果journal变得很大的话，那么journal文件发生数据丢失或损坏的概率就会上升。同时，一个很大的journal文件也会增加NameNode重启所需的时间。对于一个大规模的集群来说，可能会花一个小时来处理一个已存在一周的journal。因此最好每天都进行checkpoint的创建。</p>
<h3 id="BackupNode"><a href="#BackupNode" class="headerlink" title="BackupNode"></a>BackupNode</h3><p>BackupNode是HDFS最近引入的一个feature。与CheckpointNode类似，BackupNode能够创建周期性的checkpoints，但是除此之外它还在内存中维护了一个文件系统名字空间的最新映像，该映像会一直与NameNode状态保持同步。</p>
<p>BackupNode会接受来自处于活动状态的那个NameNode的名字空间事务形成的journal流，它会将它们存放到自己的存储目录下，同时将这些事务应用到它自己的内存映像中。NameNode会像对待存储它的journal文件的存储目录那样，将BackupNode作为它的一个journal存储目标。如果NameNode出错了，那么BackupNode的内存映像以及磁盘上checkpoint都记录了最新的名字空间状态{!即BackupNode的内存映像已经是最新的名字空间，checkpoint+journal也可以用来恢复名字空间状态}。</p>
<p>BackupNode可以不用从处于活动状态的NameNode下载checkpoint和journal文件就能创建一个checkpoint，因为它的内存中已经具有了最新的名字空间状态。这使得在BackupNode上的checkpoint处理更高效，因为它只需要将名字空间保存到本地的存储目录下。</p>
<p>BackupNode可以看做是一个只读的NameNode。它包含除block位置信息之外的所有文件系统元数据信息。除去那些会引入名字空间改变或者是需要了解block位置信息的操作之外，它也可以执行其他所有的常规NameNode操作。通过将名字空间状态的持久化授权让BackupNode处理，这样BackupNode的使用就提供一种不需要持久化存储及名字空间授权的NameNode运行选择{!即NameNode运行时可以自己不进行持久化存储了，而让BackupNode来负责，这就降低了NameNode的负载}。</p>
<h3 id="升级，文件系统快照"><a href="#升级，文件系统快照" class="headerlink" title="升级，文件系统快照"></a>升级，文件系统快照</h3><p>在软件升级期间，由软件bug或者人为失误导致的系统崩溃概率会上升。在HDFS中创建快照的目的是为了最小化系统升级期间对存储的数据的潜在威胁。</p>
<p>快照机制使得管理员可以将文件系统的当前状态进行持久化保存，这样如果升级导致数据损坏或丢失时，可以对升级进行回滚，使得HDFS回到快照创建时的名字空间和存储状态。</p>
<p>快照(只能有一个)可以通过集群管理员配置进行创建，而不管系统是何时启动的。当接受到快照请求后，NameNode会首先读取checkpoint和journal文件，然后在内存中合并它们。然后，它会写出一个新的checkpoint及空的journal到一个新的位置，这样旧的checkpoint和journal文件就仍然是保持不变的。</p>
<p>在握手期间，NameNode会向DataNodes发出一个创建本地快照的命令。本地快照不能通过简单地对目录下文件进行复制来实现，因为这会导致集群中所有DataNodes节点的存储空间加倍。每个DataNodes不是真正创建存储目录的一份拷贝，而是为现有的block文件创建出硬链接到存储目录下。当DataNodes删除一个block时，它只是删除了这个硬链接，当append操作导致block内容改变时会采用copy-on-write技术。因此老的目录中的老的block文件依然是处于未改变的状态。</p>
<p>集群管理员可以在重启系统时选择让HDFS回滚到快照状态。NameNode会使用快照创建时保存的那个checkpoint进行恢复。DataNodes会恢复之前被重命名的目录，同时启动一个后台线程去删除在快照之后创建的block副本。一旦选择了回滚，就不能在退回到之前的状态了。集群管理员也可以通过命令系统丢弃快照来释放由快照所占用的空间，然后完成软件升级。</p>
<p>系统的演化可能会导致NameNode的checkpoint和journal文件格式或者是DataNodes上的block副本文件的数据表示方式发生变化。Layout version会被用来标识数据表示格式，它会被持久化地保存到NameNode和DataNodes的存储目录中。在启动时，每个节点都会将当前软件的Layout version与存储在存储目录下的版本进行比较，并自动地将数据从旧的格式转换为新的。当系统使用新的Layout version重启时，该转换会强制性地创建一个快照。{!升级分很多种，对于普通的升级，可以让管理员手动选择是否开启snapshot，但是对于这种涉及到Layout version变更的情况，系统会强制性的进行snapshot}</p>
<p>HDFS并没有区分是NameNode还是DataNodes的Layout versions{!也就是说无论是NameNode还是DataNodes发生了Layout versions的改变，系统都会认为发生了改变，而进行相同的处理}，因为snapshot的创建是整个集群层面的事情而不是单个节点级的事件。如果升级后的NameNode因为一个软件bug而清除了它的image，那么如果只是备份了名字空间状态仍然会导致所有数据的丢失，因为NameNode无法识别DataNodes报告的blocks，就会发出一个删除命令。在这种情况下回滚虽然恢复了元数据，但是数据本身还是丢失了。</p>
<h2 id="文件IO操作及Replica管理"><a href="#文件IO操作及Replica管理" class="headerlink" title="文件IO操作及Replica管理"></a>文件IO操作及Replica管理</h2><h3 id="文件读操作与写操作"><a href="#文件读操作与写操作" class="headerlink" title="文件读操作与写操作"></a>文件读操作与写操作</h3><p>应用程序会通过创建新文件然后向文件写入数据来向HDFS添加数据。在文件关闭之后，已写入的字节串就不能被改变或删除，但是可以通过重新打开该文件通过append操作为该文件增加新数据。HDFS实现了一个单写者，多读者模型。</p>
<p>HDFS客户端打开一个文件用于写操作时会被授予该文件的租约；这样其他的客户端就不能再对该文件进行写入。正在进行写入的那个客户端会通过向NameNode发送的心跳信息周期性的更新该租约。当该文件被关闭时，租约就会被释放。租约持续时间通过一个soft limit和hard limt进行限定。在soft limit过期之前，写者肯定会独占针对该文件的访问。如果soft limit过期了，而客户端没有成功的关闭该文件或者更新该租约，另一个客户端将会优先获取到该租约。如果hard limt过期(1小时)，同时客户端仍未能成功更新该租约，HDFS会假设该客户端退出了同时会代替该写者自动地关闭该文件，然后释放该租约。写者租约不会阻止其他客户端读取该文件；一个文件可能具有多个并发读者。</p>
<p>一个HDFS文件是由多个blocks组成。当存在一个新block请求时，NameNode会分配一个具有唯一block ID的block，然后确定用于保存该块的多个副本的DataNodes列表。DataNodes会组成一个pipeline，它们的排列顺序会尽量的最小化从客户端到最后一个DataNode的总的网络距离。然后数据会以一系列的packets的形式推送到该pipeline中。应用程序写入的数据会首先缓存在客户端的一个packet缓存中。当一个packet buffer被填满(默认是64KB大小)时，数据就会被推送到pipeline。在收到前面的packets的确认信息之前，下一个packet就可以被直接推送到pipeline中。处于outstanding状态的packets数目是通过客户端的一个发送窗口大小限制的。</p>
<p>在数据写入到HDFS文件之后，在文件关闭之前，HDFS不提供任何保证以确保新的读者可以看到该数据。如果一个用户应用程序需要这种可见性保证，它可以显式地调用hflush操作。这样当前的packet会被立即推送到pipeline中，而hflush操作会等待直到收到来自pipeline中的DataNodes关于该包成功传输的确认为止。这样在hflush操作之前写入的所有数据对于读取者来说就肯定是可见的了。</p>
<p>如果没有错误发生，块的构建就会经过像图2那样的三个阶段。图2展示了一个具有三个DataNodes的流水线及5个pakctes的block。图中，粗线代表了数据包，虚线代表了确认消息，细线代表了用于建立和关闭流水线的控制消息。竖线代表了客户端及3个DataNodes的活动，时间流向是自上而下的。从t0到t1是流水线建立阶段，t1到t2是数据流阶段，t1代表了第一个数据包被发送的时间点，t2代表了针对最后一个数据包的确认信息的接收时间点。在这里，在第二个包传输时有一个hflush操作。hflush操作标识是与数据打包在一块的，而不是独立的一个操作。最后，t2到t3是针对该block的pipeline关闭阶段。</p>
<p>在一个具有数千个节点的集群中，节点失败(通常都是存储系统错误)每天都会发生。因此存储在某个DataNode上的副本可能会因为一个内存，磁盘或网络问题而损坏。HDFS会生成并存储针对HDFS文件中每个block的校验和。校验和在HDFS客户端读取时会进行验证，以检测因客户端，DataNodes或者是网络导致的损坏。当客户端创建一个HDFS文件时，它会为每个block计算校验和，然后将它与实际数据一块发送给DataNodes。DataNode会将校验和存储在与块数据文件独立的一个元数据文件中。在HDFS读取一个文件时，每个block的数据和校验和会被传送给客户端。客户端会对接受到的数据计算校验和，并验证它实时计算出的校验和与收到的校验和是否匹配。如果不匹配，客户端会告知NameNode该副本损坏了，之后会从另一个DataNode上获取该block的另一份副本。</p>
<p>当客户端打开文件进行读操作时，它会从NameNode获取一个blocks列表，及关于每个block副本的位置信息。每个block的位置信息会根据它们与客户端的距离进行排序。在读取block的内容时，客户端会首先尝试从最近的那个副本处进行读取。如果这个读取尝试失败了，客户端会继续尝试从序列中的下一个副本处读取。在目标DataNode不可用的情况下读取可能会失败，比如该DataNode可能不再持有该block的副本了，或者在检查校验和时发现副本是损坏的。</p>
<p>HDFS允许客户端去读取一个已打开的正在用于写操作的文件。在读取正在被写入的文件时，最后一个block因为正在被写入因此对于NameNode它的实际大小是未知的。在这种情况下，客户端在开始读取内容前可以询问其中某个副本得到其最新的长度。</p>
<p>HDFS的IO设计是为像MapReduce这样需要高顺序读写吞吐率的批处理系统特殊优化过。但是，为了支持像Scribe这种实时地向HDFS进行数据流导入，或者是像HBase这种提供对大表格的随机实时性访问的这些应用，还需要花费很大的精力来提高HDFS的读写响应时间。</p>
<h3 id="Block放置"><a href="#Block放置" class="headerlink" title="Block放置"></a>Block放置</h3><p>对于一个大规模集群来说，对所有的节点采用一种平摊的拓扑连接方式可能是不切实际的。通常的做法是将它们分布到多个机柜中。单个机柜中的节点共享一个交换机，机柜之间通过一个或多个核心交换机相连。这样在不同机柜中的节点间的通信需要跨越多个交换机。大多数情况下，相同机柜内节点间的网络带宽要比不同机柜的节点间的网络带宽要高。图3描述了一个具有2个机柜的集群，每个机柜包含三个节点。</p>
<p>HDFS会根据两个节点间的距离来估算它们的网络带宽。假设从节点到它的父节点间的距离是1。那么任意两个节点的距离就可以通过将它们到它们的最近公共祖先间的距离求和而得到。距离越短意味着可以用于数据传输的带宽越大。</p>
<p>HDFS允许管理员安装一个脚本，给定一个节点地址该脚本就可以返回该节点所在的机柜信息。NameNode会负责解析各个DataNode的机柜位置。当DataNode向NameNode注册时，NameNode会运行该脚本来确定该DataNode属于哪个机柜。如果该脚本没有安装，NameNode会假设所有DataNode都属于默认的同一个机柜中。</p>
<p>副本的放置对于HDFS的数据可靠性和读写性能都是至关重要的。一个好的副本放置策略可以提高数据可靠性，可用性及网络带宽利用率。当前的HDFS提供一个可配置的块放置策略接口，这样用户和研究人员就可以进行实验测试以为他们的应用选择更好的放置策略。</p>
<p>默认的HDFS block放置策略在最小化写开销和最大化数据可靠性、可用性以及总体读取带宽之间进行了一些折中。当一个新的block创建时，HDFS会将第一个副本放置在writer本身所在的那个节点上，第二个和第三个副本将会被放到另一个机柜的两个不同节点上，再剩下的就会被随机地放置，但需要保证如下几个条件：一个节点上最多只能放一个副本；如果副本数小于机柜数的2倍，那么同一个机柜上最多能放两个副本。我们选择将第二个和第三个副本放到另一个机柜上可以更好的将blocks分布到集群上。如果前两个副本被放置在相同的机柜上，那么对于任意文件来说，那么它的三分之二的blocks副本都会被放到相同的机柜上{!因为第一个副本已经定了，会被放到writer本身所在的那个节点，那么根据这种策略第二个副本也会放到上面，与此同时因为writer一直处在该节点上，那么其他block也会被这样放置，最后就会导致该文件至少有三分之二的blocks副本会被放到writer本身所在的那个节点上}。</p>
<p>当所有的目标节点选定之后，这些节点会以它们与第一个副本的接近程度为序组织成一个流水线的形式。对于读取来说，NameNode会首先判断客户端所在主机是否在集群中，如果是的话，block的位置信息会以它们与该客户端的接近程度为序返回给客户端。Block从DataNodes中读取时就会参照这个顺序。(这对于那些直接运行在集群内部节点上MapReduce很有用，当然了实际上一个主机只要可以连接到NameNode和DataNodes，就可以在它上面运行HDFS client)</p>
<p>这种策略降低了机柜间及节点间的写流量，提高了写性能。由于单个机柜的失败概率要远低于单个节点的失败概率，这种策略也不会影响数据可靠性和可用性。在三个副本的情况下，它也能降低读取时地总的网络带宽，因为一个block仅被放在两个机柜而不是三个上。</p>
<p>默认的HDFS副本放置策略可以概述如下：</p>
<ol>
<li>每个DataNode最多包含block的一个副本</li>
<li>在集群具有足够的机柜的情况下，每个机柜最多包含同一个block的两个副本</li>
</ol>
<h3 id="Replication管理"><a href="#Replication管理" class="headerlink" title="Replication管理"></a>Replication管理</h3><p>NameNode会尽量保证每个block总是具有期望的副本数。当来自DataNode的block report到达时，NameNode会检测到那些副本数过少(under- replicated)或过多(over-replicated)的block。当一个block的副本数过多，NameNode会选择一个副本进行删除。NameNode首先会尽量不减少持有该副本的机柜数，其次会倾向于从那个具有最少的可用磁盘空间的DataNode上进行删除。目标就是尽量平衡DataNodes的存储空间使用率，同时又不降低block的可用性。</p>
<p>当一个block的副本数过少时，它会被放入一个replication优先队列。只有一个副本的block会具有最高的优先级，那些具有三分之二以上的完好副本数的blocks具有最低的优先级。后台线程会周期性地扫描该队列的头部来决定新副本的放置。Block replication会遵循一个与前面的新副本放置类似的策略。如果现有副本数是一，HDFS会将下一个副本放置到不同的一个机柜上。在现有副本数是二的情况下，如果现存的两个位于同一个机柜上，那么第三个副本将会被放到另一个机柜上；反之，第三个副本将会被放置到与现有的某个副本相同机柜的不同节点上。这里的目标是为了减少新副本的创建开销。</p>
<p>NameNode也会保证一个block的所有副本不会被放置到同一个机柜上。如果NameNode检测到某个block的所有副本都处于同一个机柜上，NameNode会将该block当做是副本数过少的情况，然后使用与前面相同的放置策略将block复制到另一个机柜上。当NameNode收到副本创建成功的通知之后，该block就变成了副本数过多的状态。之后NameNode会决定删除一个旧的副本，因为针对副本数过多的情况，处理策略是尽量不降低机柜数。</p>
<h3 id="Balancer"><a href="#Balancer" class="headerlink" title="Balancer"></a>Balancer</h3><p>HDFS块放置策略没有考虑DataNode的磁盘空间使用状况。主要是为了避免将新数据(更有可能被访问)聚集到个别的DataNodes上。因此数据可能并不是总是均匀分布的。同时当有新节点添加到集群中时，集群也会处于imbalance状态。<br>Balancer是一个用于平衡HDFS集群的磁盘空间使用率的工具。它以一个取值范围在(0,1)的阈值作为输入参数。如果对于每个DataNode来说，它的磁盘空间使用率(已用空间占节点总的存储空间的比率)与整个集群的使用率(整个集群的已用空间占集群总存储空间的比率)差值不超过该阈值，我们就认为该集群已处于平衡状态。</p>
<p>该工具作为一个可以由集群管理员运行的应用程序部署在集群上。它会不断地将副本从使用率高的DataNodes移动到使用率低的DataNodes上。对于Balancer的一个关键需求就是保持数据的可用性。在选择一个副本的移动目标时，Balancer需要保证此次移动既不能降低副本数也不能降低机柜数。</p>
<p>Balancer会通过最小化机柜间的数据拷贝来进行优化。如果Balancer决定副本A需要移到另一个不同的机柜上时，恰好目标机柜上有该block的另一个副本B，那么数据会从B处直接进行拷贝而不需要再从A处。</p>
<p>还有一个配置参数可以用来限制rebalancing操作消耗的带宽。允许它消耗的带宽越高，集群就能越快达到平衡状态，但是也会带来与应用程序进程间更大的资源竞争。</p>
<h3 id="Block-Scanner"><a href="#Block-Scanner" class="headerlink" title="Block Scanner"></a>Block Scanner</h3><p>每个DataNode会运行一个block scanner周期性地扫描它的block副本，验证block数据与存储的校验和是否匹配。在每个扫描周期中，block scanner会调整读取带宽以保证可以在配置的时间周期内完成验证。当客户端读取一个完整的block并且检验和验证成功，它会通知DataNode。DataNode会将它视为一个对该副本的有效验证{!即因为客户端读取时会进行校验和验证，这样我们就可以直接利用它的验证结果，而不需要DataNode的block scanner再去验证，这就节省了计算资源}。</p>
<p>每个block校验的时间点会存储在一个人工可读的日志文件中。在任意时刻顶层的DataNode目录下，都会有两个文件，当前的及前一个日志。新的校验时间会被append到当前的文件中。相应地，每个DataNode在内存中都保存了一个根据副本校验时间排好序的扫描列表。</p>
<p>无论何时当一个正在读的客户端或者block scanner检测到一个损坏的block时，都会通知NameNode。NameNode会将该副本标记为损坏，但是不会立即对该副本进行删除，而是开始为该block复制一个完好的拷贝。只有当好的副本数达到该block的正常副本数的情况下，那个损坏的副本才会被删除。该策略旨在尽可能地对数据进行保护。因此即使某个block的所有副本都损坏了，该策略还能允许用户从损坏的副本中恢复数据。</p>
<h3 id="Decommissioning-下线"><a href="#Decommissioning-下线" class="headerlink" title="Decommissioning(下线)"></a>Decommissioning(下线)</h3><p>集群管理员可以通过列出允许进行注册的主机地址和不允许进行注册节点的主机地址，来指定可以加入到集群的节点。管理员可以命令系统重新计算这两种列表。如果集群中现有的一个节点出现在了排除列表中，就会被标记为Decommissioning。一旦一个DataNode被标记为Decommissioning，它就不会再被选定为副本放置的目标，但是它仍会继续响应读请求。NameNode会开始将它上面的blocks的副本调度到其他DataNodes上。一旦NameNode检测到该Decommissioning节点上的所有blocks已复制完成，该节点就会进入Decommissioned状态。之后，它就可以安全地从集群中删除而不带来任何数据可用性方面的危害。</p>
<h3 id="跨集群数据拷贝"><a href="#跨集群数据拷贝" class="headerlink" title="跨集群数据拷贝"></a>跨集群数据拷贝</h3><p>在处理大规模数据集时，将数据拷入或拷出HDFS集群是很吓人的。HDFS为大规模的集群内/集群间拷贝提供一个叫做DistCp的工具。它是一个MapReduce job；每个Map task会将元数据的一部分拷贝到目标文件系统。MapReduce框架会自动地处理并行task的调度，错误检测和恢复。</p>
<h2 id="Practice-At-Yahoo"><a href="#Practice-At-Yahoo" class="headerlink" title="Practice At Yahoo!"></a>Practice At Yahoo!</h2><p>Yahoo!的大规模集群包含大概3500个节点。一个典型的集群节点配置如下：</p>
<p>l  2个4核Xeon处理器@2.5g赫兹</p>
<p>l  Red Hat Enterprise Linux服务器Release 5.1</p>
<p>l  Sun Jave JDK 1.6.0_13-b03</p>
<p>l  4个SATA磁盘驱动器(每个1TB)</p>
<p>l  16G RAM</p>
<p>l  gigabit Ethernet</p>
<p>70%的磁盘空间会被分配给HDFS。剩余的会预留给操作系统，日志，以及map tasks产生的中间输出(MapReduce中间文件没有存储在HDFS上)。单个机柜内的40个节点共享一个IP交换机。机柜上的交换机又会被连接到8个核心交换机中的某一个。核心交换机提供了机柜间的以及到外部集群的连通性。对于每个集群来说，NameNode和BackupNode会被特别安置在具有64GB RAM的机器上；应用程序tasks不会被调度到它们所在的机器上。总共算起来，一个3500个节点的集群具有9.8PB的可用存储空间，因为blocks被存了三份，因此对于应用程序来说只有3.3PB的实际存储。大概算下来，1000个节点代表了1PB的存储。在HDFS投入使用的这些年里(以及未来的日子里)，组成集群节点的主机性能伴随着技术的改进也在不断提高。新的集群节点通常具有更高的处理器性能，更大空间的磁盘和内存。慢慢地，那些旧的节点会下线或者用做Hadoop的开发测试集群。关于集群节点的选择很大程度上是计算与存储间的考量。HDFS并没有强制计算与存储之间的比率，或者是对于集群节点的存储空间做出限制。</p>
<p>在一个实际的大规模集群上(3500节点)，总共有60 million个文件。这些文件总共有63 million个blocks。因为每个block通常有3个副本，这样每个DataNode大概有54000个block副本。用户应用程序每天会在集群上创建2 million个新文件。在Yahoo!的Hadoop集群中的25000个节点提供了25PB的在线数据存储。在2010年初，Yahoo!的数据处理规模大概在这样一个水平上，当然还在持续增长中。Yahoo!从2004年开始基于分布式文件系统的MapReduce的相关研究。Apache Hadoop项目在2006年成立。在那年年底，Yahoo!已经将Hadoop投入到内部使用，同时有一个用于开发的300个节点的集群。从那时起，HDFS已经成为Yahoo!后台架构的不可或缺的一部分。Web Map(作为搜索引擎关键组件的网页索引)产品一直是针对HDFS的首要应用，它总共运行75个小时，产生500TB的MapReduce中间数据，300TB的最终输出。更多的应用正在迁移到Hadoop，尤其是那些对用户行为进行分析和建模的应用。</p>
<p>Becoming a key component of yahoo’s technology suite meant tackling technical problems that are the difference between being a research project and being the custodian of many petabytes of corporate data。最重要的是数据的健壮性和数据的持久性。当然，性能的经济性，用户间的资源共享及对于系统操作者管理的舒适性也都是很重要的。</p>
<h3 id="数据的持久性"><a href="#数据的持久性" class="headerlink" title="数据的持久性"></a>数据的持久性</h3><p>将数据备份三次是为了防止因非关联的节点失效造成数据丢失。通过这种方式，Yahoo!降低了block丢失的概率；对于一个大规模集群来说，在一年的时间内丢失一个block的概率小于0.005。需要注意的是每月的节点失效概率是0.8%。(即使节点最终恢复过来，也不需要再去恢复它曾经持有的数据)。因此，对于我们上面描述的大规模集群来说，每天都会有一两个节点失效。集群大概能在两分钟之内将存放在失效节点上的54000个block副本重新创建出来。(重备份是很快的，因为它是一个可以随集群规模线性扩展的并行问题)。几个节点同时在两分钟内失效的概率是很低的，因此某个block的所有副本都丢失的概率也是很低的。</p>
<p>节点的关联性失效是另一种完全不同的威胁。通常情况下这种失效是因为机柜或者核心交换机的失效造成的。HDFS可以容忍一个机柜交换机的失效(每个block在其他机柜上还会有一份副本)。核心交换机的失效可能会导致集群中的多个机柜的节点无法连通，这种情况下某些blocks可能就是不可用的了。在第二种情况下，需要修复核心交换机来将不可用的副本恢复到集群中。另一种关联性的失效是由集群意外或计划中的电力供应中断引起的。如果某些机柜的电力供应中断，那么某些blocks就可能会变成不可用的。但是恢复电力供应可能也无法解决问题，因为集群中仍可能有一半到1%的节点无法通过加电重启恢复过来。统计学上以及实践表明，一个大规模集群将会在加电重启中丢掉一些节点。</p>
<p>除了节点的完全失效之外，存储数据也可能会损坏或丢失。Block scanner每两星期对一个大规模集群中的blocks进行扫描，通常在这个过程中大概会发现20个左右的坏副本。</p>
<h3 id="Caring-for-Commons"><a href="#Caring-for-Commons" class="headerlink" title="Caring for Commons"></a>Caring for Commons</h3><p>伴随着HDFS使用的增长，文件系统本身也必须引入一些方式来在一个庞杂的用户群体内共享资源。这样的一个首要feature就是类似于Unix文件目录权限管理模式的权限框架。在该框架内，文件和目录的访问权限分为针对owner，关联到该文件和目录的用户组，及所有其他用户的三种类别。与Unix不同的是，HDFS中文件没有执行权限和粘着位(即t/T特殊权限)。</p>
<p>在现有的权限框架内，用户认证是很弱的；用户身份是由其登陆身份决定的。在访问HDFS的时候，应用程序客户端通过查询操作系统得到用户身份和用户组。一个更强的身份认证模型目前还在开发中。在新的框架中，应用程序客户端必须出示从一个可信任源获取的name system证书。可能会使用不同的证书管理方式，初始实现使用了Kerberos。用户应用程序可以使用同一个框架来确认name system也具有一个可信任的身份。同时name system也可以询问集群中每个DataNode的证书。</p>
<p>总的可用数据存储空间是由DataNodes数和每个DataNode可以提供的存储空间决定的。HDFS的早期经验展示了一种针对不同用户群体之间进行资源分配的需求。不仅要保证资源共享的公平性，还要能够防止一个具有数千个数据写入需求的应用意外地将资源耗尽。对于HDFS来说，因为系统元数据总是存在RAM中，因此名字空间大小(文件和目录树)也是一种有限的资源。为了对存储和名字空间资源进行管理，每个目录可能会被设置一个quota来限制该目录下的存储资源。同时也可以设置另一个quota来对文件和目录数进行限制。</p>
<p>虽然HDFS架构假定大部分的应用程序会以大规模的数据集为输入，但是MapReduce编程框架可能会产生很多小输出文件(每个reduce task产生一个)，这会加大对于名字空间资源的占用。为方便起见，一个目录子树可以被合并为一个Hadoop 归档文件。一个HAR文件类似于我们所熟悉的tar，JAR或者Zip文件，但是文件系统操作必须能够识别出归档文件中的内部文件，一个HAR文件应该可以透明地用作一个MapReduce job的输入。</p>
<h3 id="Benchmarks"><a href="#Benchmarks" class="headerlink" title="Benchmarks"></a>Benchmarks</h3><p>HDFS的设计目标是为大规模数据集提供高的IO带宽。通常有三种针对该目标的度量方式。</p>
<ul>
<li><p>通过人为的benchmark观察带宽是怎样的</p>
</li>
<li><p>通过在一个具有多个用户job的生产集群里观察带宽是怎样的</p>
</li>
<li><p>通过精心构建的大规模用户应用观察带宽是怎样的</p>
</li>
</ul>
<p>这里的统计报告来自于那些至少具有3500个节点的集群。在这个规模上，总带宽与节点数成线性关系，因此单节点的带宽是一个很有意义的统计信息。这些benchmark本身是Hadoop代码的一部分。</p>
<p>DFSIO benchmark用于测量读写及append操作的平均吞吐率。DFSIO作为一个可用的应用程序，目前是Hadoop发布版的一部分。该MapReduce程序会从/向文件中读/写/appends随机数据。Job内的每个map task会在一个不同的文件上执行相同的操作，传输相同大小的数据，同时会将它们的传输速率报告给一个reduce task。Reduce task之后会对这些测量信息进行汇总。这项测试在运行时是独占集群的，同时根据集群大小按固定比例来选定map task的数目。它只是设计用来测量数据传输性能的，会排除掉任务调度，启动及reduce task的开销。</p>
<p>l  DFSIO Read：66MB/s per node</p>
<p>l  DFSIO Write：40MB/s per node</p>
<p>对于一个生产集群来说，读写的字节数将会被报告给一个metrics收集系统。这些值是几个星期的平均值同时代表着数百个用户的jobs的集群使用情况。平均情况下，每个节点上任意时刻会运行这一两个应用程序tasks(小于可用的处理器核数)。</p>
<p>l  Busy Cluster Read：1.02MB/s per node</p>
<p>l  Busy Cluster Write：1.09MB/s per node</p>
<p> 表2.针对1TB和1PB数据的Sort benchmark。每条数据记录有100字节，其中key有10字节。测试程序是一个通用的排序过程而并未针对记录大小进行特殊处理。在1TB数据排序中，block副本数设成了1，对于一个持续时间比较短的测试来说这是一个合理的设置。在1PB数据排序中，block副本数为2，这样测试程序就可以在即使有节点失效的情况也可以顺利完成。</p>
<p>在2009初，Yahoo!参与了Gray Sort比赛，并拿下了冠军。该task本身对系统将数据移入移出文件系统的能力要求很高(实际上它的关键并不在于排序)。最后一列的I/O rate包含了对HDFS的读入及写出。在第二行里，虽然HDFS的rate有所下降，但是单节点的I/O却大概增加了一倍，这是因为对于更大规模(petabyte!)的数据集来说，MapReduce的中间结果也必须对磁盘进行写入和读取。在小规模的测试里，是不会将MapReduce的中间数据溢写(spill)到磁盘的；它们被直接缓存到了task的内存中。</p>
<p>大规模集群需要HDFS NameNode能够支持与集群规模相对应的大量的client操作。NNThroughput benchmark是一个单机进程，它会启动NameNode应用程序，同时在同一个节点上运行大量的客户端线程。每个客户端线程会通过直接调用NameNode接口来执行同一个NameNode操作。该benchmark是用来测量NameNode每秒可执行的操作数。为避免由RPC连接和序列化引起的开销，该benchmark是运行在本地而不是远程的节点上。通过该测试得到了纯NameNode的性能上界：</p>
<h2 id="工作展望"><a href="#工作展望" class="headerlink" title="工作展望"></a>工作展望</h2><p>本节提出一些Yahoo的Hadoop团队正在考虑中的一些未来的工作计划；Hadoop作为一个开源项目，意味着很多新的features和变更需要由Hadoop开发者社区来决定。</p>
<p>当NameNode down掉的时候Hadoop集群实际上就会变成不可用的。由于Hadoop主要是作为一种批处理系统使用，重启NameNode也是一种可以接受的恢复方式。但是，我们已经开始向着自动化的故障恢复(failover)而迈进。当前情况下，BackupNode会接受来自primary NameNode的所有事务。如果我们同时将block reports发送给primary NameNode和BackupNode，这就允许一个故障恢复成为warm的或者hot的{!与冷启动，热启动中的含义相同，当然也有处于二者之间的暖}。我们的目标是使用Zookeeper来构建一个自动化的故障恢复解决方案。</p>
<p>NameNode的可扩展性已成为一个首要的需要解决的问题。因为NameNode将名字空间和block位置信息全部保存在内存中，NameNode的堆空间大小已经限制了文件数及可寻址的blocks数。当NameNode的内存使用率接近极限时，NameNode就会变成无响应的有时甚至需要进行重启，这已经成为NameNode面临的主要挑战。虽然我们鼓励用户创建更大的文件，但是有时这也是不可行的，因为这需要对应用程序进行比较大的变更。现在我们已经为HDFS的使用管理提供了quota，同时也提供了一个归档工具。然而，这些都没有从根本上解决可扩展性问题。</p>
<p>我们针对可扩展性的近期解决方案是允许使用多个名字空间(及多个NameNodes)来共享集群内的物理资源。我们正在扩展我们的block IDs，使它可以以一个block pool标识符为前缀。Block pools类似于一个SAN(StorgeAreaNetwork)存储系统中的LUNs(LogicUnitNumber)，而具有多个blocks pool的名字空间类似于一个文件系统卷(volume)。</p>
<p>这种策略很简单同时对系统的修改也是最小化的。除可扩展性之外，它还提供了其他一些优点：可以将不同的应用程序集隔离在不同的名字空间下，同时可以提高集群的整体可用性。可以将块存储服务进行通用化，这样就允许其他的一些具有不同名字空间结构的服务来使用这个块存储服务。我们也计划探索一些其他的方式来进行扩展，比如只将部分名字空间存在内存中，在未来提供一个NameNode的真正的分布式实现。此外，我们关于应用程序只会创建少数大文件的假设也是有问题的。如前所述，改变应用程序行为是很难的。此外，针对HDFS的新一类应用程序可能需要存储大量的小文件。</p>
<p>多个独立名字空间的主要缺点是带来的管理开销，尤其是在名字空间数很大的情况下。我们也计划使用以应用程序或者是job为中心的namespaces而不是以集群为中心的—这类似于80年代晚期和90年代早期用于处理分布式系统中远程执行的进程级(per-process)名字空间。</p>
<p>目前我们的集群少于4000节点。我们相信通过上面的解决方案，可以将它扩展到更大的规模。然而，我们认为使用多个小集群与使用单个的大集群(比如3个6000节点集群与一个18000节点集群)相比要更明智一些，因为这样具有更好的可用性和隔离性。最后，我们也计划提供更多的集群间协作支持。比如，为跨越多个集群的文件集合缓存被访问的远程文件或者是降低blocks副本数。</p>
<h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p>{!这一部分来自于：<a href="http://www.aosabook.org/en/hdfs.html}" target="_blank" rel="noopener">http://www.aosabook.org/en/hdfs.html}</a></p>
<p>一个非常小的团队构建了Hadoop文件系统，同时使得它稳定健壮的运行在产品系统中。这种成功大部分归因于简单的设计：replicated blocks, 周期性地 block reports以及中央化的元数据服务器。避免了完全的POSIX语义也提供了一定的帮助。尽管将整个元数据保存到内存中限制了可扩展性，这也使得NameNode非常简单：避免的典型文件系统中那种复杂的锁机制。Hadoop成功的另一个原因是在Yahoo!的快速地产品化，这就使得它可以不断地快速地改进。文件系统十分健壮，NameNode很少出错；事实上大部分的停机时间都是由升级造成的。只是最近才引入了自动化的故障恢复机制。</p>
<p>很多人可能会很吃惊，在构建这样一个大型系统中选择了Java语言。尽管由于Java的对象内存和垃圾回收开销给NameNode的扩展造成了一些挑战，但是Java也带来了系统的健壮性；避免了由指针和内存管理bugs造成的危害。</p>
<p>7.致谢<br>我们需要感谢现在的和过去的所有的Yahoo! HDFS团队成员，感谢他们在构建该文件系统中所做的努力。我们也需要感谢所有的Hadoop committers和collaborators(合作者)，感谢他们的宝贵共享。Corinne Chandel绘制了论文中的插图。</p>
<p>.</p>
]]></content>
      
        <categories>
            
            <category> hadoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> hadoop </tag>
            
            <tag> HDFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java多线程的总结]]></title>
      <url>/2016/03/coding/Java-%E6%80%BB%E7%BB%93-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="多线程-VS-多进程"><a href="#多线程-VS-多进程" class="headerlink" title="多线程 VS 多进程"></a>多线程 VS 多进程</h2><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>在大多数操作系统中都可以创建多个进程。当一个程序启动时，它可以为即将开始的每项任务创建一个进程，并允许它们同时运行。当一个程序因等待网络访问或用户输入而被阻塞时，另一个程序还可以运行，这样就增加了资源利用率。但是，按照这种方式创建每个进程要付出一定的代价：设置一个进程要占用相当一部分处理器时间和内存资源。而且，大多数操作系统不允许进程访问其他进程的内存空间。因此，进程间的 <strong>通信很不方便</strong>，并且也不会将它自己提供给容易的编程模型。<a id="more"></a></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>线程也称为轻型进程 (LWP)。因为线程只能在单个进程的作用域内活动，所以创建线程比创建进程要廉价得多。这样，因为线程允许协作和数据交换，并且在计算资源方面非常廉价，所以线程比进程更可取。线程需要操作系统的支持，因此不是所有的机器都提供线程。</p>
<h2 id="协作式线程VS-抢占式线程"><a href="#协作式线程VS-抢占式线程" class="headerlink" title="协作式线程VS 抢占式线程"></a>协作式线程VS 抢占式线程</h2><p><strong>协作式线程</strong> 模型允许线程自己决定什么时候放弃处理器来等待其他的线程。程序开发员可以精确地决定某个线程何时会被其他线程挂起，允许它们与对方有效地合作。缺点在于某些恶意或是写得不好的线程会消耗所有可获得的 CPU 时间，导致其他线程“饥饿”。<br><strong>抢占式线程</strong> 模型中，操作系统可以在任何时候打断线程。通常会在它运行了一段时间（就是所谓的一个时间片）后才打断它。这样的结果自然是没有线程能够不公平地长时间霸占处理器。</p>
<p>抢占式线程模型要求线程正确共享资源，协作式模型却要求线程共享执行时间。</p>
<h2 id="Thread-类-Vs-Runnable-接口"><a href="#Thread-类-Vs-Runnable-接口" class="headerlink" title="Thread 类 Vs Runnable 接口"></a>Thread 类 Vs Runnable 接口</h2><h3 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a>Thread 类</h3><p>Thread 类是一个具体的类，即不是抽象类，该类封装了线程的行为。要创建一个线程，程序员必须创建一个从 Thread 类导出的新类。程序员必须覆盖 Thread 的 run() 函数来完成有用的工作。用户并不直接调用此函数；而是必须调用 Thread 的 start() 函数，该函数再调用 run()（自动自动的）。</p>
<p>但 Java 编程语言只允许一个类有一个父类。同时，所以我们一般避免从 Thread 类导出，因为它强加了类层次。</p>
<h3 id="Runnable-接口"><a href="#Runnable-接口" class="headerlink" title="Runnable 接口"></a>Runnable 接口</h3><p>此接口只有一个函数：run()，此函数必须由实现了此接口的类实现。<br>我个人更喜欢 runnable 接口，因为从 Thread 类继承会强加类层次。<br>当使用 runnable 接口时，您不能直接创建所需类的对象并运行它；必须从 Thread 类的一个实例内部运行它。<code>Thread t1 = new Thread (new ClassImplementsRunnable(XXX, &quot;Threadname&quot;));</code></p>
<h2 id="新特性-线程池"><a href="#新特性-线程池" class="headerlink" title="新特性-线程池"></a>新特性-线程池</h2><p>线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多线程中，所有对象都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个对象，把内容给改乱了。这就是传说中的 <strong>数据竞争（data race）</strong>。数据竞争的存在是Java多线程应用中要解决的首要问题。<br>在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量。这两种机制的提出都是为了实现代码线程的安全性。</p>
<h3 id="锁-amp-synchronized-关键字"><a href="#锁-amp-synchronized-关键字" class="headerlink" title="锁 &amp; synchronized 关键字"></a>锁 &amp; synchronized 关键字</h3><p>在 Java 程序中最简单实现同步的方法就是 <strong>上锁</strong>。为了防止同时访问共享资源，线程在使用资源的前后可以给该资源上锁和开锁。</p>
<p>使用方法（其中之一）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line">       <span class="function"><span class="keyword">synchronized</span> <span class="title">method</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">       method body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>局限性：<br>不能设超时<br>不能中断<br>仅有单一条件</p>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>因为同步的开销很大。<br>Volatile /‘vɒlətaɪl/  是一种免锁机制！<br>当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。</p>
<p>注意：<br>volatile可以用在任何变量前面，但不能用于final变量前面，因为final型的变量是禁止修改的。也不存在线程安全的问题。<br>Volatile /‘vɒlətaɪl/  变量的同步性较差（但有时它更简单并且开销更低），而且其使用也更容易出错。</p>
<h2 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h2><p>在有些情况下，仅依靠线程之间对数据的互斥访问是不够的。有些线程之间存在协作关系，需要按照一定的协议来协同完成某项任务，比如典型的生产者-消费者模式。这种情况下就需要用到Java提供的线程之间的 <strong>等待-通知机制</strong>。</p>
<p>当线程所要求的条件不满足时，就进入等待状态；而另外的线程则负责在合适的时机发出通知来唤醒等待中的线程。</p>
<p>Java中的java.lang.Object类中的<code>wait/notify/notifyAll方</code>法组就是完成线程之间的同步的.</p>
<p>使用注意：</p>
<ul>
<li><code>wait/notify/notifyAll</code>操作需要放在synchronized代码块或方法中，这样才能保证在执行 <code>wait/notify/notifyAll</code>的时候，当前线程已经获得了所需要的锁。</li>
<li>当对于某个对象的等待集合中的线程数目没有把握的时候，最好使用 <code>notifyAll</code>而不是<code>notify</code>。<code>notifyAll</code>虽然会导致线程在没有必要的情况下被唤醒而产生性能影响，但是在使用上更加简单一些。</li>
<li>由于线程可能在非正常情况下被意外唤醒，一般需要把<code>wait</code>操作放在一个循环中，并检查所要求的逻辑条件是否满足。<br>典型的使用模式如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="comment">/* 逻辑条件不满足的时候 */</span>) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           lock.wait();  </span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="常见的问题"><a href="#常见的问题" class="headerlink" title="常见的问题"></a>常见的问题</h2><h3 id="在多线程中，什么是上下文切换-context-switching-？"><a href="#在多线程中，什么是上下文切换-context-switching-？" class="headerlink" title="在多线程中，什么是上下文切换(context-switching)？"></a>在多线程中，什么是上下文切换(context-switching)？</h3><p>上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p>
<h3 id="如何让正在运行的线程暂停一段时间？"><a href="#如何让正在运行的线程暂停一段时间？" class="headerlink" title="如何让正在运行的线程暂停一段时间？"></a>如何让正在运行的线程暂停一段时间？</h3><p>我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。</p>
<h3 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h3><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级</p>
<h3 id="可以直接调用Thread类的run-方法么？"><a href="#可以直接调用Thread类的run-方法么？" class="headerlink" title="可以直接调用Thread类的run()方法么？"></a>可以直接调用Thread类的run()方法么？</h3><p>当然可以，但是不建议，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread.start()方法。</p>
<h3 id="用户线程和守护线程有什么区别？"><a href="#用户线程和守护线程有什么区别？" class="headerlink" title="用户线程和守护线程有什么区别？"></a>用户线程和守护线程有什么区别？</h3><p>当我们在Java程序中创建一个线程，它就被称为用户线程。一个普通线程调用<code>t.setDaemon(ture)</code> 就可以变成守护线程，<br>一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候（只剩下守护线程时），JVM关闭程序并且退出。<br>一个守护线程创建的子线程依然是守护线程。<br>注意 守护线程不要访问固定资源，小心中断！</p>
<h3 id="你如何确保main-方法所在的线程是Java程序最后结束的线程？"><a href="#你如何确保main-方法所在的线程是Java程序最后结束的线程？" class="headerlink" title="你如何确保main()方法所在的线程是Java程序最后结束的线程？"></a>你如何确保main()方法所在的线程是Java程序最后结束的线程？</h3><p>我们可以使用Thread类的<code>joint()</code>方法来确保所有程序创建的线程在<code>main()</code>方法退出前结束。</p>
<h3 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h3><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>
<h3 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal?"></a>什么是ThreadLocal?</h3><p>ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。<br>每个线程都会拥有他们自己的Thread变量，它们可以使用get()\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。</p>
<h3 id="什么是Java-Timer类？如何创建一个有特定时间间隔的任务？"><a href="#什么是Java-Timer类？如何创建一个有特定时间间隔的任务？" class="headerlink" title="什么是Java Timer类？如何创建一个有特定时间间隔的任务？"></a>什么是Java Timer类？如何创建一个有特定时间间隔的任务？</h3><p><code>java.util.Timer</code>是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。<br><code>java.util.TimerTask</code>是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python3-多线程与多进程]]></title>
      <url>/2016/03/%E5%BE%85%E6%95%B4%E7%90%86/Python3-%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。<br><a id="more"></a><br>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程。<br><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步.（java中也是）</p>
<h3 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h3><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程。<br>对Pool对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了<code>Queue、Pipes</code>等多种方式来交换数据。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ol>
<li>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块.</li>
<li>任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程;</li>
<li>Python的threading模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。</li>
<li>主线程实例的名字叫MainThread，</li>
<li>子线程的名字在创建时指定，如<code>t = threading.Thread(target=loop, name=&#39;LoopThread&#39;)</code></li>
</ol>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>线程和多进程最大的不同在于：多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。<br>所以我们要用锁这个功能，线程因为获得了锁，因此其他线程不能同时执行上锁的方法，只能等待，直到锁被释放后，获得该锁以后才能改。由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。<br>创建一个锁就是通过<code>threading.Lock()</code>来实现：代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lock = threading.Lock() <span class="comment"># 在全局中创建</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        <span class="comment"># 先要获取锁:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 放心地改吧:</span></span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 改完了一定要释放锁:</span></span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure></p>
<p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止(也就是那线程执行<code>lock.release()</code> ),</p>
<h3 id="锁的性能特点："><a href="#锁的性能特点：" class="headerlink" title="锁的性能特点："></a>锁的性能特点：</h3><ul>
<li>好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，</li>
<li>首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</li>
<li>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁。</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。</p>
<p>ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Python3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python3-IO编程]]></title>
      <url>/2016/03/%E5%BE%85%E6%95%B4%E7%90%86/Python3-%E7%AC%94%E8%AE%B0-IO%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><a id="more"></a>
<h2 id="文件读写open"><a href="#文件读写open" class="headerlink" title="文件读写open()"></a>文件读写<code>open()</code></h2><ul>
<li>使用Python内置的<code>open()</code>函数，传入文件名和标示符:<code>f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;)</code></li>
<li>如果文件不存在，<code>open()</code>函数就会抛出一个IOError的错误.</li>
<li>调用<code>open()</code>函数<code>read()</code>方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示.</li>
<li>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的。</li>
</ul>
<p>在实际中为了保证无论是否出错都能正确地关闭文件，我们可以使用with语句来自动帮我们调用close()方法：(<strong>好习惯</strong>)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">  print(f.read())</span><br></pre></td></tr></table></figure></p>
<p>ps:<br>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取size个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回list。</p>
<h3 id="几个标示符"><a href="#几个标示符" class="headerlink" title="几个标示符"></a>几个标示符</h3><p><code>r</code>默认都是读取文本文件，并且是UTF-8编码的文本文件<br><code>rb</code>读取二进制文件<br><code>w</code>写文本文件<br><code>wb</code>表示写二进制文件.</p>
<p>几个其他的参数：<br><code>encoding=&#39;gbk&#39;</code>  读取GBK编码的文件（也可以是别的）<br><code>errors=&#39;ignore&#39;</code> 遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，设置errors参数，表示如果遇到编码错误后如何处理：最简单的方式是直接忽略</p>
<h2 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h2><p>tringIO顾名思义就是在内存中读写str。<br><code>getvalue()</code>方法用于获得写入后的str。</p>
<h2 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h2><p>在内存中读写二进制数据<br>请注意，写入的不是str，而是经过UTF-8编码的bytes。</p>
<h2 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><p>os模块可以直接调用操作系统提供的接口函数<br>获取详细的系统信息:可以调用<code>uname()</code>函数<br>操作系统中定义的环境变量: 全部保存在<code>os.environ</code>中<br>获取某个环境变量的值: 调用<code>os.environ.get(&#39;key&#39;)</code></p>
<p>操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。<br>Python提供了pickle模块来实现序列化。<br><code>pickle.dumps()</code>方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件<code>pickle.dump()</code>直接把对象序列化后写入一个file-like Object：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'dump.txt'</span>, <span class="string">'wb'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dump(d, f)</span><br></pre></td></tr></table></figure></p>
<p>把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个file-like Object中直接反序列化出对象。</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML.JSON<br>JSON标准规定JSON编码是UTF-8.<br>Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。<br>json.dumps()方法返回一个str，内容就是标准的JSON。类似的，<br>json.dump()方法可以直接把JSON写入一个file-like Object</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Python3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark基础概念——RDD]]></title>
      <url>/2016/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/Spark-%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>Spark基于map reduce算法实现的分布式计算，拥有Hadoop MapReduce所具有的优点；但不同于MapReduce的：spark是Job中间输出和结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的map reduce的算法。<a id="more"></a><br>这也是就我为什么要学习他的原因。</p>
<h3 id="SparkContext类与SparkConf类"><a href="#SparkContext类与SparkConf类" class="headerlink" title="SparkContext类与SparkConf类"></a>SparkContext类与SparkConf类</h3><p>任何Spark程序的编写都是从SparkContext(或用Java编写时的JavaSparkContext)开始 的。SparkContext的初始化需要一个SparkConf对象,后者包含了Spark集群配置的各种参数<br>(比如主节点的URL)。</p>
<h3 id="弹性分布式数据集-RDD"><a href="#弹性分布式数据集-RDD" class="headerlink" title="弹性分布式数据集 RDD"></a>弹性分布式数据集 RDD</h3><p>RDD是Spark最基本的抽象，是对分布式内存的抽象使用。它表示已被分区，不可变的并能够被并行操作的数据集合，不同的数据集格式对应不同的RDD实现。</p>
<h4 id="RDD的特点："><a href="#RDD的特点：" class="headerlink" title="RDD的特点："></a>RDD的特点：</h4><ul>
<li>它是在集群节点上的不可变的、已分区的集合对象。</li>
<li>通过并行转换的方式来创建如（map, filter, join, etc）。</li>
<li>失败自动重建。</li>
<li>可以控制存储级别（内存、磁盘等）来进行重用。</li>
<li>必须是可序列化的。</li>
<li>是静态类型的。</li>
</ul>
<p>RDD可以cache到内存中，每次对RDD数据集的操作之后的结果，都可以存放到内存中，下一个操作可以直接从内存中输入，省去了MapReduce大量的磁盘IO操作。这对于迭代运算比较常见的机器学习算法, 交互式的数据挖掘来说，效率提升很大！因为RDD的序列化特点，在内存不足时可自动降级为磁盘存储，把RDD存储于磁盘上，这时性能会有大的下降但不会差于现在的MapReduce。</p>
<p>由于RDD静态类型的的特性，Spark <strong>不适用</strong> 那种异步细粒度更新状态的应用（增量修改的应用模型），例如web服务的存储或者是增量的web爬虫和索引。</p>
<h4 id="内部表示"><a href="#内部表示" class="headerlink" title="内部表示"></a>内部表示</h4><ol>
<li>分区列表（数据块列表）</li>
<li>计算每个分片的函数（根据父RDD计算出此RDD）</li>
<li>对父RDD的依赖列表</li>
<li>对key-value RDD的Partitioner【可选】</li>
<li>每个数据分片的预定义地址列表(如HDFS上的数据块的地址)【可选</li>
</ol>
<h4 id="RDD的持久化-存储与分区"><a href="#RDD的持久化-存储与分区" class="headerlink" title="RDD的持久化-存储与分区"></a>RDD的持久化-存储与分区</h4><p>RDD根据useDisk、useMemory、deserialized、replication四个参数的组合提供了11种存储级别。<br>当前RDD默认是存储于内存，但当内存不足时，RDD会spill到disk。<br>RDD在需要进行分区把数据分布于集群中时会根据每条记录Key进行分区（如Hash 分区），以此保证两个数据集在Join时能高效。</p>
<h4 id="RDD的生成"><a href="#RDD的生成" class="headerlink" title="RDD的生成"></a>RDD的生成</h4><p>两种方式创建 RDDs：</p>
<ul>
<li>在你的驱动程序中并行化一个已经存在的集合；</li>
<li>是引用一个外部存储系统的数据集，例如共享的文件系统，HDFS，HBase或其他 Hadoop 数据格式的数据源。</li>
</ul>
<h4 id="RDD的操作"><a href="#RDD的操作" class="headerlink" title="RDD的操作"></a>RDD的操作</h4><p>对于RDD可以有两种计算方式：转换（返回值还是一个RDD）与操作（返回值不是一个RDD）。<br>注意：Transformations操作是Lazy的，也就是说从一个RDD转换生成另一个RDD的操作不是马上执行，Spark在遇到Transformations操作时只会记录需要这样的操作，并不会去执行，需要等到有Actions操作的时候才会真正启动计算过程进行计算。</p>
<h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><h2 id="Spark与Hadoop的对比"><a href="#Spark与Hadoop的对比" class="headerlink" title="Spark与Hadoop的对比"></a>Spark与Hadoop的对比</h2><ol>
<li>Spark的中间数据放到内存中，对于迭代运算效率更高。<ul>
<li>Spark更适合于迭代运算比较多的ML和DM运算。</li>
<li>hadoop更适用于数据量小但是计算密集度较大的场合。</li>
</ul>
</li>
<li>可用性。<ul>
<li>Spark通过提供丰富的Scala, Java，Python API及交互式Shell来提高可用性。</li>
</ul>
</li>
<li>容错性。<ul>
<li>在分布式数据集计算时通过checkpoint来实现容错，而checkpoint有两种方式，一个是- checkpoint data，一个是logging the updates。用户可以控制采用哪种方式来实现容错。</li>
</ul>
</li>
</ol>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>数据序列化就是将对象或者数据结构转化成特定的格式，使其可在网络中传输，或者可存储在内存或者文件中。反序列化则是相反的操作，将对象从序列化数据中还原出来。而对象序列化后的数据格式可以是二进制，可以是XML，也可以是JSON等任何格式。对象/数据序列化的重点在于数据的交换和传输，例如在远程调用技术(如EJB,XML-RPC, Web Service)，或者在GUI控件开发(JavaBean)等等。<br>Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。<br>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>对象持久化就是将对象存储在可持久保存的存储介质上，例如主流的关系数据库中。在实际应用中，需要将业务数据以对象的方式保存在数据库中，就需要应用到相应的对象持久化框架，如现在广为认知的Hibernate。而如果查阅对象持久化的历史，你会发现早在1970年就已经开始有称之为面向对象数据库OODBMS。通常这些面向对象的数据库和特定的一种语言绑定。对象持久化的重点在于如何将业务数据对象存储在持久化介质上，并同时提供查询修改的手段。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://tech.uc.cn/?p=2116" target="_blank" rel="noopener">Spark：一个高效的分布式计算系统</a></p>
]]></content>
      
        <categories>
            
            <category> Spark </category>
            
        </categories>
        
        
        <tags>
            
            <tag> saprk </tag>
            
            <tag> RDD </tag>
            
            <tag> SparkConf </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据相关职位情况统计调查]]></title>
      <url>/2016/03/%E9%9A%8F%E7%AC%94/%E7%94%9F%E6%B4%BB-%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E8%81%8C%E4%BD%8D%E8%B0%83%E6%9F%A5/</url>
      <content type="html"><![CDATA[<p>对大公司相关职位要求的汇总，期待可以找到适合的职业发展方向。<a id="more"></a></p>
<h2 id="搜狗"><a href="#搜狗" class="headerlink" title="搜狗"></a>搜狗</h2><h3 id="网页搜索-数据挖掘研究员"><a href="#网页搜索-数据挖掘研究员" class="headerlink" title="网页搜索-数据挖掘研究员"></a>网页搜索-数据挖掘研究员</h3><p>岗位说明：<br>1.调研各种网页作弊手段，设计和实施相应的对抗方案<br>2.应用机器学习技术，改进网页质量核心评估算法<br>3.应用自然语言处理技术，针对网页数据建模，挖掘有价值信息，提供网页排序使用<br>任职资格：<br>1.计算机相关专业研究生及以上学历；<br>2.精通C++或Java编程语言，熟悉Python/Shell/R脚本语言者优先；<br>3.对数据结构和算法设计有较为深刻的理解；<br>4.熟悉机器学习的基本算法，熟悉Hadoop分布式计算和Web信息检索者优先；<br>5.优秀的分析和解决问题的能力，对挑战性问题充满激情，有较强的学习能力；<br>6.良好的团队合作精神，较强的沟通能力。<br>职位类别：<br>研发类—研究<br>学历要求：<br>硕士及以上</p>
<h3 id="实习-搜狗输入法-大数据开发工程师"><a href="#实习-搜狗输入法-大数据开发工程师" class="headerlink" title="实习-搜狗输入法-大数据开发工程师"></a>实习-搜狗输入法-大数据开发工程师</h3><p>【岗位职责】<br>1.基于输入法和号码通的海量数据，进行处理分析，并进行功能研发；<br>2.能够深刻理解需求，撰写数据项目分析方案；<br>3.对海量业务数据进行分析，深度挖掘数据之间关联特征，构建精准的指标体系。<br>任职条件：<br>1.计算机或相关专业，硕士及以上学历；<br>2.熟悉C/C++或Java语言，有perl、shell等脚本处理经验者更佳；<br>3.熟悉数据结构和基本算法；<br>4.善于学习新事物，善于表达和沟通，有较强的分析和解决问题能力； 5.有Hadoop或中文处理项目经验者优先。</p>
<h3 id="实习-搜狗浏览器-机器学习研究员"><a href="#实习-搜狗浏览器-机器学习研究员" class="headerlink" title="实习-搜狗浏览器-机器学习研究员"></a>实习-搜狗浏览器-机器学习研究员</h3><p>发布日期：2016-03-28<br>工 作 地 点：北京招聘人数：1人<br>岗位职责】<br>面向大规模用户推荐系统，运用机器学习知识解决推荐系统中的瓶颈问题，并将机器学习算法并行化，以满足不断增长的海量用户需求。<br>任职条件：</p>
<ol>
<li>熟练掌握c++或者java编程语言；</li>
<li>熟练掌握数据结构、算法、等计算机基础知识；</li>
<li>专业背景满足如下方向之一：数据挖掘、推荐系统、自然语言处理、机器学习、深度学习、人工智能；</li>
<li>有良好的沟通能力和表达能力，能够用清晰简洁的话语阐明技术观点；</li>
<li>热爱技术、有进取心。<br>加分项：</li>
<li>博士优先；</li>
<li>有hadoop使用经验。</li>
</ol>
<h3 id="实习-搜狗浏览器-大数据挖掘和推荐系统工程师"><a href="#实习-搜狗浏览器-大数据挖掘和推荐系统工程师" class="headerlink" title="实习-搜狗浏览器-大数据挖掘和推荐系统工程师"></a>实习-搜狗浏览器-大数据挖掘和推荐系统工程师</h3><p>发布日期：2016-03-28<br>工 作 地 点：北京招聘人数：1人<br>岗位职责】<br>面对海量异构用户日志数据，分析用户行为规律，获取用户精准画像，以数据为中心设计和优化推荐系统算法，并在大规模、高并发环境下优化算法性能，给用户精准推荐新闻、资讯、应用App、等等，并满足不同产品出口的特殊要求。<br>任职条件：</p>
<ol>
<li>熟练掌握c++或者java编程语言；</li>
<li>熟练掌握数据结构、算法、等计算机基础知识；</li>
<li>专业背景满足如下方向之一：数据挖掘、推荐系统、自然语言处理、机器学习、深度学习、人工智能；</li>
<li>有良好的沟通能力和表达能力，能够用清晰简洁的话语阐明技术观点；</li>
<li>热爱技术、有进取心。<br>加分项：</li>
<li>有hadoop使用经验；</li>
<li>有个人技术博客（维护1年以上，原创文章20篇以上）。</li>
</ol>
<h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><h3 id="数据挖掘工程师"><a href="#数据挖掘工程师" class="headerlink" title="数据挖掘工程师"></a>数据挖掘工程师</h3><p>岗位描述:<br>在这里，你可以学习和掌握阿里巴巴集团业界最先进的大数据处理平台，涉及信息检索、自然语言处理、机器学习、数据挖掘、分布式计算等一系列的专业领域；<br>在这里，你将拥有最好的数据和实验环境，立足于uc浏览器数亿用户和数千亿浏览信息，与这些领域内的顶尖大牛工程师们一起参与目前最前沿的推荐、预测等大数据应用场景的算法设计和工程实现。<br>岗位要求:<br>岗位要求<br>1、本科以上学历，扎实的统计学、数据挖掘、机器学习理论基础，能够利用高等数学知识推演高维数学模型。<br>2、熟悉聚类、分类、回归、图模型等机器学习算法，对常见的核心算法理解透彻，有实际建模经验；<br>3、具有扎实的计算机操作系统、数据结构等编程基础，精通至少一门编程语言例如c++/python/R；<br>4、深入理解Map-Reduce模型，对Hadoop、Spark、Storm等大规模数据存储与运算平台有实践经验；<br>5、对于推荐系统和广告系统有实践经验者优先；<br>6、能够积极创新， 乐于面对挑战， 负责敬业；<br>7、优秀的团队合作精神；诚实， 勤奋， 严谨。</p>
<h3 id="数据研发工程师"><a href="#数据研发工程师" class="headerlink" title="数据研发工程师"></a>数据研发工程师</h3><p>岗位描述:<br>商家事业部-数据业务部，承载了阿里巴巴对客户提供大数据平台的使命和梦想，Enable阿里巴巴生态可以更好的进行数据化运营。我们在探索的是世界上独一无二的、领先的大数据业务，也在探索如何利用互联网精神和大数据技术在传统数据领域进行创新，来帮助客户从IT进入DT时代。</p>
<ol>
<li>参与阿里大数据开发平台建设，构建开放、安全、标准的阿里对外数据开发平台体系</li>
<li>基于阿里海量数据的数据仓库建设和数据分析，同时针对各业务场景探索大数据解决方案</li>
<li>在公共云计算环境构筑数据交换、融合、分享的生态，让数据驱动业务<br>岗位要求:</li>
<li>计算机或相关专业本科及以上学历</li>
<li>具有丰富的数据开发经验，对数据处理、数据建模、数据分析等有深刻认识和实战经验</li>
<li>熟悉SQL，有一定的SQL性能优化经验</li>
<li>熟练掌握Java语言，MapReduce编程，脚本语言Shell/Python/Perl之一</li>
<li>业务理解力强，对数据、新技术敏感，对云计算、大数据技术充满热情</li>
<li>积极乐观、诚信、有责任心；具备强烈的进取心、求知欲及团队合作精神</li>
</ol>
<h3 id="数据分析师"><a href="#数据分析师" class="headerlink" title="数据分析师"></a>数据分析师</h3><p>岗位描述:<br>1、独立负责业务数据收集整理，搭建业务数据体系，结合业务对多种数据源进行深度诊断性组合分析、挖掘、深度分析；<br>2、通过专题分析，对业务问题进行深入分析，为业务的策略、产品优化提供数据支持；<br>3、独立完成业务日常的产品运营工作，可以快速有效地取得一定的业务成果。<br>岗位要求:<br>1、统计、数学、信息技术、生物统计等专业本科及以上学历(硕士优先)，二年以上相关工作经历；<br>2、熟悉数据库基本原理，熟练运用SQL，熟练操作excel、PPT；熟悉数据挖掘的基本原理，熟练操作SAS、SPSS clementine等数据分析/挖掘工具的优先；<br>3、良好的数据敏感度，能从海量数据提炼核心结果，熟练独立编写商业数据分析报告，及时发现和分析其中隐含的变化和问题，给出建议；<br>4、具备良好的沟通能力和团队精神，较强的学习能力，能承担一定的工作压力</p>
<p>作者：数据分析网<br>链接：<a href="https://www.zhihu.com/question/24754717/answer/87999093" target="_blank" rel="noopener">https://www.zhihu.com/question/24754717/answer/87999093</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><h3 id="医疗事业部-数据挖掘实习生"><a href="#医疗事业部-数据挖掘实习生" class="headerlink" title="医疗事业部_数据挖掘实习生"></a>医疗事业部_数据挖掘实习生</h3><p>发布时间: 2016-02-18<br>工作职责:<br>-百度医疗事业部的数据分析产品后端开发和数据流开发<br>-理解数据分析与挖掘的应用场景，抽象为数据产品需求<br>-研究数据挖掘或统计学习领域的前沿技术，并用于实际问题的改善和优化<br>-大规模机器学习算法研究及并行化实现，为各种大规模机器学习应用提供稳定的服务<br>-通过对数据的敏锐洞察，深入挖掘产品潜在价值和需求，进而提供更有价值的服务</p>
<p>职责要求:<br>-熟悉Hadoop、Hive、Spark、Mysql等数据工具的若干种<br>-熟练掌握<code>Sql\R\Shell\Python\C\C++\Java</code>等编程语言的若干种<br>-对数据敏感，认同数据价值，具备基于价值层面考虑工作的结果导向型思维<br>-乐于接受打通从数据准备到数据应用整套流程的挑战<br>-熟悉数据挖掘基本理论和开发流程<br>-较强的沟通能力和逻辑表达能力，具备良好的团队合作精神和主动沟通意识<br>-全职实习,每周5天,持续实习6个月以上</p>
<h3 id="地图基础业务部-位置大数据工程类实习生"><a href="#地图基础业务部-位置大数据工程类实习生" class="headerlink" title="地图基础业务部_位置大数据工程类实习生"></a>地图基础业务部_位置大数据工程类实习生</h3><p>发布时间: 2016-02-23<br>工作职责:<br>-负责基础数据中心建设，提供离线查询、筛选等功能，支持LBS的多项业务<br>-负责基础数据服务模块开发，提供高性能、高可靠性、高可扩展性的数据服务<br>-负责组内其他架构方向的调研、设计、开发、评估等工作</p>
<p>职责要求:<br>-熟悉Linux环境，熟悉Linux环境下的C/C++编程<br>-熟悉Web网站开发，熟悉HTML、CSS、PHP、MySQL<br>-了解Hadoop/Spark/Hive<br>-具有较强的算法和数据结构功底，有较强的实践动手能力<br>-具有较强的分析问题和解决问题的能力，善于学习新事物<br>-能连续实习6个月以上的同学优先</p>
<h3 id="互联网数据研发部-数据挖掘工程师"><a href="#互联网数据研发部-数据挖掘工程师" class="headerlink" title="互联网数据研发部_数据挖掘工程师"></a>互联网数据研发部_数据挖掘工程师</h3><p>职位类别: 技术  发布时间: 2016-03-16<br>工作职责:<br>-负责百度搜索引擎基础数据挖掘核心技术研究和开发<br>-负责搜索引擎所覆盖到的网页、站点、媒体资源等数据分析和特征建模工作<br>-海量数据上的数据挖掘，研究网站、网页、链接的形态、特点和规律<br>-设计策略和算法，及分析系统的技术缺陷，对策略框架做出合理地调整或改进<br>-互联网资源特征数据挖掘，包括页面特征、站点结构，资源变化趋势等<br>-网页资源的解析提取，不同维度不同粒度的数据整合挖掘等<br>-信息提取、数据挖掘算法平台服务化等</p>
<p>职责要求:<br>-优秀的分析问题和解决问题的能力，对解决具有挑战性问题充满激情<br>-精通C/C++语言编程，熟悉linux平台、shell编程<br>-具有良好的沟通能力，和良好的团队合作精神<br>-搜索相关领域如页面解析/信息挖掘/统计分析工作经验、多语言研发经验优先<br>-有数据挖掘和平台服务化背景的优先<br>-计算机相关专业者优先，实习期不短于6个月，每周不少于4天</p>
<h3 id="2016春季实习生-机器学习-数据挖掘工程师（北京）"><a href="#2016春季实习生-机器学习-数据挖掘工程师（北京）" class="headerlink" title="2016春季实习生-机器学习/数据挖掘工程师（北京）"></a>2016春季实习生-机器学习/数据挖掘工程师（北京）</h3><p>发布时间: 2016-03-29<br>职责要求:<br>-2017年毕业在校生<br>-热爱互联网，对技术研究和应用抱有浓厚的兴趣，有强烈的上进心和求知欲，善于学习和运用新知识<br>-具有以下一个或多个领域的理论背景和实践经验：机器学习/数据挖掘/深度学习/信息检索/自然语言处理/机制设计/博弈论<br>-至少精通一门编程语言，熟悉网络编程、多线程、分布式编程技术，对数据结构和算法设计有较为深刻的理解<br>-良好的逻辑思维能力，对数据敏感，能够发现关键数据、抓住核心问题<br>-较强的沟通能力和逻辑表达能力，具备良好的团队合作精神和主动沟通意识<br>具有以下条件者优先：<br>-熟悉文本分类、聚类、机器翻译，有相关项目经验<br>-熟悉海量数据处理、最优化算法、分布式计算或高性能并行计算，有相关项目经验</p>
<h2 id="Sohu"><a href="#Sohu" class="headerlink" title="Sohu"></a>Sohu</h2><h3 id="汽车-大数据开发工程师"><a href="#汽车-大数据开发工程师" class="headerlink" title="汽车-大数据开发工程师"></a>汽车-大数据开发工程师</h3><p>所属公司：搜狐媒体所属部门：汽车总部工作地点： 北京市<br>职位描述：<br>搜狐汽车大数据分析平台的设计和开发。<br>任职资格：<br>1.熟练掌握Java/C++/Python之一，具备良好的编程素养；<br>2.熟练使用Hadoop，Hive，熟悉Map-Reduce；<br>3.具备海量数据处理和性能调优经验，有一定数据分析能力；<br>4.有大规模分布式数据框架项目经验优先；<br>5.积极主动责任心强，快速学习能力和良好沟通协调能力。</p>
<h3 id="搜狐媒体-新闻客户端-JAVA推荐研发工程师"><a href="#搜狐媒体-新闻客户端-JAVA推荐研发工程师" class="headerlink" title="搜狐媒体-新闻客户端-JAVA推荐研发工程师"></a>搜狐媒体-新闻客户端-JAVA推荐研发工程师</h3><p>所属公司：搜狐媒体所属部门：新闻客户端工作地点： 北京市<br>职位描述：</p>
<ol>
<li>负责大数据应用平台的研发和维护；</li>
<li>负责推荐系统线上平台的研发，负责算法的系统实现，开发客户端对推荐系统的各种业务需求；</li>
<li>提供高性能健壮稳定的云端大数据计算平台和存储平台。<br>任职资格：</li>
<li>热爱编程，对简单清晰、稳定高效的代码有执着的追求；</li>
<li>善于做程序设计，可以快速理解需求，洞察需求本质，给出合理的设计方案；</li>
<li>精通Java/Python等语言，研究过Netty/LevelDB/Hadoop/HBase/Storm等开源代码者优先；</li>
<li>具有个性化推荐系统研发相关项目开发经验者优先<h3 id="搜狐媒体-产品技术部-算法工程师"><a href="#搜狐媒体-产品技术部-算法工程师" class="headerlink" title="搜狐媒体-产品技术部-算法工程师"></a>搜狐媒体-产品技术部-算法工程师</h3>所属公司：搜狐媒体所属部门：产品技术部工作地点： 北京市<br>职位描述：<br>1．对内容文本进行语义分析；<br>2．对海量用户行为进行分析。<br>任职资格：<br>1．计算机相关专业本科及以上学历，具备扎实的数据结构和算法基础；<br>2．精通Java或Python，能熟练编写规范代码；<br>3．至少在以下一方面有深入研究或开发经验：数据挖掘/机器学习/自然语言处理；<br>4．优秀的分析和解决问题的能力，热衷于用数学思维分析实际问题，提出解决方案；<br>5．熟悉Linux开发环境；<br>6．具备以下经验者优先：UGC内容文本分析，推荐系统设计与开发。</li>
</ol>
<h2 id="乐视"><a href="#乐视" class="headerlink" title="乐视"></a>乐视</h2><h3 id="java开发工程师-集团大数据部"><a href="#java开发工程师-集团大数据部" class="headerlink" title="java开发工程师    集团大数据部"></a>java开发工程师    集团大数据部</h3><p>北京<br>岗位职责</p>
<ol>
<li>对海量数据进行分析、建模、挖掘，开发并优化大数据平台；</li>
<li>基于数据平台完成各类统计分析和开发任务；</li>
<li>掌握各种现有的大数据处理框架，根据需求进行代码的开发和维护。<br>职位描述</li>
<li>扎实的JAVA编程功底，掌握数据结构、算法等基础知识；</li>
<li>熟练掌握Ant或者Maven构 建工具；</li>
<li>掌握至少一种Web开发的常用框架；</li>
<li>熟悉Linux系统，能在Linux下进行开发；</li>
<li>有MapReduce，Storm，Spark等分布式开发经验者优先。</li>
</ol>
<h2 id="百分点"><a href="#百分点" class="headerlink" title="百分点"></a>百分点</h2><h3 id="数据挖掘工程师-1"><a href="#数据挖掘工程师-1" class="headerlink" title="数据挖掘工程师"></a>数据挖掘工程师</h3><p>岗位职责：<br>1、负责利用大数据相关技术对业务进行数据分析，挖掘产品特征、用户行为特征，构建用户精准运营的指标体系；<br>2、参与大数据平台的研发，包括数据抓取系统的使用和研发，在hadoop、storm、spark上进行算法开发。<br>职位要求：<br>1、两年以上工作经验；<br>2、熟悉数据挖掘、机器学习、推荐系统的理论（包括但不限于：聚类、回归、决策树、PCA、LSA、LDA、DNN、协同过滤等）；<br>3、熟悉大数据相关技术的原理及使用（包括但不限于：hadoop,hive,hbase,分布式内存数据库,storm,spark）；<br>4、熟练使用Java或者Python；<br>5、熟悉至少一门脚本语言（包括但不限于：shell,python)；<br>6、学习能力强，有激情，看好大数据行业。</p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 职业规划 </tag>
            
            <tag> 指导 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spark集群安装及配置]]></title>
      <url>/2016/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/spark-%E6%80%BB%E7%BB%93-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>主要介绍了spark的安装和配置，前提是hadoop集群以布置完成。<a id="more"></a></p>
<h2 id="scala的安装"><a href="#scala的安装" class="headerlink" title="scala的安装"></a>scala的安装</h2><p>下载的是scala-2.11.8.tgz</p>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>将下载的文件解压到<code>/usr/local/</code>目录下 ：<code>sudo tar -xzvf ~/Downloads/scala-2.11.8.tgz -C /usr/local</code><br>切换到创建的目录下 <code>cd /usr/local</code><br>看看有没有搞定： <code>ls</code><br>便于书写，我们需要对JDK的解压目录进行改名 <code>sudo mv scala-2.11.8 scala</code></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><h4 id="linux下"><a href="#linux下" class="headerlink" title="linux下"></a>linux下</h4><p>打开profile :<code>sudo vim /etc/profile</code></p>
<p>添加以下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#set scala env by wente</span><br><span class="line">export SCALA_HOME=/usr/local/scala</span><br><span class="line">export PATH=$PATH:$SCALA_HOME/bin</span><br></pre></td></tr></table></figure>
<p>保存退出。<code>:wq</code></p>
<p>使环境变量立即生效<code>source /etc/profile</code>保存设置，否则得重启才能生效</p>
<h4 id="zsh的情况下"><a href="#zsh的情况下" class="headerlink" title="zsh的情况下"></a>zsh的情况下</h4><p>~/.zshrc 中进行设置（<code>vim ~/.zshrc</code>，），在文件最前面加入如下单独一行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#set scala env by wente</span><br><span class="line">export SCALA_HOME=/usr/local/scala</span><br><span class="line">export PATH=$PATH:$SCALA_HOME/bin</span><br></pre></td></tr></table></figure>
<p>保存退出。然后 source!</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>scala -version</p>
<h2 id="spark的安装"><a href="#spark的安装" class="headerlink" title="spark的安装"></a>spark的安装</h2><p>步骤一样，</p>
<p>环境变量：</p>
<h3 id="配置环境变量-1"><a href="#配置环境变量-1" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><h4 id="linux下-1"><a href="#linux下-1" class="headerlink" title="linux下"></a>linux下</h4><p>打开profile :<code>sudo vim /etc/profile</code></p>
<p>添加以下配置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set spark env by wente</span></span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=/usr/<span class="built_in">local</span>/spark</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SPARK_HOME</span>/bin</span><br></pre></td></tr></table></figure>
<p>保存退出。<code>:wq</code></p>
<p>使环境变量立即生效<code>source /etc/profile</code>保存设置，否则得重启才能生效</p>
<h4 id="zsh的情况下-1"><a href="#zsh的情况下-1" class="headerlink" title="zsh的情况下"></a>zsh的情况下</h4><p>~/.zshrc 中进行设置（<code>vim ~/.zshrc</code>，），在文件最前面加入如下单独一行:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set spark env by wente</span></span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=/usr/<span class="built_in">local</span>/spark</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SPARK_HOME</span>/bin</span><br></pre></td></tr></table></figure>
<p>保存退出。然后 source!</p>
<h2 id="配置-Spark"><a href="#配置-Spark" class="headerlink" title="配置 Spark"></a>配置 Spark</h2><p>进入 Spark 的 conf 目录:</p>
<p>把 spark-env.sh.template 拷贝到 spark-env.sh:</p>
<p>添加：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set by wente for osx</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home</span><br><span class="line"><span class="built_in">export</span> SCALA_HOME=/usr/<span class="built_in">local</span>/scala</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_IP=10.5.57.180</span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_MEMORY=1g</span><br><span class="line"><span class="built_in">export</span> SPARK_LOCAL_DIRS=/usr/<span class="built_in">local</span>/spark</span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/usr/<span class="built_in">local</span>/hadoop</span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=/usr/<span class="built_in">local</span>/hadoop/etc/hadoop</span><br></pre></td></tr></table></figure></p>
<p>其中:<br>JAVA_HOME:指定的是 Java 的安装目录;(<strong>注意：不同机子可能在不用的地方</strong>)<br>SCALA_HOME:指定的是 Scala 的安装目录;<br>SPARK_MASTER_IP:指定的是 Spark 集群的 Master 节点的 IP 地址;<br>SPARK_WORKER_MEMOERY:指定的 Worker 节点能够最大分配给 Excutors 的内存大小, 因为我们的三台机器配置都是 2g,为了最充分的使用内存,这里设置为了 1g;（<strong>要注意机器的实际硬件条件，如果配置的超过当前Worker节点的硬件条件，Worker进程会启动失败。</strong>）<br>HADOOP_CONF_DIR:指定的是我们原来的 Hadoop 集群的配置文件的目录;</p>
<p>接下来配置 Spark 的 conf 下的 slaves 文件,删除<code>localhos</code>t把 Worker 节点都添加进去:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WenteMBP</span><br><span class="line">Slave1</span><br></pre></td></tr></table></figure></p>
<p>第四步:Slave1 和 Slave2 采用和 Master 完全一样的 Spark 安装配置,在此不再赘述。</p>
<h2 id="启动并查看集群的状况"><a href="#启动并查看集群的状况" class="headerlink" title="启动并查看集群的状况"></a>启动并查看集群的状况</h2><p>第一步:启动 Hadoop 集群</p>
<p>第二步:启动 Spark 集群</p>
<p>在 Hadoop 集群成功启动的基础上,启动 Spark 集群需要使用 Spark 的 sbin 目录下 <code>start-all.sh</code>(为了不hadoop冲突，spark的sbin环境变量不配置！)</p>
<p>此时使用 jps 发现我们在主节点正如预期一样出现了“Master”和“Worker”两个新进程!<br>此时的 Slave1 会出现新的进程“Worker”:</p>
<p>此时,我们可以进入 Spark 集群的 Web 页面,访问“<a href="http://WenteMBP:8080”" target="_blank" rel="noopener">http://WenteMBP:8080”</a>:</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Spark </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> 安装 </tag>
            
            <tag> saprk </tag>
            
            <tag> scala </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hadoop-总结-多个ssh解决方案]]></title>
      <url>/2016/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/Hadoop-%E6%80%BB%E7%BB%93-%E5%A4%9A%E4%B8%AAssh%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[SSH keys (简体中文)(<a href="https://wiki.archlinux.org/index.php/SSH_keys_(简体中文)/" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/SSH_keys_(简体中文)/</a>)<br><a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/" target="_blank" rel="noopener">GitHub Help: Generating a new SSH key and adding it to the ssh-agent</a><br><a href="http://yijiebuyi.com/blog/f18d38eb7cfee860c117d629fdb16faf.html" target="_blank" rel="noopener">一介布衣:同一台电脑关于多个SSH KEY管理</a></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Git&GitHub常用概念及操作指南]]></title>
      <url>/2016/03/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-GitAndGithub/</url>
      <content type="html"><![CDATA[<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>初始化一个Git仓库，使用git init命令。</p>
<p>添加文件到Git仓库，分两步：<a id="more"></a></p>
<p>第一步，使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</p>
<p>第二步，使用命令<code>git commit -m &quot;你的提交说明&quot;</code>，完成。</p>
<p><code>git status</code><br>命令可以让我们时刻掌握仓库当前的状态.</p>
<p><code>git diff</code><br>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词</p>
<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><h3 id="版本退回"><a href="#版本退回" class="headerlink" title="版本退回"></a>版本退回</h3><p><code>git log</code><br>命令显示从最近到最远的提交日志<br><code>git log --pretty=oneline</code> 只显示第一行，版本号，</p>
<p>版本表示的问题：<br>在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<p><code>git reset</code><br>版本退回操作<br><code>git reset --hard HEAD^</code>把当前版本回退到上一个版本<br>(只要上面的命令行窗口还没有被关掉，你就可以找到退回前的 的commit id是3628164…，于是就可以指定回到未来的某个版本：<code>git reset --hard 3628164</code>)</p>
<p><code>git reflog</code><br>用来记录你的每一次命令：以便确定要回到未来的哪个版本。显示的每行第一个数字就是：commit id 可以配合 reset使用，退回别的版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">ea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">3628164 HEAD@&#123;1&#125;: commit: append GPL</span><br></pre></td></tr></table></figure>
<p>ps:<br>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向上个版本。</p>
<h3 id="工作区-版本库概念"><a href="#工作区-版本库概念" class="headerlink" title="工作区,版本库概念"></a>工作区,版本库概念</h3><p>工作区（Working Directory）就是你在电脑里能看到的目录，比如<br>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p>
<p>git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p>
<h3 id="修改管理"><a href="#修改管理" class="headerlink" title="修改管理"></a>修改管理</h3><p>Git跟踪并管理的是修改，而非文件。Git中，每次修改，如果不add到暂存区，那就不会加入到commit中。这时使用commit是无效的。</p>
<p>用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p><code>git checkout -- file</code>可以丢弃工作区的修改，包括删除了的！(–很重要，没有–，就变成了“切换到另一个分支”的命令，)<br>这个命令只对工作区的有效，add的文件，需要先 reset回来。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>工作区直接删 <code>rm</code><br>版本库中删除该文件，那就用命令<code>git rm</code>删掉，然后<code>git commit</code><br>不知道这个文件班版本库中有没有？<code>git status</code>命令啊，<br>删错了？<code>git checkout -- file</code>一键还原</p>
<h2 id="远程库操作"><a href="#远程库操作" class="headerlink" title="远程库操作"></a>远程库操作</h2><h3 id="添加远程库及初始化"><a href="#添加远程库及初始化" class="headerlink" title="添加远程库及初始化"></a>添加远程库及初始化</h3><p><a href="">看上一篇blog</a></p>
<h3 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h3><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。<br><code>git clone git@github.com:michaelliao/gitskills.git</code><br>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建合并分支"><a href="#创建合并分支" class="headerlink" title="创建合并分支"></a>创建合并分支</h3><p>创建+切换dev分支： <code>git checkout -b dev</code> (加上-b参数表示创建并切换，相当于以下两条命令：)</p>
<p>查看当前分支：<code>git branch</code>：(命令会列出所有分支，当前分支前面会标一个*号。)</p>
<p>切换回master分支：<code>git checkout master</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除dev分支: <code>git branch -d dev</code></p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>用git log –graph命令可以看到分支合并图。</p>
<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>(请注意–no-ff参数，表示禁用Fast forward：)</p>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，master分支应该是非常稳定的，也就是**，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<p><code>git stash</code>可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p>
<p><code>git stash list</code>命令看看保存的工作现场存到哪了</p>
<p><code>git stash pop</code>，恢复的同时把stash内容也删了：</p>
<p>第二种恢复方法：<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p>
<p><strong>疑问</strong> dev分支中的bug怎么办？</p>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>多人协作的工作模式通常是这样：</p>
<ul>
<li><p>首先，可以试图用git push origin branch-name推送自己的修改；</p>
</li>
<li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>
</li>
<li><p>如果合并有冲突，则解决冲突，并在本地提交；</p>
</li>
<li><p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p>
</li>
<li><p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。</p>
</li>
</ul>
<p>查看远程库信息，使用<code>git remote -v</code></p>
<p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；（从远程库clone时，默认情况下，你只能看到本地的master分支，要在dev分支上开发，就必须创建远程origin的dev分支到本地）</p>
<p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；（不关联，git pull 会失败）</p>
<p>哪些分支需要推送，哪些不需要呢？</p>
<ul>
<li><p>master分支是主分支，因此要时刻与远程同步；</p>
</li>
<li><p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
</li>
<li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
</li>
<li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
</li>
</ul>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>标签也是版本库的一个快照。Git的标签其实它就是指向某个commit的指针（跟分支很像，但是分支可以移动，标签不可），所以，创建和删除标签都是瞬间完成的。</p>
<p>命令<code>git tag &lt;name&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p>
<p><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</p>
<p><code>git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以用PGP签名标签；</p>
<p>命令<code>git tag</code>可以查看所有标签。</p>
<p>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</p>
<p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p>
<p>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p>
<p>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p>
<p>注意：如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除</p>
<h2 id="git自定义配置"><a href="#git自定义配置" class="headerlink" title="git自定义配置"></a>git自定义配置</h2><p>，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。<br><code>.gitignore</code>文件本身要放到版本库里，并且可以对.gitignore做版<br>忽略文件的原则是：</p>
<p>忽略操作系统自动生成的文件，比如缩略图等；<br>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；<br>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</p>
<h3 id="别名配置"><a href="#别名配置" class="headerlink" title="别名配置"></a>别名配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line"></span><br><span class="line">//co表示checkout，ci表示commit，br表示branch</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br branch</span><br><span class="line"></span><br><span class="line">//配置一个git last，让其显示最后一次提交信息：</span><br><span class="line"><span class="meta">$</span> git config --global alias.last 'log -1'</span><br><span class="line"></span><br><span class="line">//lg</span><br><span class="line">git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span><br></pre></td></tr></table></figure>
<h3 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h3>]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> 快捷键 </tag>
            
            <tag> 使用 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> Git/GitHub </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hadoop配置文件的参数设定]]></title>
      <url>/2016/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/Hadoop-%E6%80%BB%E7%BB%93-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A/</url>
      <content type="html"><![CDATA[<h2 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h2><ol>
<li><code>fs.defaultFS</code><br>NameNode的URI 一般设定为：<code>hdfs://localhost:9000</code></li>
</ol>
<p>SequenceFile<a id="more"></a></p>
<h2 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h2><ol>
<li><code>dfs.namenode.secondary.http-address</code></li>
</ol>
<p>添加secondarynamenode的机器名  一般设定为：<code>{your_namenode_ip}:50070</code></p>
<ol>
<li><p><code>dfs.replication</code><br>首先 dfs.replication这个参数是个client参数，即node level参数。需要在每台datanode上设置。<br>其实默认为3个副本已经够用了，设置太多也没什么用。<br>一个文件，上传到hdfs上时指定的是几个副本就是几个。以后你修改了副本数，对已经上传了的文件也不会起作用。</p>
</li>
<li><p><code>dfs.namenode.name.dir</code><br>If this is a comma-delimited list of directories then the name table is replicated in all of the directories, for redundancy.<br>不过若没有配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 /tmp/hadoo-hadoop，而这个目录在重启时有可能被系统清理掉，导致必须重新执行 format 才行。所以我们进行了设置，同时也指定 dfs.namenode.name.dir 和 dfs.datanode.data.dir，否则在接下来的步骤中可能会出错。</p>
</li>
<li><p><code>dfs.datanode.data.dir</code><br>同上</p>
</li>
</ol>
<h2 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h2><ol>
<li><p><code>mapreduce.framework.name</code><br>一般设定为：<code>yarn</code>     Execution framework set to Hadoop YARN.</p>
</li>
<li><p><code>mapreduce.jobhistory.addres</code>s<br>一般设定为：<code>WenteMBP:10020</code><br>MapReduce JobHistory Server host:port    Default port is 10020.</p>
</li>
<li><p><code>apreduce.jobhistory.webapp.address</code><br>一般设定为：<code>WenteMBP:19880</code><br>MapReduce JobHistory Server Web UI host:port    Default port is 19888.</p>
</li>
</ol>
<h2 id="mapred-site-xml-1"><a href="#mapred-site-xml-1" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h2><ol>
<li><p><code>yarn.resourcemanager.hostname</code><br>ResourceManager host.<br>host Single hostname that can be set in place of setting all yarn.resourcemanager*address resources. Results in default ports for ResourceManager components.</p>
</li>
<li><p><code>yarn.nodemanager.aux-services</code><br>一般设定为：<code>mapreduce_shuffle</code><br>NodeManager上运行的附属服务。需配置成<code>mapreduce_shuffle</code>，才可运行MapReduce程序<br>默认值：“”</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> hadoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> hadoop </tag>
            
            <tag> 安装 </tag>
            
            <tag> 参数 </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hadoop伪分布安装配置]]></title>
      <url>/2016/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/Hadoop-%E6%80%BB%E7%BB%93-%E5%8D%95%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97/</url>
      <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="vim的安装"><a href="#vim的安装" class="headerlink" title="vim的安装"></a>vim的安装</h3><p>if ubuntu默认没有安装vim ：解决：<br>命令行输入：<code>sudo apt-get install vim</code>　　然后安装，出现确认的时候，输入y确认就行<a id="more"></a></p>
<h3 id="更新apts"><a href="#更新apts" class="headerlink" title="更新apts"></a>更新apts</h3><p><code>sudo apt-get update</code></p>
<h2 id="安装SSH、配置SSH无密码登陆"><a href="#安装SSH、配置SSH无密码登陆" class="headerlink" title="安装SSH、配置SSH无密码登陆"></a>安装SSH、配置SSH无密码登陆</h2><p>Ubuntu 默认已安装了 SSH client，此外还需要安装 SSH server</p>
<p><code>sudo apt-get install openssh-server</code></p>
<p>安装后，可以使用如下命令登陆本机：<br><code>ssh localhost</code> 输入 yes 。然后按提示输入密码</p>
<p>为了方便，配置成SSH无密码登陆：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exit                           # 退出刚才的 ssh localhost</span><br><span class="line">cd ~/.ssh/                     # 若没有该目录，请先执行一次ssh localhost</span><br><span class="line">ssh-keygen -t rsa              # 会有提示，都按回车就可以</span><br><span class="line">cat ./id_rsa.pub &gt;&gt; ./authorized_keys  # 加入授权</span><br></pre></td></tr></table></figure>
<p>再用 <code>ssh localhost</code>命令，无需输入密码就可以直接登陆了(成功！)</p>
<h2 id="java的安装"><a href="#java的安装" class="headerlink" title="java的安装"></a>java的安装</h2><p>下载的是java version 1.8.0_73 （感觉太新了，可能有不兼容！）</p>
<h2 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h2><p><code>scp ./jdk-8u73-linux-x64.tar.gz Slave1:/home/wente</code></p>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>创建目录:<code>sudo mkdir /usr/java</code><br>将下载的文件解压到<code>/usr/java</code>目录下 ：<code>sudo tar -zxvf jdk-7u11-linux-i586.tar.gz -C /usr/java</code><br>切换到创建的目录下 <code>cd /usr/java/</code><br>看看有没有搞定： <code>ls</code><br>便于书写，我们需要对JDK的解压目录进行改名 <code>sudo mv jdk1.8.0_73 java8</code></p>
<h3 id="配置环境变量-linux"><a href="#配置环境变量-linux" class="headerlink" title="配置环境变量(linux)"></a>配置环境变量(linux)</h3><p>打开profile :<code>sudo vim /etc/profile</code></p>
<p>添加以下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#set java env by wente</span><br><span class="line">export JAVA_HOME=/usr/java/java8</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br></pre></td></tr></table></figure>
<p>保存退出。<code>:wq</code></p>
<p>使环境变量立即生效<code>source /etc/profile</code>保存设置，否则得重启才能生效<br>ja</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>java<br>javac<br>java -version</p>
<h2 id="hadoop单机的安装"><a href="#hadoop单机的安装" class="headerlink" title="hadoop单机的安装"></a>hadoop单机的安装</h2><h3 id="创建hadoop用户"><a href="#创建hadoop用户" class="headerlink" title="创建hadoop用户"></a>创建hadoop用户</h3><p>输入如下命令创建新用户 :<br><code>sudo useradd -m hadoop -s /bin/bash</code>这条命令创建了可以登陆的 hadoop 用户，并使用 /bin/bash 作为 shell。</p>
<p>使用如下命令设置密码，按提示输入两次密码：<br><code>sudo passwd hadoop</code></p>
<p>hadoop 用户增加管理员权限，方便部署，避免一些对新手来说比较棘手的权限问题：<br><code>sudo adduser hadoop sudo</code></p>
<h3 id="hadoop安装"><a href="#hadoop安装" class="headerlink" title="hadoop安装"></a>hadoop安装</h3><p>下载 <code>hadoop-2.7.2.tar.gz</code><br>我们选择将 Hadoop 安装至 <code>/usr/local/</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxf /media/psf/LinuxShar/hadoop-2.7.2-src.tar.gz -C /usr/<span class="built_in">local</span>    <span class="comment"># 解压到/usr/local中</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">sudo mv ./hadoop-2.7.2/ ./hadoop            <span class="comment"># 将文件夹名改为hadoop</span></span><br><span class="line">sudo chown -R hadoop:hadoop ./hadoop        <span class="comment"># 修改文件权限</span></span><br></pre></td></tr></table></figure>
<p>输入如下命令来检查 Hadoop 是否可用，成功则会显示 Hadoop 版本信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/hadoop</span><br><span class="line">./bin/hadoop version</span><br></pre></td></tr></table></figure>
<h2 id="hadoop单机配置-伪分布式"><a href="#hadoop单机配置-伪分布式" class="headerlink" title="hadoop单机配置(伪分布式)"></a>hadoop单机配置(伪分布式)</h2><p>Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。</p>
<p>Hadoop 的配置文件位于 <code>/usr/local/hadoop/etc/hadoop/</code> 中，伪分布式需要修改2个配置文件 core-site.xml 和 hdfs-site.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。</p>
<p>修改配置文件core-site.xml 将当中的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改为下面配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同样的，修改配置文件 hdfs-site.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置完成后，执行 NameNode 的格式化:</p>
<p><code>./bin/hdfs namenode -format</code></p>
<p>成功的话，会看到 “successfully formatted” 和 “Exitting with status 0” 的提示，若为 “Exitting with status 1” 则是出错。</p>
<p>接着开启 NameNode 和 DataNode 守护进程。</p>
<p><code>./sbin/start-dfs.sh</code></p>
<p>Shell 命令<br>若出现如下SSH提示，输入yes即可。</p>
<p>启动完成后，可以通过命令 <code>jps</code>来判断是否成功启动，</p>
<p>若成功启动则会列出如下进程: “NameNode”、”DataNode” 和 “SecondaryNameNode”（如果 SecondaryNameNode 没有启动，请运行 sbin/stop-dfs.sh 关闭进程，然后再次尝试启动尝试）。如果没有 NameNode 或 DataNode ，那就是配置不成功，请仔细检查之前步骤，或通过查看启动日志排查原因。</p>
<h3 id="启动YARN（完全启动）"><a href="#启动YARN（完全启动）" class="headerlink" title="启动YARN（完全启动）"></a>启动YARN（完全启动）</h3><p>首先修改配置文件 <code>mapred-site.xml</code>，这边需要先进行重命名：</p>
<p><code>mv ./etc/hadoop/mapred-site.xml.template ./etc/hadoop/mapred-site.xml</code></p>
<p>然后再进行编辑:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着修改配置文件 yarn-site.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后就可以启动 YARN 了（需要先执行过 ./sbin/start-dfs.sh）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-yarn.sh      # 启动YARN</span><br><span class="line">./sbin/mr-jobhistory-daemon.sh start historyserver  # 开启历史服务器，才能在Web中查看任务运行情况</span><br></pre></td></tr></table></figure>
<h3 id="hadoop环境变量配置"><a href="#hadoop环境变量配置" class="headerlink" title="hadoop环境变量配置"></a>hadoop环境变量配置</h3><h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><p>打开profile :<code>sudo vim /etc/profile</code></p>
<p>添加以下配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> hadoop env by wente</span></span><br><span class="line">export PATH=$PATH:/usr/local/hadoop/sbin:/usr/local/hadoop/bin</span><br></pre></td></tr></table></figure>
<p>保存退出。<br>使环境变量立即生效<code>source /etc/profile</code>保存设置，否则得重启才能生效</p>
<p>生效后，在任意目录中，都可以直接使用<code>hdfs</code> 等命令了，读者不妨现在就执行 hdfs dfs -ls input 查看 HDFS 文件试试看。</p>
<h4 id="zsh的情况下"><a href="#zsh的情况下" class="headerlink" title="zsh的情况下"></a>zsh的情况下</h4><p>~/.zshrc 中进行设置（<code>vim ~/.zshhrc</code>，与 JAVA_HOME 的设置相似），在文件最前面加入如下单独一行:</p>
<p><code>export PATH=$PATH:/usr/local/hadoop/sbin:/usr/local/hadoop/bin</code></p>
<p>保存退出。然后 source!</p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="RPM、tar-gz、DEB格式软件包的区别"><a href="#RPM、tar-gz、DEB格式软件包的区别" class="headerlink" title="RPM、tar.gz、DEB格式软件包的区别"></a>RPM、tar.gz、DEB格式软件包的区别</h3><p>RPM包在红帽Linux、SUSE、Fedora可以直接进行安装，但在Ubuntu中却无法识别；</p>
<p>DEB包应该是Ubuntu的专利，在Ubuntu中双击DEB包就可以进入自动安装进程；</p>
<p>tar.gz包在所有的Linux版本中都能使用，但安装过程也最麻烦。要先解压缩，然后在“终端”里用cd 命令进入刚才解压的目录，再找到安装链接文件安装。tar.gz就是用tar和gzip压缩后的文件扩展名。 用winzip或winrar就可以打开。</p>
<h3 id="tar命令的操作"><a href="#tar命令的操作" class="headerlink" title="tar命令的操作"></a>tar命令的操作</h3><p>查看<br><code>tar -tf aaa.tar.gz</code>  在不解压的情况下查看压缩包的内容<br>解压：<br>1、<code>*.tar</code> 用 tar –xvf 解压<br>2、<code>*.gz</code> 用 gzip -d或者gunzip 解压<br>3、<code>*.tar.gz和*.tgz</code>用 tar –xzf 解压<br>4、<code>*.bz2</code> 用 bzip2 -d或者用bunzip2 解压<br>5、<code>*.tar.bz2</code>用tar –xjf 解压<br>6、<code>*.Z</code> 用 uncompress 解压<br>7、<code>*.tar.Z</code> 用tar –xZf 解压</p>
<h3 id="什么是-YARN"><a href="#什么是-YARN" class="headerlink" title="什么是 YARN"></a>什么是 YARN</h3><p>新版的 Hadoop 使用了新的 MapReduce 框架（MapReduce V2，也称为 YARN，Yet Another Resource Negotiator）。</p>
<p>YARN 是从 MapReduce 中分离出来的，负责资源管理与任务调度。YARN 运行于 MapReduce 之上，提供了高可用性、高扩展性，YARN 的更多介绍在此不展开，有兴趣的可查阅相关资料。</p>
<h3 id="ntp的安装（可以不装，只是测试用）"><a href="#ntp的安装（可以不装，只是测试用）" class="headerlink" title="ntp的安装（可以不装，只是测试用）"></a>ntp的安装（可以不装，只是测试用）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src    &lt;==切换目录</span><br><span class="line">tar -zxvf /root/ntp-4.2.8p3.tar.gz   &lt;==解压缩到此目录</span><br><span class="line">./configure --prefix=/usr/local/ntp --enable-all-clocks --enable-parse-clocks   &lt;==开始建立makefile</span><br><span class="line">make clean; make</span><br><span class="line">make check</span><br><span class="line">make install &lt;==安装</span><br></pre></td></tr></table></figure>
<p>为安装到单独目录的软体之man page加入man path搜寻：<br>可能就得要在<code>/etc/manpath.config</code> 内的40~50行左右处，写入如下的一行：<br><code>MANPATH_MAP /usr/local/software/bin /usr/local/software/man</code></p>
<h3 id="虚拟机文件的共享"><a href="#虚拟机文件的共享" class="headerlink" title="虚拟机文件的共享"></a>虚拟机文件的共享</h3><p>如果在屏幕顶部可以看见 Parallels Desktop 菜单栏，请选择 <code>虚拟机 &gt; 配置</code>。选择以下其中一种方法：</p>
<ul>
<li>要只共享 Home 文件夹中的文件夹，请从 共享文件夹 菜单中选择 仅 Home 文件夹。</li>
<li>要共享所有的 Mac OS X 文件夹，请从 共享文件夹 菜单中选择 所有磁盘。</li>
<li>要共享您选择的文件夹，请点击 自定义文件夹 并点击添加 (+)按钮，然后选择您想要共享的文件夹。您可以通过再次点击 (+) 按钮添加更多的文件夹。</li>
</ul>
<p>如果您正在使用 Linux，共享文件夹将被挂载到 <code>/media/psf</code> 或 <code>/mnt/psf</code> 目录。</p>
<h3 id="U盘的挂载"><a href="#U盘的挂载" class="headerlink" title="U盘的挂载"></a>U盘的挂载</h3><ol>
<li><p>挂载U盘需要有管理员的权限。</p>
</li>
<li><p>先在 <code>/mnt</code> 下建立一个名叫USB的文件夹，文件夹名称随意：<code>mkdir /mnt/USBTEST</code>.</p>
</li>
<li><p>然后输入：<code>fdisk –l</code> 查看一下磁盘分区情况：</p>
</li>
<li><p>然后将U盘插入电脑的USB接口，再输入：<code>fdisk –l</code>查看一下磁盘分区的变化情况，我们可以在下图中看到多出了一个 <code>/dev/sdb2</code>的分区，这个就是刚才插入的U盘设备</p>
</li>
<li><p>开始挂载U盘设备，输入：<code>mount –t vfat /dev/sdb2 /mnt/USBTEST</code></p>
</li>
<li><p>挂载成功后，我们查看一下U盘里的文件：<code>ls –la /mnt/USBTEST</code></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> hadoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> hadoop </tag>
            
            <tag> linux </tag>
            
            <tag> 安装 </tag>
            
            <tag> 单机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Algorithms-笔记-无向图性质及实现]]></title>
      <url>/2016/03/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E7%AC%94%E8%AE%B0-%E6%97%A0%E5%90%91%E5%9B%BE/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<h2 id="无向图的基本概念"><a href="#无向图的基本概念" class="headerlink" title="无向图的基本概念"></a>无向图的基本概念</h2><ul>
<li>边</li>
<li>顶点</li>
<li>自环</li>
<li>平行边</li>
<li>多重图</li>
<li>简单图</li>
<li>顶点的度数</li>
<li>路径</li>
<li>简单路径</li>
<li>环</li>
<li>简单环</li>
<li>路径/环的长度</li>
<li>连通的</li>
<li>连通图</li>
<li>无环图</li>
<li>森林</li>
<li>生成树</li>
</ul>
<p>图和树的关系（什么样的图一棵树）。满足5个条件之一：</p>
<p>稀疏图和稠密图的区别：</p>
<h2 id="最常用的图和处理代码"><a href="#最常用的图和处理代码" class="headerlink" title="最常用的图和处理代码"></a>最常用的图和处理代码</h2><h3 id="计算V的度数"><a href="#计算V的度数" class="headerlink" title="计算V的度数"></a>计算V的度数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">degree</span> <span class="params">(Grgaph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> degree = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">		degree++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> degree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算计算所有顶点的最大度数"><a href="#计算计算所有顶点的最大度数" class="headerlink" title="计算计算所有顶点的最大度数"></a>计算计算所有顶点的最大度数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDegree</span> <span class="params">(Grgaph G)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V();	v++ ) &#123;</span><br><span class="line">		<span class="keyword">if</span> (degree(G, v) &gt; max) &#123;</span><br><span class="line">			max = degree(G,v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算所有顶点的平均度数"><a href="#计算所有顶点的平均度数" class="headerlink" title="计算所有顶点的平均度数"></a>计算所有顶点的平均度数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">avgDegree</span><span class="params">(Grgaph G)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2.0</span> * G.E() / G.V(); <span class="comment">//握手定理：Degree = 2 * E</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算自环的个数"><a href="#计算自环的个数" class="headerlink" title="计算自环的个数"></a>计算自环的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfSelfLoops</span><span class="params">(Grgaph G )</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V ; v++	) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> w  : G.adj(v)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v == w) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string-representation-of-the-graph’s-adjacency-lists"><a href="#string-representation-of-the-graph’s-adjacency-lists" class="headerlink" title="string representation of the graph’s adjacency lists"></a>string representation of the graph’s adjacency lists</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	String s = V + <span class="string">"vertices, "</span> + E + <span class="string">" edges\n"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">		s += v + <span class="string">": "</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> w  : <span class="keyword">this</span>.adj(v)) &#123;</span><br><span class="line">			s += w + <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		s += <span class="string">" \n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 无向图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hadoop集群安装配置]]></title>
      <url>/2016/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/Hadoop-%E6%80%BB%E7%BB%93-hadoop%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>Hadoop 集群的安装配置大致为如下流程:</p>
<p>选定一台机器作为 Master<br>在 Master 节点上配置 hadoop 用户、安装 SSH server、安装 Java 环境<br>在 Master 节点上安装 Hadoop，并完成配置<br>在其他 Slave 节点上配置 hadoop 用户、安装 SSH server、安装 Java 环境<br>将 Master 节点上的 /usr/local/hadoop 目录复制到其他 Slave 节点上<br>在 Master 节点上开启 Hadoop<a id="more"></a></p>
<h3 id="计算机命名"><a href="#计算机命名" class="headerlink" title="计算机命名"></a>计算机命名</h3><p>为了便于区分，可以修改各个节点的主机名（在终端标题、命令行中可以看到主机名，以便区分）：<br>Linux 中：<code>sudo vim /etc/hostname</code><br>在osx 中 ： <code>System Preference -&gt; Sharing -&gt; Computer Name</code></p>
<p>修改完成后需要<strong>重启</strong>一下，重启后在终端中才会看到机器名的变化。接下来的教程中请注意区分 Master（WenteMBP） 节点与 Slave 节点的操作。</p>
<h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>Linux 中查看节点 IP 地址的命令为 <code>ifconfig</code><br>找到了每个结点对应IP后，然后执行如下命令修改自己所用节点的IP映射：<code>sudo vim /etc/hosts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># hadoop</span><br><span class="line">10.5.57.180 WenteMBP</span><br><span class="line">10.211.55.14 Slave1</span><br></pre></td></tr></table></figure>
<p>我们在 <code>/etc/hosts</code> 中将该映射关系填写上去即可，如下图所示（一般该文件中只有一个 127.0.0.1，其对应名为 localhost，如果有多余的应删除，特别是不能有 “127.0.0.1 WenteMBP” 这样的记录）.</p>
<p>需要在所有节点上完成网络配置:如上面讲的是 Master(WenteMBP )节点的配置，而在其他的 Slave 节点上，也要对 <code>/etc/hostname</code>（修改为 Slave1、Slave2 等） 和 <code>/etc/hosts</code>（跟 Master 的配置一样）这两个文件进行修改.</p>
<h3 id="检查网络配置情况"><a href="#检查网络配置情况" class="headerlink" title="检查网络配置情况"></a>检查网络配置情况</h3><p>配置好后需要在各个节点上执行如下命令，测试是否相互 ping 得通，如果 ping 不通，后面就无法顺利配置成功：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping WenteMBP -c 3   # 只ping 3次，否则要按 Ctrl+c 中断</span><br><span class="line">ping Slave1 -c 3</span><br></pre></td></tr></table></figure>
<h3 id="SSH-密钥分发"><a href="#SSH-密钥分发" class="headerlink" title="SSH 密钥分发"></a>SSH 密钥分发</h3><p>这个是很容易出错的地方，这个<strong>授权是相互的</strong>!</p>
<p>这个操作是要让 Master 节点可以无密码 SSH 登陆到各个 Slave 节点上。</p>
<p>首先生成 Master 节点的公匙，在 Master 节点的终端中执行（因为改过主机名，所以还需要删掉原有的再重新生成一次）：<a href="">具体操作请看上一篇blog</a></p>
<p>完成后可执行 <code>ssh WenteMBP</code> 验证一下（可能需要输入 yes，成功后执行 exit 返回原来的终端）。接着在 WenteMBP 节点将上公匙传输到 Slave1 节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~/.ssh/id_rsa.pub wente@Slave1:/home/hadoop/</span><br></pre></td></tr></table></figure>
<p>接着在 Slave1 节点上，将 ssh 公匙加入授权：</p>
<p><code>cat /media/psf/LinuxShar/authorized_keys\ copy  &gt;&gt; ~/.ssh/authorized_keys</code>（我的是id_rsa.pub 是放在虚拟机共享盘中的，源地址和别人的可能不一样.）</p>
<p>同理，将Slave1的公钥授权给WenteMBP!</p>
<h3 id="授权的权限修改（这步可有可无）"><a href="#授权的权限修改（这步可有可无）" class="headerlink" title="授权的权限修改（这步可有可无）"></a>授权的权限修改（这步可有可无）</h3><p>在验证前，需要做两件事儿。第一件事儿是修改文件”<code>authorized_keys</code>“权限（权限的设置非常重要，因为不安全的设置安全设置，会让你不能使用RSA功能），另一件事儿是用root用户设置”<code>/etc/ssh/sshd_config</code>“的内容。使其无密码登录有效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">RSAAuthentication yes</span><br><span class="line"></span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line">AuthorizedKeysFile    .ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>
<p>然后再通过chmod命令给该文件赋值权限<br><code>chmod 600 authorized_keys</code></p>
<h3 id="shh登录的验证"><a href="#shh登录的验证" class="headerlink" title="shh登录的验证"></a>shh登录的验证</h3><p>这样，在 Master 节点上就可以无密码 SSH 到各个 Slave 节点了，可在 Master 节点上执行如下命令进行检验，如下图所示：</p>
<p><code>ssh Slave1</code></p>
<p>如果出现以下错误提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">The ECDSA host key for slave1 has changed,</span><br><span class="line">and the key for the corresponding IP address 10.211.55.14</span><br><span class="line">is unchanged. This could either mean that</span><br><span class="line">DNS SPOOFING is happening or the IP address for the host</span><br><span class="line">and its host key have changed at the same time.</span><br><span class="line">Offending key for IP in /Users/wente/.ssh/known_hosts:11</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the ECDSA key sent by the remote host is</span><br><span class="line">SHA256:S9EhCzYP0GlDf+Rj5Ke+a2iDiY1vZjn4w8jlDtFyEn0.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /Users/wente/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending ECDSA key in /Users/wente/.ssh/known_hosts:9</span><br><span class="line">ECDSA host key for slave1 has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br><span class="line">lost connection</span><br></pre></td></tr></table></figure>
<p>那就删除<code>/.ssh/known_hosts</code>中slave1相关的条目就可以了。</p>
<h2 id="配置集群-分布式环境"><a href="#配置集群-分布式环境" class="headerlink" title="配置集群/分布式环境"></a>配置集群/分布式环境</h2><p>集群/分布式模式需要修改<code>/usr/local/hadoop/etc/hadoop</code> 中的5个配置文件。<br>正常启动所必须的设置项： <code>slaves、core-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xml</code>。</p>
<h3 id="slaves"><a href="#slaves" class="headerlink" title="slaves"></a>slaves</h3><p>将作为 DataNode 的主机名写入该文件，每行一个，默认为 localhost，所以在伪分布式配置时，节点即作为 NameNode 也作为 DataNode。分布式配置可以保留 localhost，也可以删掉，让 Master 节点仅作为 NameNode 使用。</p>
<h3 id="文件-core-site-xml-改为下面的配置："><a href="#文件-core-site-xml-改为下面的配置：" class="headerlink" title="文件 core-site.xml 改为下面的配置："></a>文件 core-site.xml 改为下面的配置：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://WenteMBP:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="文件-hdfs-site-xml-改为下面的配置"><a href="#文件-hdfs-site-xml-改为下面的配置" class="headerlink" title="文件 hdfs-site.xml 改为下面的配置"></a>文件 hdfs-site.xml 改为下面的配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>WenteMBP:50090<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="文件-mapred-site-xml-改为下面的配置"><a href="#文件-mapred-site-xml-改为下面的配置" class="headerlink" title="文件 mapred-site.xml 改为下面的配置"></a>文件 mapred-site.xml 改为下面的配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>WenteMBP:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>WenteMBP:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="文件-yarn-site-xml-改为下面的配置"><a href="#文件-yarn-site-xml-改为下面的配置" class="headerlink" title="文件 yarn-site.xml 改为下面的配置"></a>文件 yarn-site.xml 改为下面的配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>WenteMBP<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>配置好后，将 Master 上的 /usr/local/Hadoop 文件夹复制到各个节点上就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">tar -zcf ~/hadoop.master.tar.gz ./hadoop # 先压缩再复制</span><br><span class="line">cd ~</span><br><span class="line">scp ./hadoop.master.tar.gz Slave1:/home/wente</span><br></pre></td></tr></table></figure></p>
<p>因为之前有跑过伪分布式模式，建议在切换到集群模式前先删除之前的临时文件。在 Master(WenteMBP) 节点上执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">sudo rm -r ./hadoop/tmp     # 删除 Hadoop 临时文件</span><br><span class="line">sudo rm -r ./hadoop/logs/*   # 删除日志文件</span><br><span class="line">tar -zcf ~/hadoop.master.tar.gz ./hadoop   # 先压缩再复制</span><br><span class="line">cd ~</span><br><span class="line">scp ./hadoop.master.tar.gz Slave1:/home/wente</span><br></pre></td></tr></table></figure>
<p>在 Slave1 节点上执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -r /usr/local/hadoop    # 删掉旧的（如果存在）</span><br><span class="line">sudo tar -zxf ~/hadoop.master.tar.gz -C /usr/local</span><br><span class="line">sudo chown -R wente:wente /usr/local/hadoop  #这步很重要，不设置的话，master无法调用</span><br></pre></td></tr></table></figure>
<h2 id="启动及问题"><a href="#启动及问题" class="headerlink" title="启动及问题"></a>启动及问题</h2><p>首次启动需要先在 Master(WenteMBP) 节点执行 NameNode 的格式化：<code>hdfs namenode -format</code></p>
<p>接着可以启动 hadoop 了，启动需要在 Master(WenteMBP) 节点上进行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start-all.sh</span><br><span class="line">mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure>
<p>通过命令 <code>jps</code>可以查看各个节点所启动的进程。正确的话，在 Master 节点上可以看到如下所示(数字 不一样，注意进程)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10352 NameNode</span><br><span class="line">10802 NodeManager</span><br><span class="line">10451 DataNode</span><br><span class="line">10569 SecondaryNameNode</span><br><span class="line">10700 ResourceManager</span><br><span class="line">10862 Jps</span><br><span class="line">9630 JobHistoryServer</span><br></pre></td></tr></table></figure>
<p>在 Slave 节点可以看到 DataNode 和 NodeManager 进程，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wente@Slave1:~$ jps</span><br><span class="line">23992 DataNode</span><br><span class="line">24168 NodeManager</span><br><span class="line">24987 Jps</span><br></pre></td></tr></table></figure>
<p>缺少任一进程都表示出错。另外还需要在 Master 节点上通过命令<code>hdfs dfsadmin -report</code> 查看 DataNode 是否正常启动，如果 Live datanodes 不为 0 ，则说明集群启动成功。</p>
<p>也可以通过 Web 页面看到查看 DataNode 和 NameNode 的状态：<a href="http://wenteMBP:50070/" target="_blank" rel="noopener">http://wenteMBP:50070/</a>。如果不成功，可以通过启动日志排查原因。</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>Shell 命令<br>scp 是 secure copy 的简写，用于在 Linux 下进行远程拷贝文件，类似于 cp 命令，不过 cp 只能在本机中拷贝。执行 scp 时会要求输入 Slave1 上 hadoop 用户的密码(hadoop)，输入完成后会提示传输完毕.</p>
]]></content>
      
        <categories>
            
            <category> hadoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> hadoop </tag>
            
            <tag> linux </tag>
            
            <tag> 安装 </tag>
            
            <tag> 集群 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Eclipse安装Hadoop-Eclipse-Plugin]]></title>
      <url>/2016/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7/Hadoop-%E6%80%BB%E7%BB%93-%20Hadoop-Eclipse-Plugin%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="安装-Hadoop-Eclipse-Plugin"><a href="#安装-Hadoop-Eclipse-Plugin" class="headerlink" title="安装 Hadoop-Eclipse-Plugin"></a>安装 Hadoop-Eclipse-Plugin</h3><p>要在 Eclipse 上编译和运行 MapReduce 程序，需要安装 hadoop-eclipse-plugin，可下载 Github 上的 <a href="https://github.com/winghc/hadoop2x-eclipse-plugin" target="_blank" rel="noopener">hadoop2x-eclipse-plugin</a></p>
<p>下载后，将 release 中的 <code>hadoop-eclipse-kepler-plugin-2.6.0.jar</code> （还提供了 2.2.0 和 2.4.1 版本）复制到 Eclipse 安装目录的 <code>plugins</code> 文件夹中，重启 Eclipse 即可（添加插件后只需要运行一次该命令，以后按照正常方式启动就行了）。<a id="more"></a></p>
<h3 id="配置-Hadoop-Eclipse-Plugin"><a href="#配置-Hadoop-Eclipse-Plugin" class="headerlink" title="配置 Hadoop-Eclipse-Plugin"></a>配置 Hadoop-Eclipse-Plugin</h3><p>在配置前请确保已经开启了 Hadoop。</p>
<p>启动 Eclipse 后确认可以在左侧的Project Explorer中看到<code>DFS Locations</code></p>
<p>插件需要进一步的配置。</p>
<p><code>1. 选择 Eclipse 菜单下的 Preference。
此时会弹出一个窗体，窗体的左侧会多出 Hadoop Map/Reduce 选项，点击此选项，选择 Hadoop 的安装目录（如我的 ：</code>/usr/local/hadoop`，直接输入就行）。</p>
<ol>
<li><p>切换 Map/Reduce 开发视图，选择 Window 菜单下选择 <code>Open Perspective -&gt; Other</code>，弹出一个窗体，从中选择 <code>Map/Reduce</code>选项即可进行切换。</p>
</li>
<li><p>建立与 Hadoop 集群的连接，点击 Eclipse软件右下角的 Map/Reduce Locations 面板，在面板中单击右键，选择 New Hadoop Location。</p>
</li>
</ol>
<p>在弹出来的 General 选项面板中，General 的设置要与 Hadoop 的配置一致。一般两个 Host 值是一样的，如果是伪分布式，填写 localhost 即可，另外我使用的Hadoop伪分布式配置，设置 <code>fs.defaultFS</code> 为 <code>hdfs://localhost:9000</code>，则 DFS Master 的 Port 要改为 <code>9000</code>。Map/Reduce(V2) Master 的 <code>Port</code> 用默认的即可，<code>Location Name</code> 随意填写。</p>
<h3 id="在-Eclipse-中创建-MapReduce-项目"><a href="#在-Eclipse-中创建-MapReduce-项目" class="headerlink" title="在 Eclipse 中创建 MapReduce 项目"></a>在 Eclipse 中创建 MapReduce 项目</h3><p>这个和普通的程序没有什么区别了，主要是选项不一样</p>
<h3 id="在-Eclipse-中运行-MapReduce-程序会遇到的问题"><a href="#在-Eclipse-中运行-MapReduce-程序会遇到的问题" class="headerlink" title="在 Eclipse 中运行 MapReduce 程序会遇到的问题"></a>在 Eclipse 中运行 MapReduce 程序会遇到的问题</h3>]]></content>
      
        <categories>
            
            <category> hadoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Eclipse </tag>
            
            <tag> 配置 </tag>
            
            <tag> hadoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[KMP算法及DFA的理解]]></title>
      <url>/2016/03/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E7%AC%94%E8%AE%B0-KMP%E7%AE%97%E6%B3%95%E5%8F%8ADFA%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<h2 id="暴力查找法与KMP"><a href="#暴力查找法与KMP" class="headerlink" title="暴力查找法与KMP"></a>暴力查找法与KMP</h2><p>暴力的字符串查找算法使用的是暴力搜索，：<br>假设要处理的文本字符串为s，要在其中查找字符串p（也称为模式字符串）。<br>先将s与p的首字符对齐，然后一个字符一个字符的对比，如果到某个字符不一样，就将p字符串右移一位，然后s与p的字符指针回退到新的对齐的位置，重新开始对比。</p>
<p>KMP与暴力查找不同的就是避免将指针回退到所有的字符之前。<br>它是用一个dfa数组（有地方叫做Next数组）来指示匹配失败的时候下一步j应该放到哪，也就是对齐的位置，这个位置不一定是暴力找算法中的右移的一位，可能是多位，效率更高。</p>
<h2 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h2><p>自动机分为两种：DFA和NFA（非确定性有限状态自动机），都可以用来匹配字符串。很多正则表达式引擎使用的就是NFA。</p>
<p>如果有过FPGA开发经验，就会很清楚，自动机与硬件描述语言中常见的状态机类似。状态机是一种流程控制的模型。一个自动机包含多个状态，状态之间可以有条件的进行转移。这个条件就是输入。</p>
<p>根据输入的不同，一个状态可以转移到另一个状态，或者保持当前状态。</p>
<h2 id="KMP中DFA的构造"><a href="#KMP中DFA的构造" class="headerlink" title="KMP中DFA的构造"></a>KMP中DFA的构造</h2><p>KMP算法并不回退文本指针i,而是使用一个自动机数组<code>dfa[][]``，记录dfa[txt.chatAt[i]][j]</code></p>
<p>在比较了<code>txt.chatAt[i]</code>与<code>pat.chatAt[j]</code>之后应该和下一个文本字符txt.chatAt[i+1]比较的模式字符位置(即回退模式指针j到某个位置而不需回退文本指针i)。</p>
<p>dfa数组就是要构造出这样的回退值，并且<code>dfa[txt.chatAt[i]][j]</code>这个值就是重叠字符的数量，也就是从左向右滑动已匹配的j-1个字符直到所有重叠的字符都互相匹配或者没有相匹配的字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由pattion构造DFA</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.pat = pat;</span><br><span class="line">	<span class="keyword">int</span> M = pat.length();</span><br><span class="line">	<span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">	dfa = <span class="keyword">new</span> <span class="keyword">int</span>[R][M];</span><br><span class="line">	<span class="comment">// 计算DFA</span></span><br><span class="line">	dfa[pat.charAt(<span class="number">0</span>)][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> X = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++) &#123; <span class="comment">// 复制匹配失败情况下的值</span></span><br><span class="line">			dfa[c][j] = dfa[c][X];</span><br><span class="line">		&#125;</span><br><span class="line">		dfa[pat.charAt(j)][j] = j + <span class="number">1</span>; <span class="comment">// 设置匹配成功情况下的值</span></span><br><span class="line">		X = dfa[pat.charAt(j)][X]; <span class="comment">// 更新重启新动态</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>见github!</p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><blockquote>
<p>对于长度为M的模式字符串和长度为N的文本，KMP访问的字符不会超过M+N个。</p>
<p>够照DFA的时间和空间 和RM 成正比。</p>
</blockquote>
<p>综上：</p>
<ul>
<li><p>KMP为最坏的情况下提供线性的级别运行时间的保证。</p>
</li>
<li><p>对文本重复性很高，模块重复性也很高的情况，很有优势，蛤实际上这种情况很小发生，（别的情况和暴力差不多啦！）</p>
</li>
<li><p>但他不用退回的优点，使KMP更适合在长度不确定的输入流中查找 。（如标准输入）</p>
</li>
</ul>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[R向单词查找树与3向单词查找树]]></title>
      <url>/2016/03/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E7%AC%94%E8%AE%B0-R%E5%90%91%E4%B8%8E3%E5%90%91%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<h2 id="R向单词查找树的性能"><a href="#R向单词查找树的性能" class="headerlink" title="R向单词查找树的性能"></a>R向单词查找树的性能</h2><blockquote>
<p>单词查找 树的练表结构（形状）和键的插入或删除顺序无关，对任意给定的一组键，其单词查找树都是唯一的。</p>
</blockquote>
<p>这是一个很特殊的性质。</p>
<blockquote>
<p>在单词查找 树中查找一个键或是插入一个键时，访问数组的次数最多为键的长度加1.</p>
</blockquote>
<p>单词查找 树对命中的查找是最理想的！<br>也说明，在单词查找 树中查找一个键或是插入一个键时，和表的键的数量无关。</p>
<blockquote>
<p>字母表的大小为R，在一棵由N个随机键构造的单词查找树中，未命中的查找平均所需要的检查的结点数量为 Log RN</p>
</blockquote>
<p>查找未命中的成本与键的长度无关，（100万个键，就是检查3~4个结点就可以了，牛吧，）</p>
<blockquote>
<p>一棵单词树中的链接总数在RN到RMW之间，其中w为键的平均长度，</p>
</blockquote>
<p>这个说明了，缩小R能够节省大量的空间。<br>也说明了： 在实际应用中，采用单词查找树之前 了解要被插入的所有键的性质是非常的重要的！！</p>
<p>综上，不要使用R向单词查找树 处理大型字母表的大量长键，他的空间占用极大，但是他的性能是无可匹敌的。</p>
<h2 id="3向单词查找树的性能"><a href="#3向单词查找树的性能" class="headerlink" title="3向单词查找树的性能"></a>3向单词查找树的性能</h2><blockquote>
<p>由N个平均长度为w的字符串构造的3向单词查找树的链接总数在3N到3Nw之间</p>
</blockquote>
<p>这比R向单词查找树用的空间小的多的多。<br>3向单词查找树最大的特点就是：不对特定的应用场景产生依赖。任何情况下都能产生不做的性能。</p>
<h2 id="几种查找算法的比较"><a href="#几种查找算法的比较" class="headerlink" title="几种查找算法的比较"></a>几种查找算法的比较</h2><ul>
<li><p>如果空间足够，<strong><em>R向单词查找树</em></strong>是速度最快的。——能右<strong>常数</strong>次比较内完成查找。</p>
</li>
<li><p>R向单词查找树的空间华北地区满足时， <strong><em>3向单词查找树</em></strong>是最佳的选择，它对字符的比较是<strong>对数级别</strong>的。</p>
</li>
<li><p><strong><em>Hash表</em></strong>也是对数级别，但他不支持有序性的操作。</p>
</li>
</ul>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> Algorithms </tag>
            
            <tag> 单词查找树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[字符串分割--java中String.split()用法]]></title>
      <url>/2016/03/coding/Java-%E6%80%BB%E7%BB%93-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2split%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<p>在java.lang包中有String.split()方法，返回是一个数组。
　</p>
<ol>
<li><p>“.”和“|”都是转义字符，必须得加<code>&quot;\\&quot;</code>;</p>
</li>
<li><p>如果用“.”作为分隔的话，必须是如下写法：<br><code>String.split(&quot;\\.&quot;)</code>,这样才能正确的分隔开，不能用String.split(“.”);</p>
</li>
<li><p>如果用“|”作为分隔的话，必须是如下写法：<br><code>String.split(&quot;\\|&quot;)</code>,这样才能正确的分隔开，不能用String.split(“|”);</p>
</li>
<li><p>如果在一个字符串中有多个分隔符，可以用“|”作为连字符，比如：“acount=? and uu =? or n=?”,把三个都分隔出来，可以用<br><code>String.split(&quot;and|or&quot;);</code></p>
</li>
</ol>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 辨析 </tag>
            
            <tag> 变量 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux Shell Scripts 笔记]]></title>
      <url>/2016/03/%E5%BE%85%E6%95%B4%E7%90%86/Linux-%E7%AC%94%E8%AE%B0-ShellScripts/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       This program shows "Hello World!" in your screen.</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment"># 2005/08/23	VBird	First release</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"Hello World! \a \n"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<ol>
<li><p>#!/bin/bash 在宣告这个 script 使用的 shell 名称.在很多状况中，如果没有配置好这一行， 那么该程序很可能会无法运行，因为系统可能无法判断该程序需要使用什么 shell 来运行啊！</p>
</li>
<li><p>程序内容的说明：<br>整个 script 当中，除了第一行的『 #! 』是用来宣告 shell 的之外，其他的 # 都是『注解』用途！<br>以下是必须写的：<br>script 的功能；<br>script 的版本资讯；<br>script 的作者与联络方式；<br>script 的版权宣告方式；<br>script 的 History (历史纪录)；<br>script 内较特殊的命令，使用『绝对路径』的方式来下达；<br>script 运行时需要的环境变量预先宣告与配置。</p>
</li>
</ol>
<p>3 主要环境变量的宣告：<br>建议务必要将一些重要的环境变量配置好，鸟哥个人认为， PATH 与 LANG (如果有使用到输出相关的资讯时) 是当中最重要的！ 如此一来，则可让我们这支程序在进行时，可以直接下达一些外部命令，而不必写绝对路径呢！比较好啦！</p>
<ol>
<li><p>主要程序部分</p>
</li>
<li><p>运行成果告知 (定义回传值)<br>这个变量来观察～ 那么我们也可以利用 exit 这个命令来让程序中断，并且回传一个数值给系统。$–</p>
</li>
</ol>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux文件、目录、权限的管理]]></title>
      <url>/2016/03/%E5%BE%85%E6%95%B4%E7%90%86/Linux-%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="群组"><a href="#群组" class="headerlink" title="群组"></a>群组</h2><p>root-Uers-group-Others 4级<br>Linux系统当中，预设的情况下，所有的系统上的帐号与一般身份使用者、root的资料， 都是记录在/<code>etc/passwd</code>这个文件中；个人的密码则是记录在/<code>etc/shadow</code>下；所有的群组名称都纪录在<code>/etc/group</code><br>所以没事儿不要删除！<a id="more"></a></p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>键入 <code>ls -al</code> （ls -&gt; list的意思）后显示 <code>读写权限+连接数+文件拥有者+所属群组+大小+修改时间+名字</code></p>
<h3 id="文件类型与权限-permission-："><a href="#文件类型与权限-permission-：" class="headerlink" title="文件类型与权限(permission)："></a>文件类型与权限(permission)：</h3><p>一共10个字母：<br>第一个字母代表这个文件是『目录、文件或链接文件等等』：<br>当为[ d ]则是目录，<br>若是[ l ]则表示为链接文件(link file)；似Windows系統底下的快捷方式<br>若是[ b ]则表示为装置档里面的可供储存的周边设备(可随机存取装置)；<br>若是[ c ]则表示为装置档里面的序列埠设备，例如键盘、键盘(一次性读取装置)。</p>
<p>接下来的字元中，以三个为一组，且均为『rwx』的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。<br>第一组为『档案拥有者可具备的权限』，以『initial-setup-ks.cfg』那个档案为例，该档案的拥有者可以读写，但不可执行；<br>第二组为『加入此群组之帐号的权限』；<br>第三组为『非本人且没有加入本群组之其他帐号的权限』。</p>
<h3 id="改变文件属性与权限chgrp-chown-chmod"><a href="#改变文件属性与权限chgrp-chown-chmod" class="headerlink" title="改变文件属性与权限chgrp/chown/chmod"></a>改变文件属性与权限chgrp/chown/chmod</h3><ol>
<li><p><code>chgrp</code>：改变文件所属群组（change group）<br>Examples: <code>chgrp -hR staff /u</code>     Change the group of /u and subfiles to “staff”</p>
</li>
<li><p><code>chown</code> ：改变文件拥有者 (change owner)<br>taps：如果要连目录下的所有sub目录或文件同时更改档案拥有者的话，直接加上<code>-R</code> (r - recursive 递回)</p>
</li>
<li><p><code>chmod</code> ：改变文件的权限, SUID, SGID, SBIT等等的特性<br><code>chmod [-cfvR] [--help] [--version] mode file</code><br>必要参数：<br>-c 当发生改变时，报告处理信息<br>-f 错误信息不输出<br>-R 处理指定目录以及其子目录下的所有文件<br>-v 运行时显示详细处理信息</p>
</li>
</ol>
<p>权限的设定方法有两种， 分别可以使用<strong>数字</strong>或者是<strong>符号</strong>来进行权限的变更；</p>
<p>使用数字时各权限的分数对照表如下：<br>r:4<br>w:2<br>x:1<br>examples:rwx = 4+2+1 = 7<br>examples:文件的权限设定为：『-rwxr—–』，那就键入<code>chmod 740 filename</code></p>
<p>使用符号改变时可以使用<code>chmod u=rwx,g=rx,o=r filename</code>来设定(u-user g-group o-others a-all)</p>
<p>还有可以用<code>+</code> , examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# ls -al .bashrc </span><br><span class="line">-rwxr-xr-x . 1 root root 176 Dec 29 2013 .bashrc</span><br><span class="line">[root@study ~]# chmod a+w .bashrc </span><br><span class="line">[root@study ~]# ls -al .bashrc </span><br><span class="line">-rwxrwxrwx . 1 root root 176 Dec 29 2013 .bashrc</span><br></pre></td></tr></table></figure>
<h3 id="权限对目录的意义"><a href="#权限对目录的意义" class="headerlink" title="权限对目录的意义"></a>权限对目录的意义</h3><p>| 名称    |     内容        |     类似物件        |    r            |    w            |        x     |<br>| 文件    |    详细资料data    |    文件资料夹    |读到文件内容        |    修改文件内容    |执行文件内容<br>| 目录    |    档名            |    可分类抽屉    |    读到档名        |修改档名        |进入该目录的权限(key) |</p>
<p><strong>重点：</strong><br><code>x (access directory)：</code> 咦！目录的执行权限有啥用?<br>不能拿来执行吧？没错！目录不可以被执行，目录的x代表的是使用者能否进入该目录成为工作目录的用途！当一个你没有x权限的目录，你是不能访问的，<code>cd</code>会无效。<br>所以要注意：要开放目录给任何人浏览时，应该至少也要给予r及x的权限，但w权限不可随便给！ </p>
<h3 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h3><p>几个特殊的：</p>
<ol>
<li><p>设备及设备文件 （device）  通常在<code>/ dev</code>中, 一般不要随意修改，<br>1.1 块设备(block)<br>1.2 字符设备 （character）</p>
</li>
<li><p>套接字（socket） 第一个属性是<code>s</code>, 最常在/run或/tmp目录下。</p>
</li>
<li><p>管道（FIFO,pipe） 第一个属性为<code>p</code>,</p>
</li>
</ol>
<h3 id="文件名和扩展名"><a href="#文件名和扩展名" class="headerlink" title="文件名和扩展名"></a>文件名和扩展名</h3><p>Linux的文件是没有所谓的『扩展名』的，加上只是为了好辨认。<br>Linux档案长度限制( 注1 )：<br>在Linux底下，使用传统的Ext2/Ext3/Ext4档案系统以及近来被CentOS 7 当作预设文件系统的xfs 而言，针对文件名长度限制为：</p>
<blockquote>
<p>单一档案或目录的最大容许档名为255bytes，以一个ASCII 英文占用一个bytes 来说，则大约可达255 个字母长度。若是以每个中文字占用2bytes 来说， 最大档名就是大约在128 个中文字之谱！</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>Filesystem Hierarchy Standard (FHS)标准-规范每个特定的目录下应该要放置什么样子的资料.<br>规定了三个重要目录的定义：</p>
<h3 id="root-根目录-："><a href="#root-根目录-：" class="headerlink" title="/ (root, 根目录)："></a><code>/ (root, 根目录)：</code></h3><p>与开机系统有关；<br>FHS标准建议：</p>
<blockquote>
<p>根目录(/)所在分AQ 应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。如此不但性能较佳，根目录所在的文件系统也较不容易发生问题。</p>
</blockquote>
<h3 id="usr-unix-software-resource-："><a href="#usr-unix-software-resource-：" class="headerlink" title="/usr(unix software resource)："></a><code>/usr</code>(unix software resource)：</h3><p>与软件安装/执行有关；<br>这个目录有点类似Windows 系统的<code>C:\Windows\ (当中的一部份) + C:\Program files \</code>这两个目录的综合，系统刚安装完毕时，这个目录会占用最多的硬盘容量。<br>注意： <code>/usr/bin</code> 要求在此目录下不应该有子目录！</p>
<h3 id="var-variable-："><a href="#var-variable-：" class="headerlink" title="/var (variable)："></a><code>/var</code> (variable)：</h3><p>与系统运作过程有关。就是运行时候的缓存目录。</p>
<h3 id="目录树-和路径"><a href="#目录树-和路径" class="headerlink" title="目录树 和路径"></a>目录树 和路径</h3><p>Linux底下，所有的档案与目录都是由根目录开始的！</p>
<p>开头不是<code>/</code>就属于<strong>相对路径</strong>的写法，这个<code>/home/dmtsai/.bashrc；</code>这个就是<strong>绝对路径</strong>。<br>如果是在写程程序 (shell scripts) 來管理系統的时，务必使用绝对路径。</p>
<p><code>.</code>：代表当前的目录，也可以使用<code>./</code>来表示；<br><code>..</code>：代表上一层目录，也可以<code>../</code> 来代表。</p>
<p>##文件与目录管理</p>
<h3 id="目录的操作cd-pwd-mkdir-PATH"><a href="#目录的操作cd-pwd-mkdir-PATH" class="headerlink" title="目录的操作cd/pwd/mkdir/PATH"></a>目录的操作cd/pwd/mkdir/PATH</h3><p>几个特殊的目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">. 代表此层目录</span><br><span class="line">.. 代表上一层目录</span><br><span class="line">- 代表前一个工作目录</span><br><span class="line">~ 代表『目前使用者身份』所在的主目录</span><br><span class="line">~account 代表account 这个使用者的主目录(account是个帐号名称)</span><br></pre></td></tr></table></figure>
<p>常见的处理目录的指令：</p>
<ol>
<li><code>cd：</code>变换目录(change directory)</li>
<li></li>
<li><p><code>pwd</code>：显示目前的目录(print working directory)<br>如果输入：<code>pwd -P</code> 可以让我们取得正确（真实）的目录名称，而不是以链接的路径来显示的。</p>
</li>
<li><p><code>mkdir</code>：建立一个新的目录 (make directory)</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# mkdir [-mp]目录名称</span><br><span class="line">选项与参数：</span><br><span class="line">-m ：设定档案的权限喔！直接设定，不需要看预设权限(umask) 的脸色～</span><br><span class="line">-p ：帮助你直接将所需要的目录(包含上层目录)递回建立起来！</span><br><span class="line"></span><br><span class="line">范例：请到/tmp底下尝试建立数个新目录看看： </span><br><span class="line">[root@study ~]# cd /tmp </span><br><span class="line">[root@study tmp]# mkdir test     &lt;==建立一名为test的新目录 </span><br><span class="line">[root@study tmp]# mkdir test1/test2/test3/test4</span><br><span class="line">的mkdir：无法创建目录&apos;测试1 / TEST2 / TEST3 / TEST4“：没有这样的文件或目录</span><br><span class="line">#话说，系统告诉我们，没可能建立这个目录啊！就是没有目录才要建立的！见鬼嘛？</span><br><span class="line">[root@study tmp]# mkdir -p test1/test2/test3/test4 </span><br><span class="line">#原来是要建test4上层没先建test3之故！加了这个-p的选项，可以自行帮你建立多层目录！</span><br></pre></td></tr></table></figure>
<ol>
<li><code>rmdir</code>：删除一个<strong>空的</strong>目录(remove directory)<br>注意是空的，有u文件的不能用这个命令了，这样设计比较安全，对吧。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# rmdir [-p]目录名称</span><br><span class="line">选项与参数：</span><br><span class="line">-p ：连同『上层』『空的』目录也一起删除</span><br><span class="line"></span><br><span class="line">范例：将于mkdir范例中建立的目录(/tmp底下)删除掉！</span><br><span class="line">[root@study tmp]# ls -ld test*    &lt;==看看有多少目录存在？</span><br><span class="line">drwxr-XR-X。2根根部6 6月4日19:03测试</span><br><span class="line">drwxr-XR-X。3根根6月18日19:04 4个TEST1</span><br><span class="line">Drwx  -  X  -  X。2根根部6 6月4日19:05测试2</span><br><span class="line">[root@study tmp]# rmdir test   &lt;==可直接删除掉，没问题 </span><br><span class="line">[root@study tmp]# rmdir test1   &lt;==因为尚有内容，所以无法删除！</span><br><span class="line">命令rmdir：无法删除“测试1”：目录非空</span><br><span class="line">[root@study tmp]# rmdir -p test1/test2/test3/test4 </span><br><span class="line">[root@study tmp]# ls -ld test*     &lt;==您看看，底下的输出中test与test1不见了！</span><br><span class="line">Drwx  -  X  -  X。2根根部6 6月4日19:05测试2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 瞧！利用-p 这个选项，立刻就可以将test1/test2/test3/test4 一次删除～</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不过要注意的是，这个rmdir 仅能『删除空的目录』喔！</span></span><br></pre></td></tr></table></figure>
<h3 id="PATH"><a href="#PATH" class="headerlink" title="$PATH"></a><code>$PATH</code></h3><blockquote>
<p>当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。</p>
</blockquote>
<p>几个要点：</p>
<ol>
<li><p>不同身份使用者预设的PATH不同，预设能够随意执行的指令也不同(如root与dmtsai)；</p>
</li>
<li><p>PATH是可以修改的；</p>
</li>
<li><p>使用绝对路径或相对路径直接指定某个指令的档名来执行，会比搜寻PATH来的正确；</p>
</li>
<li><p>指令应该要放置到正确的目录下，执行才会比较方便；</p>
</li>
<li><p>本目录(.)最好不要放到PATH当中。（为了安全，）</p>
</li>
</ol>
<h3 id="ls操作"><a href="#ls操作" class="headerlink" title="ls操作"></a>ls操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# ls [-aAdfFhilnrRSt]档名或目录名称.. </span><br><span class="line">[root@study ~]# ls [--color=&#123;never,auto,always&#125;]档名或目录名称.. </span><br><span class="line">[root@ study ~]# ls [--full-time]档名或目录名称.. </span><br><span class="line">选项与参数：</span><br><span class="line"> -a ：全部的档案，连同隐藏档(开头为.的档案)一起列出来(常用)</span><br><span class="line">-A ：全部的档案，连同隐藏档，但不包括. 与.. 这两个目录</span><br><span class="line">-d ：仅列出目录本身，而不是列出目录内的档案资料(常用)</span><br><span class="line">-f ：直接列出结果，而不进行排序(ls 预设会以档名排序！)</span><br><span class="line">-F ：根据档案、目录等资讯，给予附加资料结构，例如：</span><br><span class="line">      *:代表可执行档； /:代表目录； =:代表socket 档案； |:代表FIFO 档案；</span><br><span class="line">-h ：将档案容量以人类较易读的方式(例如GB, KB 等等)列出来；</span><br><span class="line">-i ：列出inode 号码，inode 的意义下一章将会介绍；</span><br><span class="line">-l ：长资料串列出，包含档案的属性与权限等等资料；(常用)</span><br><span class="line">-n ：列出UID 与GID 而非使用者与群组的名称(UID与GID会在帐号管理提到！)</span><br><span class="line">-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小；</span><br><span class="line">-R ：连同子目录内容一起列出来，等于该目录下的所有档案都会显示出来；</span><br><span class="line">-S ：以档案容量大小排序，而不是用档名排序；</span><br><span class="line">-t ：依时间排序，而不是用档名。</span><br><span class="line">--color=never ：不要依据档案特性给予颜色显示；</span><br><span class="line">--color=always ：显示颜色</span><br><span class="line">--color=auto ：让系统自行依据设定来判断是否给予颜色</span><br><span class="line">--full-time ：以完整时间模式(包含年、月、日、时、分) 输出</span><br><span class="line">--time=&#123;atime,ctime&#125; ：输出access 时间或改变权限属性时间(ctime) </span><br><span class="line">                       而非内容变更时间(modification time)</span><br></pre></td></tr></table></figure>
<p>最常用的功能 就是<code>ls -l</code>，简写<code>ll</code>.</p>
<h3 id="cp-rm-mv操作"><a href="#cp-rm-mv操作" class="headerlink" title="cp/rm/mv操作"></a>cp/rm/mv操作</h3><p> cp- copy<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@study ~]# cp [-adfilprsu]来源档(source)目标档(destination) </span><br><span class="line">[root@study ~]# cp [options] source1 source2 source3 .... directory </span><br><span class="line">选项与参数：</span><br><span class="line"> -a ：相当于-dr --preserve=all的意思，至于dr请参考下列说明；(常用)</span><br><span class="line">-d ：若来源档为连结档的属性(link file)，则复制连结档属性而非档案本身；</span><br><span class="line">-f ：为强制(force)的意思，若目标档案已经存在且无法开启，则移除后再尝试一次；</span><br><span class="line">-i ：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</span><br><span class="line">-l ：进行硬式连结(hard link)的连结档建立，而非复制档案本身；</span><br><span class="line">-p ：连同档案的属性(权限、用户、时间)一起复制过去，而非使用预设属性(备份常用)；</span><br><span class="line">-r ：递回持续复制，用于目录的复制行为；(常用)</span><br><span class="line">-s ：复制成为符号连结档(symbolic link)，亦即『捷径』档案；</span><br><span class="line">-u ：destination 比source 旧才更新destination，或destination 不存在的情况下才复制。</span><br><span class="line">--preserve=all ：除了-p 的权限相关参数外，还加入SELinux 的属性, links, xattr 等也复制了。</span><br><span class="line">最后需要注意的，如果来源档有两个以上，则最后一个目的档一定要是『目录』才行！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">examples：变换目录到/tmp，并将/var/log/wtmp复制到/tmp且观察属性： </span><br><span class="line">[root@study ~]# cd /tmp </span><br><span class="line">[root@study tmp]# cp /var/log/wtmp .  &lt;==想要复制到目前的目录，最后的.不要忘 </span><br><span class="line">[root@study tmp]# ls -l /var/log/wtmp wtmp </span><br><span class="line">-rw-rw-r-- . 1 root utmp 28416 Jun 11 18: 56 /var/log/wtmp</span><br><span class="line"> -rw-r--r-- . 1 root root 28416 Jun 11 19:01 wtmp</span><br><span class="line"><span class="meta"> #</span><span class="bash">注意上面的特殊字体，在不加任何选项的情况下，档案的某些属性/权限会改变；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是个很重要的特性！要注意喔！还有，连档案建立的时间也不一样了！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 那如果你想要将档案的所有特性都一起复制过来该怎办？可以加上-a 喔！如下所示：</span></span><br></pre></td></tr></table></figure></p>
<p>在预设的条件中， cp的来源文件与目的文件的权限是不同的，目的文件的拥有者通常会是指令操作者本身。<br>由于具有这个特性，因此当我们在进行备份的时候，某些需要特别注意的特殊权限文件， 例如密码文件(/etc/shadow) 以及一些设定档，就不能直接以cp 来复制，<strong>而必须要加上-a 或者是-p 等等可以完整复制档案权限的选项才行！</strong></p>
<p>rm - remove</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# rm [-fir]档案或目录</span><br><span class="line">选项与参数：</span><br><span class="line">-f ：就是force 的意思，忽略不存在的档案，不会出现警告讯息；</span><br><span class="line">-i ：互动模式，在删除前会询问使用者是否动作</span><br><span class="line">-r ：递回删除啊！最常用在目录的删除了！目录下的东西都一起删除的！这是非常危险的选项！！！</span><br></pre></td></tr></table></figure>
<p> mv - move,另外一个用途就是『变更文件名！』</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[根@研究〜]＃MV [-fiu]源目标 </span><br><span class="line">[@根研究〜]＃MV [选项]源1源2 source3 ....目录</span><br><span class="line">选项与参数：</span><br><span class="line">-f ：force 强制的意思，如果目标档案已经存在，不会询问而直接覆盖；</span><br><span class="line">-i ：若目标档案(destination) 已经存在时，就会询问是否覆盖！</span><br><span class="line">-u ：若目标档案已经存在，且source 比较新，才会更新(update)</span><br><span class="line"></span><br><span class="line">范例二：将刚刚的目录名称更名为mvtest2 </span><br><span class="line">[root@study tmp]# mv mvtest mvtest2  &lt;==这样就更名了！简单～</span><br><span class="line">#其实在Linux底下还有个有趣的指令，名称为rename，</span><br><span class="line"># 该指令专职进行多个档名的同时更名，并非针对单一档名变更，与mv不同。请man rename。</span><br><span class="line"></span><br><span class="line">范例三：再建立两个档案，再全部移动到/tmp/mvtest2当中 </span><br><span class="line">[root@study tmp]# cp ~/.bashrc bashrc1 </span><br><span class="line">[root@study tmp]# cp ~/.bashrc bashrc2 </span><br><span class="line">[root@study tmp] # mv bashrc1 bashrc2 mvtest2 </span><br><span class="line">#注意到这边，如果有多个来源档案或目录，则最后一个目标档一定是『目录！』</span><br><span class="line"># 意思是说，将所有的资料移动到该目录的意思！</span><br></pre></td></tr></table></figure>
<h3 id="文件内容查阅操作cat-tac-nl-more-less-head-tail-od"><a href="#文件内容查阅操作cat-tac-nl-more-less-head-tail-od" class="headerlink" title="文件内容查阅操作cat/tac/nl/more/less/head/tail/od"></a>文件内容查阅操作cat/tac/nl/more/less/head/tail/od</h3><ol>
<li>cat 由第一行开始显示档案内容<br><code>cat [-AbEnTv]</code><br>选项与参数：<br>-A ：相当于-vET 的整合选项，可列出一些特殊字符而不是空白而已；<br>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！<br>-E ：将结尾的断行字元$ 显示出来；<br>-n ：列印出行号，连同空白行也会有行号，与-b 的选项不同；<br>-T ：将[tab] 按键以^I 显示出来；<br>-v ：列出一些看不出来的特殊字符</li>
</ol>
<ol>
<li>tac 从最后一<strong>行</strong>开始显示，可以看出tac 是cat 的倒着写！</li>
</ol>
<ol>
<li><p>nl 显示的时候，顺道输出行号！</p>
</li>
<li><p>more 一页一页的显示档案内容</p>
</li>
<li><p>less 与more 类似，但是比more 更好的是，他可以往前翻页！</p>
</li>
<li><p>head 只看头几行<br><code>head [-n number] 文件</code><br>选项与参数：<br>-n ：后面接数字，代表显示几行的意思</p>
</li>
<li><p>tail 只看尾巴几行</p>
</li>
<li><p>od 以二进位的方式读取档案内容！</p>
</li>
</ol>
<h3 id="touch修改文件时间或新建文件"><a href="#touch修改文件时间或新建文件" class="headerlink" title="touch修改文件时间或新建文件"></a>touch修改文件时间或新建文件</h3><p>三个重<strong>要的文件时间点</strong>：</p>
<ul>
<li><p>mtime(modification time) 内容最后修改时间</p>
</li>
<li><p>ctime(status time) 权限、属性修改时间</p>
</li>
<li><p>atime(acess time) 读取时间</p>
</li>
</ul>
<p><code>touch [-acdmt]文件</code><br>选项与参数：<br>-a ：仅修订access time；<br>-c ：仅修改文件的时间，若该文件不存在则不建立新档案；<br>-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用–date=”日期或时间”<br>-m ：仅修改mtime ；<br>-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]</p>
<p>不过，要注意的是，即使我们复制一个文件时，复制所有的属性，但也没有办法复制ctime 这个属性的。ctime 可以记录这个档案最近的状态(status) 被改变的时间。</p>
<h3 id="文件预设权限-umask"><a href="#文件预设权限-umask" class="headerlink" title="文件预设权限 umask"></a>文件预设权限 umask</h3><p>查阅的方式有两种，一种可以直接输入umask ，就可以看到数字型态的权限设定分数， 一种则是加入-S (Symbolic) 这个选项，就会以符号类型的方式来显示出权限了！奇怪的是，怎么umask 会有四组数字啊？不是只有三组吗？是没错啦。第一组是特殊权限用的，不用去管。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# umask</span><br><span class="line">0022              &lt;==与一般权限有关的是后面三个数字！</span><br><span class="line">[root@study ~]# umask -S</span><br><span class="line">U = RWX，G = RX，O = RX</span><br></pre></td></tr></table></figure>
<p>默认的权限如下：</p>
<ul>
<li><p>若使用者建立为<strong>文件</strong>则默认『没有可执行( x )权限』，亦即只有rw这两个项目，也就是最大为666分，预设权限如下：<code>-rw-rw-rw-</code></p>
</li>
<li><p><strong>目录</strong>，则由于x与 ​是否可以进入此目录有关，因此默认为所有权限均开放，亦即为777分，预设权限如下：<code>drwxrwxrwx</code></p>
</li>
</ul>
<p>要<strong>注意</strong>的是，umask的分数指的『该默认值需要减掉的权限！』(r、w、x分别是4、2、1分，)</p>
<h3 id="文件隐藏属性chattr-lsattr"><a href="#文件隐藏属性chattr-lsattr" class="headerlink" title="文件隐藏属性chattr/lsattr"></a>文件隐藏属性chattr/lsattr</h3><p><code>lsattr [-adR]文件或目录</code><br>选项与参数：<br>-a ：将隐藏档的属性也秀出来；<br>-d ：如果接的是目录，仅列出目录本身的属性而非目录内的档名；<br>-R ：连同子目录的资料也一并列出来！ </p>
<p><code>chattr [+-=][ASacdistu]文件或目录名称</code><br>选项与参数：</p>
<ul>
<li>：增加某一个特殊参数，其他原本存在参数则不动。</li>
</ul>
<ul>
<li>：移除某一个特殊参数，其他原本存在参数则不动。<br>= ：设定一定，且仅有后面接的参数</li>
</ul>
<p>A ：当设定了A 这个属性时，若你有存取此档案(或目录)时，他的存取时间atime 将不会被修改，<br>     可避免I/O 较慢的机器过度的存取磁碟。(目前建议使用档案系统挂载参数处理这个项目)<br>S ：一般档案是非同步写入磁碟的(原理请参考前一章sync的说明)，如果加上S这个属性时，<br>     当你进行任何档案的修改，该更动会『同步』写入磁碟中。<br>a ：当设定a 之后，这个档案将只能增加资料，而不能删除也不能修改资料，只有root 才能设定这属性<br>c ：这个属性设定之后，将会自动的将此档案『压缩』，在读取的时候将会自动解压缩，<br>     但是在储存的时候，将会先进行压缩后再储存(看来对于大档案似乎蛮有用的！)<br>d ：当dump 程序被执行的时候，设定d 属性将可使该档案(或目录)不会被dump 备份<br>i ：这个i 可就很厉害了！他可以让一个档案『不能被删除、改名、设定连结也无法写入或新增资料！』<br>     对于系统安全性有相当大的助益！只有root 能设定此属性<br>s ：当档案设定了s 属性时，如果这个档案被删除，他将会被完全的移除出这个硬碟空间，<br>     所以如果误删了，完全无法救回来了喔！<br>u ：与s 相反的，当使用u 来设定档案时，如果该档案被删除了，则资料内容其实还存在磁碟中，<br>     可以使用来救援该档案喔！<br>注意1：属性设定常见的是a 与i 的设定值，而且很多设定值必须要身为root 才能设定<br>注意2：xfs文件系统仅支持AadiS 而已</p>
<h3 id="文件特殊权限：-SUID-SGID-SBIT"><a href="#文件特殊权限：-SUID-SGID-SBIT" class="headerlink" title="文件特殊权限： SUID, SGID, SBIT"></a>文件特殊权限： SUID, SGID, SBIT</h3><p>SUID - Set UID 当s 标志在<strong>User</strong>的x 权限上时表示为SUID<br>注意:<br> <strong>SUID对于目录是无效</strong>的～这点要特别留意。<br> SUID仅可用在binary program上，不能够用在shell script上面！</p>
<p>SGID - Set GID s 在<strong>群组group</strong>的x 时则称为Set GID<br>注意<br>除了binary program 之外，事实上SGID 也能够用在目录上，这也是非常常见的一种用途！</p>
<p>SBIT-Sticky Bit 目<strong>前只针对目录有效</strong>，对于文件已经没有效果了。<br>SBIT 对于目录的作用是：</p>
<ul>
<li><p>当使用者对于此目录具有w, x 权限，亦即具有写入的权限时；</p>
</li>
<li><p>当使用者在该目录下建立档案或目录时，仅有自己与root 才有权力删除该档案。</p>
</li>
</ul>
<p>如何修改呢？<br>如果在这三个数字之前再加上一个数字的话，最前面的那个数字就代表这几个权限了！<br>4 为SUID<br>2 为SGID<br>1 为SBIT</p>
<h3 id="查看文件类型-file"><a href="#查看文件类型-file" class="headerlink" title="查看文件类型 file"></a>查看文件类型 file</h3><h3 id="脚本文件名的查询which-type-whereis-locate-updatedb-find"><a href="#脚本文件名的查询which-type-whereis-locate-updatedb-find" class="headerlink" title="脚本文件名的查询which/type/whereis/locate/updatedb/find"></a>脚本文件名的查询which/type/whereis/locate/updatedb/find</h3><p>which 寻找执行文件<br><code>which [-a] command</code><br>选项或参数：<br>-a ：将所有由PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称</p>
<p>注意是  PATH内的！</p>
<p>whereis 文件名<br><code>whereis [-bmsu]档案或目录名</code><br>选项与参数：<br>-l :可以列出whereis 会去查询的几个主要目录而已<br>-b :只找binary格式的文件（可执行）<br>-m :只找在说明文件manual 路径下的文件<br>-s :只找source 来源档案<br>-u :搜寻不在上述三个项目当中的其他特殊档案</p>
<p>注意 ：whereis 只找几个特定的​​目录而已～ 所以比find快</p>
<p>locate 直接在后面输入『文件的部分名称』后，就能够得到结果。</p>
<p><code>locate [-ir] keyword</code><br>选项与参数：<br>-i ：忽略大小写的差异；<br>-c ：不输出档名，仅计算找到的档案数量<br>-l ：仅输出几行的意思，例如输出五行则是-l 5<br>-S ：输出locate 所使用的资料库档案的相关资讯，包括该资料库纪录的档案/目录数量等<br>-r ：后面可接正规表示法的显示方式</p>
<p>updatedb：根据/etc/updatedb.conf 的设定去搜寻系统硬盘内的文件名，并更新<code>/var/lib/mlocate</code> 内的资料库文件案；比较慢，<br>locate：依据<code>/var/lib/mlocate</code> 内的资料库记载，找出使用者输入的关键字档名。 会比较快。</p>
<p>find 利用find 可以加入许多选项来直接查询档案系统，以获得自己想要知道的档名。<br><code>[root@study ~]# find [PATH] [option] [action]</code><br>选项与参数：</p>
<ol>
<li>与时间有关的选项：共有-atime, -ctime 与-mtime ，以-mtime 说明<br>-mtime n ：n 为数字，意义为在n 天之前的『一天之内』被更动过内容的档案；(注意，0代表 24小时内。)<br>-mtime +n ：列出在n 天之前(不含n 天本身)被更动过内容的档案档名；<br>-mtime -n ：列出在n 天之内(含n 天本身)被更动过内容的档案档名。<br>-newer file ：file 为一个存在的档案，列出比file 还要新的档案档名</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> 文件 </tag>
            
            <tag> 目录 </tag>
            
            <tag> 权限 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux软件安装学习笔记]]></title>
      <url>/2016/03/%E5%BE%85%E6%95%B4%E7%90%86/Linux-%E7%AC%94%E8%AE%B0-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="什么是make-与configure"><a href="#什么是make-与configure" class="headerlink" title="什么是make 与configure"></a>什么是make 与configure</h3><p>行make时，make会在当时的目录下搜寻Makefile (or makefile) 这个文字档，而Makefile里面则记录了原始码如何编译的详细资讯！make会自动的判别原始码是否经过变动了，而自动更新执行档。</p>
<p>Makefile 怎么写？通常软件开发商都会写一支侦测程式来侦测使用者的作业环境，及该作业环境是否有软件开发商所需要的其他功能，该侦测程式侦测完毕后，就会主动的建立这个Makefile 的规则文件啦！通常这支侦测程式的文件名为<code>configure</code> 或者是<code>config</code> 。<a id="more"></a></p>
<h3 id="什么是Tarball-的软件"><a href="#什么是Tarball-的软件" class="headerlink" title="什么是Tarball 的软件"></a>什么是Tarball 的软件</h3><p>所谓的Tarball文件，其实就是将软件的所有原始码文件先以<code>tar</code>打包，然后再以压缩技术来压缩，通常最常见的就是以<code>gzip</code>来压缩了.文件名也会变成<em>.tar.bz2, </em>.tar.xz。</p>
<p>软件的Tarball 安装的基本流程是这样的啦：</p>
<ol>
<li><p>将Tarball 由厂商的网页下载下来；</p>
</li>
<li><p>将Tarball 解开，产生很多的原始码文件；</p>
</li>
<li><p>开始以gcc 进行原始码的编译(会产生目标档object files)；</p>
</li>
<li><p>然后以gcc 进行函式库、主、副程式的连结，以形成主要的binary file；</p>
</li>
<li><p>将上述的binary file 以及相关的设定档安装至自己的主机上面。</p>
</li>
</ol>
<h3 id="Tarball-安装的基本步骤"><a href="#Tarball-安装的基本步骤" class="headerlink" title="Tarball 安装的基本步骤"></a>Tarball 安装的基本步骤</h3><ol>
<li><p>取得原始档：将tarball 文件在/usr/local/src 目录下解压缩；</p>
</li>
<li><p>取得步骤流程：进入新建立的目录底下，去查阅INSTALL 与README 等相关文件内容(很重要的步骤！)；</p>
</li>
<li><p>相依属性软件安装：根据INSTALL/README 的内容察看并安装好一些相依的软件(非必要)；</p>
</li>
<li><p>·建立makefile：以自动侦测程式(configure 或config) 侦测作业环境，并建立Makefile 这个文件；<br><code>./configure --prefix=/usr/local/ntp --enable-all-clocks --enable-parse-clocks</code></p>
</li>
</ol>
<p>prefix后面接的路径就是『这个软件未来要安装到那个目录去？』如果你没有指定<code>--prefix=/path</code>这个参数，通常预设参数就是<code>/usr/local</code>至于其他的参数意义就得要参考<code>./configure --help</code>了</p>
<ol>
<li><p><code>make clean</code>make会读取Makefile中关于clean的工作。这个步骤不一定会有，但是希望执行一下，因为他可以去除目标文件！</p>
</li>
<li><p><code>make</code> 编译：以make 这个程式并使用该目录下的Makefile 做为他的参数设定档，来进行make (编译或其他) 的动作；</p>
</li>
<li><p><code>make install</code> 安装：以make 这个程式，并以Makefile 这个参数设定档，依据 install 这个标的(target) 的指定来安装到正确的路径！</p>
</li>
<li><p>为安装到单独目录的软件之man page加入man path搜寻：</p>
</li>
</ol>
<p>如果你安装的软件放置到<code>/usr/local/software/</code>，那么man page搜寻的设定中，可能就得要在<code>/etc/man_db.conf</code>内的40~50行左右处，写入如下的一行：<br><code>MANPATH_MAP /usr/local/software/bin /usr/local/software/man</code><br>这样才可以使用man 来查询该软件的线上文件啰！</p>
<p>建议大家将自己安装的软件放置在<code>/usr/local</code> 下，至于原始码 (Tarball)则建议放置在<code>/usr/local/src</code> (src 为source 的缩写)底下啊</p>
<p>软件的内容大致上是摆在etc, lib, bin, man 等目录当中，分别代表『设定档、函式库、执行档、线上说明档』。</p>
<p>单一软件的文件都在同一个目录之下，那么要移除该软件就简单的多了！只要将该目录移除即可视为该软件已经被移除啰！以上面为例，我想要移除apache只要下达<code>rm -rf /usr/local/apache</code>』就可以了。</p>
<h3 id="tarball安装-的建议"><a href="#tarball安装-的建议" class="headerlink" title="tarball安装 的建议"></a>tarball安装 的建议</h3><p>最好将tarball 的原始数据解压缩到<code>/usr/local/src</code> 当中；</p>
<p>安装时，最好安装到<code>/usr/local</code>这个预设路径下；</p>
<p>考虑未来的反安装步骤，最好可以将每个软件单独的安装在/usr/local 底下；</p>
<p>为安装到单独目录的软件之man page加入man path搜寻：</p>
<p>如果你安装的软件放置到<code>/usr/local/software/</code>，那么man page搜寻的设定中，可能就得要在<code>/etc/man_db.conf</code>内的40~50行左右处，写入如下的一行：<br><code>MANPATH_MAP /usr/local/software/bin /usr/local/software/man</code><br>这样才可以使用man 来查询该软件的线上文件啰！</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> 管理 </tag>
            
            <tag> 软件安装 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux文件系统管理（进阶）]]></title>
      <url>/2016/03/%E5%BE%85%E6%95%B4%E7%90%86/Linux-%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="磁盘配额-Quota"><a href="#磁盘配额-Quota" class="headerlink" title="磁盘配额(Quota)"></a>磁盘配额(Quota)</h2><p><code>quota</code>就是在回报管理员磁盘使用率以及让管理员管理磁盘使用情况的一个工具<a id="more"></a></p>
<h2 id="软件磁盘阵列-Software-RAID"><a href="#软件磁盘阵列-Software-RAID" class="headerlink" title="软件磁盘阵列(Software RAID"></a>软件磁盘阵列(Software RAID</h2><p>Redundant Arrays of Inexpensive Disks, RAID<br>RAID可以透过一个技术(软件或硬件)，将多个较小的磁盘整合成为一个较大的磁盘装置；而这个较大的磁盘功能可不止是储存而已，他还具有资料保护的功能。<br>有以下几种等级：<br>RAID-0 (等量模式, stripe)：效能最佳<br>RAID-1 (映射模式, mirror)：完整备份<br>RAID 1+0，RAID 0+1<br>RAID 5：效能与资料备份的均衡考量</p>
<p>software, hardware RAID的不同 </p>
<h3 id="软件磁盘阵列的设定"><a href="#软件磁盘阵列的设定" class="headerlink" title="软件磁盘阵列的设定"></a>软件磁盘阵列的设定</h3><h2 id="逻辑卷管理员-Logical-Volume-Manager"><a href="#逻辑卷管理员-Logical-Volume-Manager" class="headerlink" title="逻辑卷管理员(Logical Volume Manager)"></a>逻辑卷管理员(Logical Volume Manager)</h2><h3 id="什么是LVM：-PV-PE-VG-LV-的意义"><a href="#什么是LVM：-PV-PE-VG-LV-的意义" class="headerlink" title="什么是LVM： PV, PE, VG, LV 的意义"></a>什么是LVM： PV, PE, VG, LV 的意义</h3><p>LVM的重点在于<strong>可以弹性的调整filesystem的容量</strong>！</p>
<p>Physical Volume, PV, 实体卷轴</p>
<p>Volume Group, VG, 卷轴群组</p>
<p>Physical Extent, PE, 实体范围区块</p>
<p>Logical Volume, LV, 逻辑卷轴</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> 管理 </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux用户管理学习笔记]]></title>
      <url>/2016/03/%E5%BE%85%E6%95%B4%E7%90%86/Linux-%E7%AC%94%E8%AE%B0-%E5%B8%90%E5%8F%B7%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="帐号与群组概念"><a href="#帐号与群组概念" class="headerlink" title="帐号与群组概念"></a>帐号与群组概念</h2><p>每个登入的使用者至少都会取得两个ID ，一个是使用者ID (User ID ，简称UID)、一个是群组ID (Group ID ，简称GID)。<br>使用者帐号有关的有两个非常重要的文件，一个是管理使用者UID/GID重要参数的<code>/etc/passwd</code> ，一个则是专门管理密码相关资料的<code>/etc/ shadow</code><br><a id="more"></a></p>
<h3 id="etc-passwd-结构"><a href="#etc-passwd-结构" class="headerlink" title="/etc/passwd 结构"></a>/etc/passwd 结构</h3><p>注意：这个任何人都可以看，没有什么保密性，所以密码为X<br>有7个项目，用：隔开</p>
<p>帐号名称：<br>密码（x）：<br>UID（0 root; 1-999系统帐号；1000~60000用户）：<br>GID：<br>使用者信息说明栏：<br>主目录：<br>Shell（比较需要注意的是，有一个shell可以用来替代成让帐号无法取得shell环境的登入动作！那就是<code>/sbin/nologin</code>）</p>
<h3 id="etc-shadow-文件结构"><a href="#etc-shadow-文件结构" class="headerlink" title="/etc/shadow 文件结构"></a>/etc/shadow 文件结构</h3><p>只有root可以读写，<br>九个项目组成</p>
<p>帐号名称：</p>
<p>密码：(经过编码的密码(加密)，不是真的密码)</p>
<p>最近更动密码的日期：(Linux日期的时间是以1970年1月1日作为1而累加的日期,所以显示的一个数)</p>
<p>密码不可被更动的天数：(是0的话，表示密码随时可以更动的意思) </p>
<p>密码需要重新变更的天数：(99999 (计算为273年)的话，那就表示，呵呵，密码的变更没有强制性之意)</p>
<p>密码需要变更期限前的警告天数：()</p>
<p>帐号失效日期：0代表密码过期立刻失效，如果是-1则是代表密码永远不会失效</p>
<p>保留：</p>
<h3 id="etc-group-文件结构"><a href="#etc-group-文件结构" class="headerlink" title="/etc/group 文件结构"></a>/etc/group 文件结构</h3><p>分为四栏</p>
<p>1.群组名称：</p>
<p>2.群组密码：</p>
<p>3.GID：</p>
<p>4.此群组支持的帐号名称：(添加时注意不要有空格；不显示root 和创建者)</p>
<h3 id="etc-gshadow"><a href="#etc-gshadow" class="headerlink" title="/etc/gshadow"></a><code>/etc/gshadow</code></h3><p>分四个项目</p>
<p>1.群组名称<br>2.密码栏，同样的，开头为! 表示无合法密码，所以无群组管理员<br>3.群组管理员的帐号(相关资讯在gpasswd中介绍)<br>4.有加入该群组支援的所属帐号(与/etc/group 内容相同！)</p>
<h3 id="有效群组-effective-group-与初始群组-initial-group"><a href="#有效群组-effective-group-与初始群组-initial-group" class="headerlink" title="有效群组(effective group)与初始群组(initial group)"></a>有效群组(effective group)与初始群组(initial group)</h3><p>在读取/写入/执行文件时，针对群组部分，只要是users, wheel与dmtsai这三个群组拥有的功能，我dmtsai这个使用者都能够拥有，但是新建的时候不是，<br>通常有效群组的作用是在新建文件。</p>
<h3 id="群组查询命令与有效群组的切换groups-newgrp"><a href="#群组查询命令与有效群组的切换groups-newgrp" class="headerlink" title="群组查询命令与有效群组的切换groups/newgrp"></a>群组查询命令与有效群组的切换groups/newgrp</h3><p>输入<code>groups</code>在这个输出的信息中， 第一个输出的群组即为有效群组(effective group)了</p>
<p>有效群组的切换newgrp的命令：<code>newgrp groupname</code></p>
<h2 id="帐号管理"><a href="#帐号管理" class="headerlink" title="帐号管理"></a>帐号管理</h2><h3 id="新增与移除使用者：-useradd-相关设定档-passwd-usermod-userdel"><a href="#新增与移除使用者：-useradd-相关设定档-passwd-usermod-userdel" class="headerlink" title="新增与移除使用者： useradd, 相关设定档, passwd, usermod, userdel"></a>新增与移除使用者： useradd, 相关设定档, passwd, usermod, userdel</h3><p><code>useradd [-u UID] [-g初始群组] [-G次要群组] [-mM] [-c说明栏] [-d家目录绝对路径] [- s shell]使用者帐号名</code><br>选项与参数：<br>-u ：后面接的是UID ，是一组数字。直接指定一个特定的UID 给这个帐号；<br>-g ：后面接的那个群组名称就是我们上面提到的initial group 啦～<br>      该群组的GID 会被放置到/etc/passwd 的第四个栏位内。<br>-G ：后面接的群组名称则是这个帐号还可以加入的群组。<br>      这个选项与参数会修改/etc/group 内的相关资料喔！<br>-M ：强制！不要建立使用者家目录！(系统帐号预设值)<br>-m ：强制！要建立使用者家目录！(一般帐号预设值)<br>-c ：这个就是/etc/passwd 的第五栏的说明内容啦～可以随便我们设定的啦～<br>-d ：指定某个目录成为家目录，而不要使用预设值。务必使用绝对路径！<br>-r ：建立一个系统的帐号，这个帐号的UID 会有限制(参考/etc/login.defs)<br>-s ：后面接一个shell ，若没有指定则预设是/bin/bash 的啦～<br>-e ：后面接一个日期，格式为『YYYY-MM-DD』此项目可写入shadow 第八栏位，亦即帐号失效日的设定项目啰；<br>-f ：后面接shadow 的第七栏位项目，指定密码是否会失效。0为立刻失效，-1 为永远不失效(密码只会过期而强制于登入时重新设定而已。)</p>
<p>设置时知道底下几个文件：</p>
<p>使用者帐号与密码参数方面的文件：<code>/etc/passwd, /etc/shadow</code>PAM (Pluggable Authentication Modules, 嵌入式模组) 的机制！</p>
<p>使用者群组相关方面的文件：<code>/etc/group, /etc/gshadow</code><br>使用者的家目录：<code>/home/帐号名称</code></p>
<p>其实useradd 的预设值查询：<code>useradd -D</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GROUP=100		 &lt;==预设的群组 </span><br><span class="line">HOME=/home		 &lt;==预设的主目录所在目录 </span><br><span class="line">INACTIVE=-1		 &lt;==密码失效日，在shadow内的第7栏 </span><br><span class="line">EXPIRE=			 &lt;==帐号失效日，在shadow内的第8栏 </span><br><span class="line">SHELL=/bin/sh		 &lt;==预设的shell </span><br><span class="line">SKEL=/etc/skel		 &lt;==使用者家目录的内容资料参考目录 </span><br><span class="line">CREATE_MAIL_SPOOL=no    &lt;==是否主动帮使用者建立邮件信箱(mailbox)</span><br></pre></td></tr></table></figure>
<p>passwd </p>
<p><code>passwd [--stdin] [帐号名称]</code>   &lt;==所有人均可使用来改自己的密码<br><code>passwd [-l] [-u] [--stdin] [-S]  [-n日数] [-x日数] [-w日数] [-i日期]帐号</code> &lt;==root功能<br>选项与参数：<br>–stdin ：可以透过来自前一个管线的资料，作为密码输入，对shell script 有帮助！<br>-l ：是Lock 的意思，会将/etc/shadow 第二栏最前面加上! 使密码失效；<br>-u ：与-l 相对，是Unlock 的意思！<br>-S ：列出密码相关参数，亦即shadow 文件内的大部分资讯。<br>-n ：后面接天数，shadow 的第4 栏位，多久不可修改密码天数<br>-x ：后面接天数，shadow 的第5 栏位，多久内必须要更动密码<br>-w ：后面接天数，shadow 的第6 栏位，密码过期前的警告天数<br>-i ：后面接『日期』，shadow 的第7 栏位，密码失效日期</p>
<p><strong>易错</strong>：要帮一般帐号建立密码需要使用<code>passwd 帐号</code>的格式，使用<code>passwd</code>表示修改自己的密码！</p>
<p>chage<br><code>chage [-ldEImMW]帐号名</code><br>选项与参数：<br>-l ：列出该帐号的详细密码参数；<br>-d ：后面接日期，修改shadow 第三栏位(最近一次更改密码的日期)，格式YYYY-MM-DD<br>-E ：后面接日期，修改shadow 第八栏位(帐号失效日)，格式YYYY-MM-DD<br>-I ：后面接天数，修改shadow 第七栏位(密码失效日期)<br>-m ：后面接天数，修改shadow 第四栏位(密码最短保留天数)<br>-M ：后面接天数，修改shadow 第五栏位(密码多久需要进行变更)<br>-W ：后面接天数，修改shadow 第六栏位(密码过期前警告日期)</p>
<p>usermod<br><code>usermod [-cdegGlsuLU] username</code><br>选项与参数：<br>-c ：后面接帐号的说明，即/etc/passwd 第五栏的说明栏，可以加入一些帐号的说明。<br>-d ：后面接帐号的家目录，即修改/etc/passwd 的第六栏；<br>-e ：后面接日期，格式是YYYY-MM-DD 也就是在/etc/shadow 内的第八个栏位资料啦！<br>-f ：后面接天数，为shadow 的第七栏位。<br>-g ：后面接初始群组，修改/etc/passwd 的第四个栏位，亦即是GID 的栏位！<br>-G ：后面接次要群组，修改这个使用者能够支援的群组，修改的是/etc/group 啰～<br>-a ：与-G 合用，可『增加次要群组的支援』而非『设定』喔！<br>-l ：后面接帐号名称。亦即是修改帐号名称， /etc/passwd 的第一栏！<br>-s ：后面接Shell 的实际文件，例如/bin/bash 或/bin/csh 等等。<br>-u ：后面接UID 数字啦！即/etc/passwd 第三栏的资料；<br>-L ：暂时将使用者的密码冻结，让他无法登入。其实仅改/etc/shadow 的密码栏。<br>-U ：将/etc/shadow 密码栏的! 拿掉，解冻啦！</p>
<p>userdel<br> <code>userdel [-r] username</code><br>选项与参数：<br>-r ：连同使用者的家目录也一起删除</p>
<h3 id="一般使用者常用的帐号相关指令id-finger-chfn-chsh"><a href="#一般使用者常用的帐号相关指令id-finger-chfn-chsh" class="headerlink" title="一般使用者常用的帐号相关指令id/finger/chfn/chsh"></a>一般使用者常用的帐号相关指令id/finger/chfn/chsh</h3><p>id<br><code>id [username]</code> 这个指令则可以查询某人或自己的相关UID/GID 等等的资讯</p>
<p>finger<br><code>finger [-s] username</code><br>选项与参数：<br>-s ：仅列出使用者的帐号、全名、终端机代号与登入时间等等；<br>-m ：列出与后面接的帐号相同者，而不是利用部分比对(包括全名部分)</p>
<p>结果：<br>Never logged in.：<code>figner</code> 还会调查使用者登入主机的情况喔！<br>No mail.：调查<code>/var/spool/mail</code>当中的信箱资料；<br>No Pl​​an.：调查<code>~vbird1/.plan</code> 文件，并将该文件取出来说明</p>
<p>chfn 有点像是： change finger 的意思！<br><code>chfn [-foph] [帐号名]</code><br>选项与参数：<br>-f ：后面接完整的大名；<br>-o ：您办公室的房间号码；<br>-p ：办公室的电话号码；<br>-h ：家里的电话号码！</p>
<p>chsh 这就是change shell 的简写！使用方法就更简单了！</p>
<p><code>chsh [-ls]</code><br>选项与参数：<br>-l ：列出目前系统上面可用的shell ，其实就是/etc/shells 的内容！<br>-s ：设定修改自己的Shell 啰</p>
<h3 id="新增与移除群组groupadd-groupmod-groupdel"><a href="#新增与移除群组groupadd-groupmod-groupdel" class="headerlink" title="新增与移除群组groupadd/groupmod/groupdel"></a>新增与移除群组groupadd/groupmod/groupdel</h3><p><code>groupadd [-g gid] [-r]群组名称</code><br>选项与参数：<br>-g ：后面接某个特定的GID ，用来直接给予某个GID ～<br>-r ：建立系统群组啦！与/etc/login.defs 内的GID_MIN 有关。</p>
<p><code>groupmod [-g gid] [-n group_name]群组名</code><br>选项与参数：<br>-g ：修改既有的GID 数字；<br>-n ：修改既有的群组名称</p>
<p>groupdel 自然就是在删除群组</p>
<h3 id="gpasswd：群组管理员功能"><a href="#gpasswd：群组管理员功能" class="headerlink" title="gpasswd：群组管理员功能"></a>gpasswd：群组管理员功能</h3><p>关于系统管理员(root)做的动作：<br><code>gpasswd groupname</code><br><code>gpasswd [-A user1,...] [-M user3,...] groupname</code><br><code>gpasswd [-rR] groupname</code><br>选项与参数：<br>    ：若没有任何参数时，表示给予groupname 一个密码(<code>/etc/gshadow</code>)<br>-A ：将groupname 的主控权交由后面的使用者管理(该群组的管理员)<br>-M ：将某些帐号加入这个群组当中！<br>-r ：将groupname 的密码移除<br>-R ：让groupname 的密码栏失效</p>
<p>关于群组管理员(Group administrator)做的动作：<br><code>gpasswd [-ad] user groupname</code><br>选项与参数：<br>-a ：将某位使用者加入到groupname 这个群组当中！<br>-d ：将某位使用者移除出groupname 这个群组当中。</p>
<h2 id="ACL的使用（Access-Control-List）"><a href="#ACL的使用（Access-Control-List）" class="headerlink" title="ACL的使用（Access Control List）"></a>ACL的使用（Access Control List）</h2><h2 id="使用者身份切换"><a href="#使用者身份切换" class="headerlink" title="使用者身份切换"></a>使用者身份切换</h2><p><code>su [-lm] [-c指令] [username]</code><br>选项与参数：</p>
<ul>
<li>：单纯使用- 如『 su - 』代表使用login-shell 的变数文件读取方式来登入系统；<pre><code>若使用者名称没有加上去，则代表切换为root 的身份。
</code></pre>-l ：与- 类似，但后面需要加欲切换的使用者帐号！也是login-shell 的方式。<br>-m ：-m 与-p 是一样的，表示『使用目前的环境设定，而不读取新使用者的设定档』<br>-c ：仅进行一次指令，所以-c 后面可以加上指令喔！</li>
</ul>
<p>单纯使用<code>su</code> 切换成为root的身份，读取的变数设定方式为<code>non-login shell</code>的方式，这种方式很多原本的变数不会被改变，尤其是我们之前谈过很多次的PATH这个变数，由于没有改变成为root的环境，因此很多root惯用的指令就只能使用绝对路径来执行咯。其他的还有MAIL这个变数，你输入mail时，收到的邮件竟然还是dmtsai的，而不是root本身的邮件！是否觉得很奇怪啊！所以切换身份时，<strong>务必</strong>使用<code>su -</code>!</p>
<p><code>sudo [-b] [-u新使用者帐号]</code><br>选项与参数：<br>-b ：将后续的指令放到背景中让系统自行执行，而不与目前的shell 产生影响<br>-u ：后面可以接欲切换的使用者，若无此项则代表切换身份为root 。</p>
<p><strong>sudo执行的重点是</strong>：『能否使用sudo<strong>必须</strong>要看<code>/etc/sudoers</code>的设定值，而可使用sudo者是透过输入使用者自己的密码来执行后续的指令串』喔！</p>
<h3 id="visudo-与-etc-sudoers"><a href="#visudo-与-etc-sudoers" class="headerlink" title="visudo 与/etc/sudoers"></a>visudo 与<code>/etc/sudoers</code></h3><p>除了root之外的其他帐号，若想要使用sudo执行属于root的权限指令，则root需要先使用visudo去修改<code>/etc/sudoers</code> ，让该帐号能够使用全部或部分的root指令功能。</p>
<h2 id="使用者的特殊shell-与PAM-模组"><a href="#使用者的特殊shell-与PAM-模组" class="headerlink" title="使用者的特殊shell 与PAM 模组"></a>使用者的特殊shell 与PAM 模组</h2><p>PAM (Pluggable Authentication Modules, 嵌入式模组) </p>
<h2 id="用户信息查询"><a href="#用户信息查询" class="headerlink" title="用户信息查询"></a>用户信息查询</h2><h3 id="查询用户：-last-lastlog"><a href="#查询用户：-last-lastlog" class="headerlink" title="查询用户： last, lastlog"></a>查询用户： last, lastlog</h3><p>查询目前已登入在系统  <code>w, who,</code></p>
<p>查询每个帐户的最近登入的时间，则可以使用lastlog</p>
<h3 id="用户对话-write-mesg-wall"><a href="#用户对话-write-mesg-wall" class="headerlink" title="用户对话 write, mesg, wall"></a>用户对话 write, mesg, wall</h3><p><code>write vbird1 pts/2</code></p>
<h3 id="用户邮件信箱：-mail"><a href="#用户邮件信箱：-mail" class="headerlink" title="用户邮件信箱： mail"></a>用户邮件信箱： mail</h3><h3 id="帐号相关的检查工具pwck、pwconv、pwunconv"><a href="#帐号相关的检查工具pwck、pwconv、pwunconv" class="headerlink" title="帐号相关的检查工具pwck、pwconv、pwunconv"></a>帐号相关的检查工具pwck、pwconv、pwunconv</h3><p>pwck<br><code>pwck</code>这个指令在检查<code>/etc/passwd</code> 这个帐号设定档内的资讯，与实际的家目录是否存在等资讯， 还可以比对<code>/etc/passwd /etc/shadow</code>的资讯是否一致，另外，如果<code>/etc/ passwd</code> 内的资料栏位错误时，会提示使用者修订。</p>
<p>pwconv</p>
<p>这个指令主要的目的是在『将/<code>etc/passwd</code> 内的帐号与密码，移动到<code>/etc/shadow</code> 当中！』<br>如果您正常使用useradd 增加使用者时，使用pwconv 并不会有任何的动作，因为<code>/etc/passwd</code>与 <code>/etc/shadow</code>并不会有上述两点问题,不过，如果手动设定帐号，这个pwconv 就很重要</p>
<p>pwunconv</p>
<p>将/etc/shadow 内的密码栏资料写回/etc/passwd 当中， 并且删除/etc/shadow 文件。 一般不要用！</p>
<p>chpasswd</p>
<p>读入未加密前的密码，并且经过加密后，​​ 将加密后的密码写入<code>/etc/shadow</code>当中。』这个指令很常被使用在大量建置帐号的情况中喔！他可以由Standard input 读入资料，每行数据的格式是『 <code>username:password</code> 』</p>
<h3 id="大量建置帐号范本"><a href="#大量建置帐号范本" class="headerlink" title="大量建置帐号范本"></a>大量建置帐号范本</h3>]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> 管理 </tag>
            
            <tag> 帐户 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux文件系统管理基础学习笔记]]></title>
      <url>/2016/03/%E5%BE%85%E6%95%B4%E7%90%86/Linux-%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="文件系统基本知识"><a href="#文件系统基本知识" class="headerlink" title="文件系统基本知识"></a>文件系统基本知识</h2><p>我们称呼一个可被挂载的数据为一个文件系统而不是一个分区！</p>
<p>一个文件系统，文件内容和很多属性，这种数据放在不同和块中，常用的有三个：</p>
<ul>
<li><p>superblock：记录此filesystem 的整体资讯，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关资讯等；</p>
</li>
<li><p>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block 号码；（能找到inode,就可以找到它的block）</p>
</li>
<li><p>block：实际记录文件的内容，若文件太大时，会占用多个block 。</p>
</li>
</ul>
<p>这种数据存取的方法我们称为<strong>索引式文件系统(</strong>indexed allocation)。</p>
<p>文件系统一开始就将inode与block规划好了，除非重新格式化(或者利用resize2fs等指令变更文件系统大小)，否则inode与block固定后就不再变动。<br><a id="more"></a></p>
<h2 id="EXT2文件系统（Linux-second-extended-file-system-）"><a href="#EXT2文件系统（Linux-second-extended-file-system-）" class="headerlink" title="EXT2文件系统（Linux second extended file system ）"></a>EXT2文件系统（Linux second extended file system ）</h2><p>Ext2文件系统主要有：boot sector, superblock, inode bitmap, block bitmap, inode table, data block 等六大部分。</p>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>Ext2 文件系统的block特点：</p>
<ul>
<li><p>原则上，block 的大小与数量在格式化完就不能够再改变了(除非重新格式化)；</p>
</li>
<li><p>每个block 内最多只能够放置一个文件的资料；</p>
</li>
<li><p>承上，如果文件大于block 的大小，则一个文件会占用多个block 数量；</p>
</li>
<li><p>承上，若文件小于block ，则该block 的剩余容量就不能够再被使用了(磁盘空间会浪费)。</p>
</li>
</ul>
<p>综上：大的block 可能会产生较严重的磁盘容量浪费，但是如果block 较小的话，那么大型文件将会占用数量更多的block ，而inode 也要记录更多的block 号码，此时将可能导致文件系统不良的读写效能。 所以一般选择4K,(现在的磁盘都很大！)</p>
<h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p>inode的数量与大小也是在格式化时就已经固定，其他特点：</p>
<ul>
<li><p>每个inode 大小均固定为128 bytes (新的ext4 与xfs 可设定到256 bytes)；</p>
</li>
<li><p>每个文件（**不管是一般文件还是目录文件）都仅会占用一个inode 而已；</p>
</li>
<li><p>承上，因此文件系统能够建立的文件数量与inode 的数量有关；</p>
</li>
<li><p>系统读取文件时需要先找到inode，并分析inode 所记录的权限与使用者是否符合，若符合才能够开始实际读取 block 的内容。</p>
</li>
</ul>
<p>inode的大小是有限的，一个block号码要4byte，为了记录更多的数据 ，系统规定：</p>
<blockquote>
<p>将inode 记录block 号码的区域定义为12个直接，一个间接, 一个双间接与一个三间接记录区。</p>
</blockquote>
<p>inode 能够指定多少个block 呢？我们以较小的1K block 来说明好了，可以指定的情况如下：</p>
<p>12个直接指向： <code>12*1K=12K</code><br>由于是直接指向，所以总共可记录12笔记录，因此总额大小为如上所示；</p>
<p>间接： <code>256*1K=256K</code><br>每笔block号码的记录会花去4bytes，因此1K的大小能够记录256笔记录，因此一个间接可以记录的文件大小如上； </p>
<p>双间接： <code>256*256*1K=256 2 K</code><br>第一层block会指定256个第二层，每个第二层可以指定256个号码，因此总额大小如上；</p>
<p>三间接： <code>256*256*256*1K=256 3 K</code><br>第一层block会指定256个第二层，每个第二层可以指定256个第三层，每个第三层可以指定256个号码，因此总额大小如上；</p>
<p>总额：将直接、间接、双间接、三间接加总，得到<code>12 + 256 + 256*256 + 256*256*256 (K) = 16GB</code></p>
<p>Ext4 文件系统的inode 容量已经可以扩大到256bytes 了，更大的inode 容量，可以纪录更多的文件系统资讯，包括新的ACL 以及SELinux 类型等， 当然，可以纪录的单一文件容量达16TB 且单一文件系统总容量可达1EB 哩！</p>
<h3 id="superblock"><a href="#superblock" class="headerlink" title="superblock"></a>superblock</h3><p>一般来说， superblock的大小为1024bytes superblock的功能：</p>
<ul>
<li><p>block 与inode 的总量；</p>
</li>
<li><p>未使用与已使用的inode / block 数量；</p>
</li>
<li><p>block 与inode 的大小(block 为1, 2, 4K，inode 为128bytes 或256bytes)；</p>
</li>
<li><p>filesystem 的挂载时间、最近一次写入资料的时间、最近一次检验磁盘(fsck) 的时间等文件系统的相关资讯；</p>
</li>
<li><p>一个valid bit 数值，若此文件系统已被挂载，则valid bit 为0 ，若未被挂载，则valid bit 为1。</p>
</li>
</ul>
<h3 id="Filesystem-Description-文件系统描述说明"><a href="#Filesystem-Description-文件系统描述说明" class="headerlink" title="Filesystem Description (文件系统描述说明)"></a>Filesystem Description (文件系统描述说明)</h3><h3 id="block-bitmap-区块对照表"><a href="#block-bitmap-区块对照表" class="headerlink" title="block bitmap (区块对照表)"></a>block bitmap (区块对照表)</h3><h3 id="inode-bitmap-inode-对照表"><a href="#inode-bitmap-inode-对照表" class="headerlink" title="inode bitmap (inode 对照表)"></a>inode bitmap (inode 对照表)</h3><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h2 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h2><p>EXT家族支持度最广，但格式化超慢！</p>
<h3 id="文件系统与目录树"><a href="#文件系统与目录树" class="headerlink" title="文件系统与目录树"></a>文件系统与目录树</h3><p>我们在Linux下的文件系统建立一个目录时，文件系统会分配一个inode与至少一块block给该目录。</p>
<p>inode本身并不记录文件名，文件名的记录是在目录的block当中。<br>所以 新增/删除/更名文件名与目录的w权限有关！！那么因为文件名是记录在目录的block当中，因此当我们要读取某个文件时，就务必会经过目录的inode与block，然后才能够找到那个待读取文件的inode号码，最终才会读到正确的文件的block内的数据 。</p>
<p>查询root 主目录内的文件所占用的inode 号码时，可以使用<code>ls -i</code>这个选项来处理：</p>
<h3 id="文件的存取"><a href="#文件的存取" class="headerlink" title="文件的存取"></a>文件的存取</h3><p>新增一个文件，此时文件系统的行为是：</p>
<ol>
<li><p>先确定使用者对于欲新增文件的目录是否具有w 与x 的权限，若有的话才能新增；</p>
</li>
<li><p>根据inode bitmap 找到没有使用的inode 号码，并将新文件的权限/属性写入；</p>
</li>
<li><p>根据block bitmap 找到没有使用中的block 号码，并将实际的数据写入block 中，且更新inode 的block 指向数据；</p>
</li>
<li><p>将刚刚写入的inode 与block 资料同步更新inode bitmap 与block bitmap，并更新superblock 的内容。</p>
</li>
</ol>
<p>为了检查文件的一下致性，引入了<strong>日志式文件系统</strong>（journaling filesystem）概念。<br>当数据的纪录过程当中发生了问题，那么我们的系统只要去检查日志记录区块， 就可以知道哪个文件发生了问题，针对该问题来做一致性的检查即可，而不必针对整块filesystem 去检查， 这样就可以达到快速修复filesystem </p>
<h3 id="非同步处理概念"><a href="#非同步处理概念" class="headerlink" title="非同步处理概念"></a>非同步处理概念</h3><p>当系统载入一个文件到内存后，如果该文件没有被更动过，则在内存内的文件数据会被设定为干净(clean)的。 但如果内存中的文件数据被更改过了(例如你用nano去编辑过这个文件)，此时该内存中的数据会被设定为脏的(Dirty)。此时所有的动作都还在内存中执行，并没有写入到硬盘中！系统会<strong>不定时的</strong>将内存中设定为Dirty的数据 写回，以保持硬盘与内存数据的一致性。</p>
<h3 id="Linux-VFS-（Vistual-Filesystem-Siwitch）"><a href="#Linux-VFS-（Vistual-Filesystem-Siwitch）" class="headerlink" title="Linux VFS （Vistual Filesystem Siwitch）"></a>Linux VFS （Vistual Filesystem Siwitch）</h3><p>为了可以支持多种filesystem ,整个Linux 的系统都是透过一个名为Virtual Filesystem Switch 的核心功能去读取filesystem 。</p>
<h2 id="XFS-filesystem"><a href="#XFS-filesystem" class="headerlink" title="XFS filesystem"></a>XFS filesystem</h2><p>xfs 这一个较适合<strong>高容量硬盘</strong>与<strong>巨型文件</strong>性能较佳的文件系统了。</p>
<p>xfs 文件系统在数据的分布上，主要规划为三个部份，一个数据区(data section)、一个文件系统活动登录区(log section)以及一个即时运作区(realtime section)。</p>
<h3 id="data-section"><a href="#data-section" class="headerlink" title="data section"></a>data section</h3><p>类似于EXT的block group , 只是inode 与block是动态产生，并非一开始于格式化就完成配置的。所以格式化动作超快！</p>
<h3 id="log-section"><a href="#log-section" class="headerlink" title="log section"></a>log section</h3><p>类似日志区，因为系统所有动作的时候都会在这个区块做个纪录，因此这个区块的硬盘活动是相当频繁的！所以最好有一个SSD</p>
<h3 id="realtime-section"><a href="#realtime-section" class="headerlink" title="realtime section"></a>realtime section</h3><p>当有文件要被建立时，xfs 会在这个区段里面找一个到数个的extent 区块，将文件放置在这个区块内，等到分配完毕后，再写入到data section 的inode 与block 去！这个extent 区块的大小得要在格式化的时候就先指定，最小值是4K 最大可到1G。一般非硬盘阵列的硬盘预设为64K，<br>而具有类似硬盘阵列的stripe 情况下，则建议extent 设定为与stripe 一样大较佳。</p>
<p>这个一般<strong>不要改动，很影响性能</strong>。</p>
<h2 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h2><h3 id="列出文件系统的整体磁盘使用量操作-df"><a href="#列出文件系统的整体磁盘使用量操作-df" class="headerlink" title="列出文件系统的整体磁盘使用量操作 df"></a>列出文件系统的整体磁盘使用量操作 df</h3><p><code>df [-ahikHTm] [目录或文件名]</code><br>选项与参数：<br>-a ：列出所有的文件系统，包括系统特有的<code>/proc</code> 等文件系统；<br>-k ：以KBytes 的容量显示各文件系统；<br>-m ：以MBytes 的容量显示各文件系统；<br>-h ：<strong><em>以人们较易阅读的GBytes, MBytes, KBytes 等格式自行显示；</em></strong><br>-H ：以M=1000K 取代M=1024K 的进位方式；<br>-T ：连同该partition 的filesystem 名称(例如xfs) 也列出；<br>-i ：不用磁盘容量，而以inode 的数量来显示</p>
<p>在Linux 底下如果df 没有加任何选项，那么预设会将系统内所有的 (不含特殊内存内的文件系统与swap) 都以1 Kbytes 的容量来列出来！</p>
<p>du读取的范围主要是在Superblock 内的内容， 所以这个指令显示结果的速度非常的快速！</p>
<h3 id="du操作"><a href="#du操作" class="headerlink" title="du操作"></a>du操作</h3><p><code>du [-ahskm]文件或目录名称</code><br>选项与参数：<br>-a ：列出所有的文件与目录容量，因为预设仅统计目录底下的文件量而已。<br>-h ：以人们较易读的容量格式(G/M) 显示；<br>-s ：列出总量而已，而不列出每个各别的目录占用容量；<br>-S ：不包括子目录下的总计，与-s 有点差别。<br>-k ：以KBytes 列出容量显示；<br>-m ：以MBytes 列出容量显示；</p>
<p>du 这个指令其实会直接到文件系统内去搜寻所有的文件数据 ，所以比较慢。<br>常用命令：<code>du -sm /*</code><br>这是个很常被使用的功能～模糊字母* 来代表每个目录，如果想要检查某个目录下，哪个次目录占用最大的容量，可以用这个方法找出来。</p>
<h3 id="Hard-Link-amp-Symbolic-Link（待研究）"><a href="#Hard-Link-amp-Symbolic-Link（待研究）" class="headerlink" title="Hard Link &amp; Symbolic Link（待研究）"></a>Hard Link &amp; Symbolic Link（待研究）</h3><h2 id="硬盘操作"><a href="#硬盘操作" class="headerlink" title="硬盘操作"></a>硬盘操作</h2><h3 id="列出系统上的所有硬盘列表-lsblk"><a href="#列出系统上的所有硬盘列表-lsblk" class="headerlink" title="列出系统上的所有硬盘列表 lsblk"></a>列出系统上的所有硬盘列表 lsblk</h3><p>(list block device)<br><code>lsblk [-dfimpt] [device]</code><br>选项与参数：<br>-d ：仅列出磁盘本身，并不会列出该磁盘的分割资料<br>-f ：同时列出该磁盘内的文件系统名称<br>-i ：使用ASCII 的线段输出，不要使用复杂的编码(再某些环境下很有用)<br>-m ：同时输出该装置在/dev 底下的权限资料(rwx 的资料)<br>-p ：列出该装置的完整文件名！而不是仅列出最后的名字而已。<br>-t ：列出该磁盘装置的详细资料，包括磁盘伫列机制、预读写的资料量大小等</p>
<p>RM：是否为可卸载装置(removable device)，如光碟、USB 磁盘等等<br>RO：是否为唯读装置的意思<br>TYPE：是磁盘(disk)、分区(partition) 还是只读(rom) 等输出<br>MOUTPOINT：就是前一章谈到的挂载点！</p>
<h3 id="装置的UUID等参数查看blkid"><a href="#装置的UUID等参数查看blkid" class="headerlink" title="装置的UUID等参数查看blkid"></a>装置的UUID等参数查看blkid</h3><h3 id="列出硬盘的分区类型与分区信息查看-parted"><a href="#列出硬盘的分区类型与分区信息查看-parted" class="headerlink" title="列出硬盘的分区类型与分区信息查看 parted"></a>列出硬盘的分区类型与分区信息查看 parted</h3><h3 id="磁盘分割操作：-gdisk-fdisk"><a href="#磁盘分割操作：-gdisk-fdisk" class="headerlink" title="磁盘分割操作： gdisk/fdisk"></a>磁盘分割操作： gdisk/fdisk</h3><h3 id="格式化操作-mkfs-ext4"><a href="#格式化操作-mkfs-ext4" class="headerlink" title="格式化操作 mkfs.ext4"></a>格式化操作 mkfs.ext4</h3><h2 id="文件系统挂载与卸载"><a href="#文件系统挂载与卸载" class="headerlink" title="文件系统挂载与卸载"></a>文件系统挂载与卸载</h2><h3 id="挂载操作-mount"><a href="#挂载操作-mount" class="headerlink" title="挂载操作 mount"></a>挂载操作 mount</h3><p>的几个原则：<br>单一文件系统不应该被重复挂载在不同的挂载点(目录)中；<br>单一目录不应该重复挂载多个文件系统；<br>要作为挂载点的目录，理论上应该都是空目录才是。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount -a </span><br><span class="line">mount [-l] </span><br><span class="line">mount [-t文件系统] LABEL=&apos;&apos;挂载点 </span><br><span class="line">mount [-t文件系统] UUID=&apos;&apos;挂载点  #鸟哥近期建议用这种方式喔！</span><br><span class="line">mount [-t文件系统]装置文件名挂载点</span><br></pre></td></tr></table></figure>
<p>选项与参数：<br>-a ：依照设定档/etc/fstab的数据将所有未挂载的磁盘都挂载上来<br>-l ：单纯的输入mount 会显示目前挂载的信息。加上-l 可增列Label 名称！<br>-t ：可以加上文件系统种类来指定欲挂载的类型。常见的Linux 支援类型有：xfs, ext3, ext4,<br>      reiserfs, vfat, iso9660(光碟格式), nfs, cifs, smbfs (后三种为网路文件系统类型)</p>
<h3 id="开机挂载操作-etc-fstab-及-etc-mtab"><a href="#开机挂载操作-etc-fstab-及-etc-mtab" class="headerlink" title="开机挂载操作 /etc/fstab 及 etc/mtab"></a>开机挂载操作 /etc/fstab 及 etc/mtab</h3><p>开机自动挂载可参考/etc/fstab之设定，设定完毕务必使用mount -a 测试语法正确否；</p>
<h3 id="loop挂载操作"><a href="#loop挂载操作" class="headerlink" title="loop挂载操作"></a>loop挂载操作</h3><p>例子 ：我们可以建立大文件以制作loop 装置文件！</p>
<p><code>mount -o loop UUID=&quot;7dd97bd2-4446-48fd-9d23-a8b03ffdd5ee&quot; /mnt(目标目录)</code></p>
<h2 id="内存交换swap"><a href="#内存交换swap" class="headerlink" title="内存交换swap"></a>内存交换swap</h2><h2 id="文件的压缩"><a href="#文件的压缩" class="headerlink" title="文件的压缩"></a>文件的压缩</h2><h3 id="文件压缩常见命令-gzip-zcat-zmore-zless-zgrep"><a href="#文件压缩常见命令-gzip-zcat-zmore-zless-zgrep" class="headerlink" title="文件压缩常见命令 gzip zcat/zmore/zless/zgrep"></a>文件压缩常见命令 gzip zcat/zmore/zless/zgrep</h3><p>gzip 可以说是应用度最广的压缩指令了！<br><code>gzip [-cdtv#]文件名</code><br><code>zcat文件名.gz</code><br>选项与参数：<br>-c ：将压缩的资料输出到萤幕上，可透过资料流重导向来处理；<br>-d ：解压缩的参数；<br>-t ：可以用来检验一个压缩档的一致性～看看文件有无错误；<br>-v ：可以显示出原文件/压缩文件的压缩比等资讯；<br>-# ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！预设是-6</p>
<p>bzip2压缩率高，对于大容量文件来说，bzip2 压缩时间会花比较久</p>
<p><code>bzip2 [-cdkzv#]文件名</code><br><code>bzcat文件名.bz2</code><br>选项与参数：<br>-c ：将压缩的过程产生的资料输出到萤幕上！<br>-d ：解压缩的参数<br>-k ：保留原始文件，而不会删除原始的文件喔！<br>-z ：压缩的参数(预设值，可以不加)<br>-v ：可以显示出原文件/压缩文件的压缩比等资讯；<br>-# ：与gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！(默认是6，很不错的)</p>
<p>xz压缩率更高，对于大容量文件来说，xz 压缩时间会花更久</p>
<p><code>xz [-dtlkc#]文件名</code><br><code>xcat 文件名.xz</code><br>选项与参数：<br>-d ：就是解压缩啊！<br>-t ：测试压缩档的完整性，看有没有错误<br>-l ：列出压缩档的相关资讯<br>-k ：保留原本的文件不删除～<br>-c ：同样的，就是将资料由萤幕上输出的意思！<br>-# ：同样的，也有较佳的压缩比的意思！</p>
<h3 id="打包指令-tar"><a href="#打包指令-tar" class="headerlink" title="打包指令 tar"></a>打包指令 tar</h3><p>他的参数是非常多，常用的有：<br>压缩：<code>tar -j c v -f filename.tar.bz2要被压缩的文件或目录名称</code><br>查询：<code>tar -j t v -f filename.tar.bz2</code><br>解压缩：<code>tar -j x v -f filename.tar.bz2 -C欲解压缩的目录</code></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> 管理 </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LinuxShell学习笔记]]></title>
      <url>/2016/03/%E5%BE%85%E6%95%B4%E7%90%86/Linux-%E7%AC%94%E8%AE%B0-Shell/</url>
      <content type="html"><![CDATA[<h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>由于kernel在内存中是受保护的区块，因此我们必须要透过『 Shell 』将我们输入的指令与Kernel 沟通，好让 Kernel 可以控制硬件来正确无误的工作。</p>
<p>什么是shell?<br>只要能够操作应用程序的介面都能够称为shell。狭义的shell指的是命令列方面的软件，包括bash  等。广义的sell则包括图形介面的软件！</p>
<p>怎么知道我有多少种 shell可以用？<br>检查一下<code>/etc/shells</code>这个文件 输入：<code>cat /etc/shell</code>.<br><a id="more"></a></p>
<p>###主要功能</p>
<ol>
<li><p>命令记忆 history<br>预设的指令记忆功能可以到达1000 个！保存在你的主目录内的<code>.bash_history</code>中， 注意的是，没有关机前暂时在<code>~/.bash_history</code></p>
</li>
<li><p>命令补全 tab</p>
</li>
</ol>
<p>[Tab] 接在一串指令的第一个字的后面，则为命令补全；<br>[Tab] 接在一串指令的第二个字以后时，则为文件补齐！<br>若安装bash-completion 软件，则在某些指令后面使用[tab] 按键时，​​可以进行选项/参数的补齐功能！</p>
<ol>
<li>命令别名设置（alias）</li>
</ol>
<p>例如 ： <code>alias lm=&#39;ls -al&#39;</code></p>
<ol>
<li><p>工作控制、前台后台控制： (job control, foreground, background)</p>
</li>
<li><p>sell script</p>
</li>
<li><p>通配符 </p>
</li>
</ol>
<h3 id="内置命令-type"><a href="#内置命令-type" class="headerlink" title="内置命令 type"></a>内置命令 type</h3><p><code>type [-tpa] name</code><br>选项与参数：<br>    ：不加任何选项与参数时，type 会显示出name 是外部指令还是bash 内建指令<br>-t ：当加入-t 参数时，type 会将name 以底下这些字眼显示出他的意义：<br>      file ：表示为外部指令；<br>      alias ：表示该指令为命令别名所设定的名称；<br>      builtin ：表示该指令为bash 内建的指令功能；<br>-p ：如果后面接的name 为外部指令时，才会显示完整文件名；<br>-a ：会由PATH 变数定义的路径中，将所有含name 的指令都列出来，包含alias</p>
<h3 id="快输编辑"><a href="#快输编辑" class="headerlink" title="快输编辑"></a>快输编辑</h3><p><code>[ctrl]+u/[ctrl]+k</code>    分别是从游标处向前删除指令串(<code>[ctrl]+u)</code> 及向后删除指令串(<code>[ctrl]+k</code>)。<br><code>[ctrl]+a/[ctrl]+e</code>    分别是让游标移动到整个指令串的最前面(<code>[ctrl]+a</code>) 或最后面([<code>ctrl]+e</code>)。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的显示与设置echo-unset"><a href="#变量的显示与设置echo-unset" class="headerlink" title="变量的显示与设置echo/unset/"></a>变量的显示与设置echo/unset/</h3><p>区别与自定变量的不同，环境变量通常以大写字母来表示</p>
<p>显示出您的环境变量 HOME <code>echo $HOME或者是echo ${HOME}</code></p>
<p>变量的设定用等号<code>=</code>连接变量与他的内容，其规则：</p>
<ol>
<li><p>变数与变数内容以一个等号<code>=</code>来连结，如下所示： <code>myname=VBird</code></p>
</li>
<li><p>等号两边不能直接接空白字母，如下所示为错误：<code>myname = VBird或myname=VBird Tsai</code></p>
</li>
<li><p>变数名称只能是英文字母与数字，但是开头字母不能是数字，如下为错误： <code>2myname=VBird</code></p>
</li>
<li><p>变数内容若有空白字母可使用双引号<code>&quot;</code>或单引号<code>&#39;</code>将变数内容结合起来，但<br>双引号内的特殊字母如$等，可以保有原本的特性，如下所示：<br><code>var=&quot;lang is $LANG&quot;则echo $var可得lang is zh_TW.UTF-8</code><br>单引号内的特殊字母则仅为一般字母(纯文字)，如下所示：<br><code>var=&#39;lang is $LANG&#39;则echo $var可得lang is $LANG</code></p>
</li>
<li><p>可用跳脱字母<code>\</code> 将特殊符号(<code>如[Enter], $, \,空白字母, &#39;等</code>)变成一般字母，如：<br><code>myname=VBird\ Tsai</code></p>
</li>
</ol>
<p>6.在一串指令的执行中，还需要藉由其他额外的指令所提供的w信息时，可以使用反单引号<code>指令</code>或<code>$(指令)</code>。特别注意，那个<code>是键盘上方的数字键1左边那个按键，而不是单引号！例如想要取得核心版本的设定：</code>version=$(uname -r)再echo $version可得3.10.0-229.el7.x86_64`</p>
<ol>
<li><p>若该变数为扩增变量的内容时，则可用<code>&quot;$变数名称&quot;</code>或<code>${变数}</code>累加内容，如下所示：<br><code>PATH=&quot;$PATH&quot;:/home/bin或PATH=${PATH} :/home/bin</code></p>
</li>
<li><p>若该变数需要在其他子程序执行，则需要以export来使变数变成环境变数：<br><code>export PATH</code></p>
</li>
<li><p>通常大写字母为系统预设变数，自行设定变数可以使用小写字母，方便判断(纯粹依照使用者兴趣与嗜好) ；</p>
</li>
<li><p>取消变数的方法为使用<code>unset：unset变数名称</code>例如取消myname的设定：<br><code>unset myname</code></p>
</li>
</ol>
<h3 id="常见环境变量与查看环境变量命令env-所有变量查看命令-set"><a href="#常见环境变量与查看环境变量命令env-所有变量查看命令-set" class="headerlink" title="常见环境变量与查看环境变量命令env 所有变量查看命令 set"></a>常见环境变量与查看环境变量命令env 所有变量查看命令 set</h3><p>env = environment </p>
<p>bash 对于变数有几个基本的定义：</p>
<ol>
<li><p>变数类型预设为『字串』，所以若不指定变数类型，则1+2 </p>
</li>
<li><p>为一个『字串』而不是『计算式』。所以上述第一个执行的结果才会出现那个情况的；</p>
</li>
<li><p>bash 环境中的数值运算，预设最多仅能到达整数形态，所以1/3 结果是0；</p>
</li>
</ol>
<h3 id="export-自定变量转成环境变量-与子程序概念"><a href="#export-自定变量转成环境变量-与子程序概念" class="headerlink" title="export 自定变量转成环境变量 与子程序概念"></a>export 自定变量转成环境变量 与子程序概念</h3><p><strong>子程序</strong>仅会继承父程序的环境变数，子程序不会继承父程序的自定变数啦！</p>
<p>要让变数内容继续的在子程序中使用，那么就请执行：<code>export变数名称</code></p>
<h3 id="变量的有效范围"><a href="#变量的有效范围" class="headerlink" title="变量的有效范围"></a>变量的有效范围</h3><h3 id="变量的键盘读取、数组与声明：-read-array-declare"><a href="#变量的键盘读取、数组与声明：-read-array-declare" class="headerlink" title="变量的键盘读取、数组与声明： read, array, declare"></a>变量的键盘读取、数组与声明： read, array, declare</h3><p>read 读取来自键盘输入的变量<br><code>read [-pt] variable</code><br>选项与参数：<br>-p ：后面可以接提示字元！<br>-t ：后面可以接等待的『秒数！』这个比较有趣～不会一直等待使用者啦</p>
<p>declare或typeset是一样的功能，就是在『声明变量的类型』</p>
<p><code>declare [-aixr] variable</code><br>选项与参数：<br>-a ：将后面名为variable 的变数定义成为阵列(array) 类型<br>-i ：将后面名为variable 的变数定义成为整数数字(integer) 类型<br>-x ：用法与export 一样，就是将后面的variable 变成环境变数；<br>-r ：将变数设定成为readonly 类型，该变数不可被更改内容，也不能unset</p>
<p>数组变量类型的设置：</p>
<p><code>var [指数] =内容</code></p>
<h3 id="变量内容的删除、取代与替换-（Optional）"><a href="#变量内容的删除、取代与替换-（Optional）" class="headerlink" title="变量内容的删除、取代与替换 （Optional）"></a>变量内容的删除、取代与替换 （Optional）</h3><h2 id="别名与历史命令"><a href="#别名与历史命令" class="headerlink" title="别名与历史命令"></a>别名与历史命令</h2><h3 id="命令别名设定：-alias-unalias"><a href="#命令别名设定：-alias-unalias" class="headerlink" title="命令别名设定： alias/unalias"></a>命令别名设定： alias/unalias</h3><h2 id="Bash-shell-的操作环境"><a href="#Bash-shell-的操作环境" class="headerlink" title="Bash shell 的操作环境"></a>Bash shell 的操作环境</h2><p>bash 欢迎信息记录在：<code>/etc/issue</code></p>
<h3 id="shell环境设定"><a href="#shell环境设定" class="headerlink" title="shell环境设定"></a>shell环境设定</h3><p>login 与 non-login shell 的概念</p>
<p>login shell 下程序 读取的设定文件：</p>
<h3 id="常见的几个环境设定文件"><a href="#常见的几个环境设定文件" class="headerlink" title="常见的几个环境设定文件"></a>常见的几个环境设定文件</h3><p>系统：<br><code>/etc/profile：</code><strong>系统</strong>的设定，最好不要改</p>
<p>个人主要的三个设定文件有：(可以改动)</p>
<p><code>~/.bash_profile</code><br><code>~/.bash_login</code><br><code>~/.profile</code></p>
<p>其他的设定文件：<br><code>~/.bashrc</code>在  non-login shell的情况下读取，<br><code>~/.bash_logout</code>  记录了当退出bash后，系统动作<br><code>~/.bash_history</code> 历史命令的文件。</p>
<h2 id="数据重定向"><a href="#数据重定向" class="headerlink" title="数据重定向"></a>数据重定向</h2><h3 id="standard-output-与-standard-error-output"><a href="#standard-output-与-standard-error-output" class="headerlink" title="standard output 与 standard error output"></a>standard output 与 standard error output</h3><ol>
<li><p>标准输入　　(stdin) ：代码为 0 ，使用 <code>&lt; 或 &lt;&lt;</code>；</p>
</li>
<li><p>标准输出　　(stdout)：代码为 1 ，使用 <code>&gt; 或 &gt;&gt;</code> ; </p>
</li>
<li><p>标准错误输出(stderr)：代码为 2 ，使用 <code>2&gt; 或 2&gt;&gt;</code> ；</p>
</li>
</ol>
<p>注意的几点：</p>
<ul>
<li><p><code>&gt;</code> 是有覆盖的方式，而<code>&gt;&gt;</code>是以累加的方式，</p>
</li>
<li><p>要注意喔，<code>1&gt;&gt;</code> 以及<code>2&gt;&gt;</code> 中间是<strong>没有空格</strong>的!</p>
</li>
<li><p><code>&lt;&lt;</code>当遇见他后面接的字母时输入结束</p>
</li>
</ul>
<p>用法：</p>
<ul>
<li><p>将stdout与stderr分存到不同的文件去  <code>find /home -name .bashrc &gt; list_right 2&gt; list_error</code></p>
</li>
<li><p>将stdout与stderr分存到同一个文件去 <code>find /home - name .bashrc &gt; list 2&gt;&amp;1</code></p>
</li>
</ul>
<p><code>/dev/null</code> 可以吃掉任何导向这个装置的数据.</p>
<h3 id="一次输入多重命令"><a href="#一次输入多重命令" class="headerlink" title="一次输入多重命令"></a>一次输入多重命令</h3><p><strong>指令回传值$?</strong>概念 ：若前一个指令执行的结果为正确，在Linux底下会回传一个<code>$? = 0</code>的值</p>
<ul>
<li><p><code>cmd ; cmd</code>(不考虑指令相关性的连续指令下达) example :</p>
</li>
<li><p><code>CMD1 &amp;&amp; CMD2</code>     1.若cmd1执行完毕且正确执行<code>($?=0)</code>，则开始执行cmd2。2.若cmd1执行完毕且为错误<code>($?≠0)</code>，则cmd2不执行。</p>
</li>
<li><p><code>CMD1 || CMD2</code>1.若cmd1执行完毕且正确执行<code>($?=0)</code>，则cmd2不执行。2.若cmd1执行完毕且为错误<code>($?≠0)</code>，则开始执行cmd2。</p>
</li>
</ul>
<h2 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道 pipe"></a>管道 pipe</h2><p>管线命令仅会处理standard output，对于standard error output 会予以忽略；</p>
<p>管线命令<strong>必须</strong>要能够接受来自前一个指令的资料成为standard input 继续处理才行；</p>
<h3 id="选取命令-cut-grep"><a href="#选取命令-cut-grep" class="headerlink" title="选取命令 cut/grep"></a>选取命令 cut/grep</h3><p>cut 主要的用途在于将『同一行里面的数据进行分解！』最常使用在分析一些数据或文字资料的时候！cut 在处理多空格相连的资料时，会比较吃力一点。</p>
<p><code>cut -d&#39;分隔字符&#39; -f fields</code> &lt;==用于有特定分隔字元<br><code>cut -c字符区间</code>            &lt;==用于排列整齐的讯息<br>选项与参数：<br>-d ：后面接分隔字元。与-f 一起使用；<br>-f ：依据-d 的分隔字元将一段讯息分割成为数段，用-f 取出第几段的意思；<br>-c ：以字元(characters) 的单位取出固定字元区间；</p>
<p>grep 则是分析一行讯息， 若当中有我们所需要的资讯，就<strong>将该</strong>行拿出.</p>
<p><code>grep [-acinv] [--color=auto] &#39;搜寻字串&#39; filename</code><br>选项与参数：<br>-a ：将binary 文件以text 文件的方式搜寻资料<br>-c ：计算找到’搜寻字串’ 的次数<br>-i ：忽略大小写的不同，所以大小写视为相同<br>-n ：顺便输出行号<br>-v ：反向选择，亦即显示出没有’搜寻字串’ 内容的那一行！<br>–color=auto ：可以将找到的关键字部分加上颜色的显示(有的发行版已经预设了。)</p>
<h3 id="排序命令-sort-wc-uniq"><a href="#排序命令-sort-wc-uniq" class="headerlink" title="排序命令 sort/wc/uniq"></a>排序命令 sort/wc/uniq</h3><p>sort 可以依据不同的资料型态来排序</p>
<p><code>sort [-fbMnrtuk] [file or stdin]</code><br>选项与参数：<br>-f ：忽略大小写的差异，例如A 与a 视为编码相同；<br>-b  ：忽略最前面的空白字元部分；<br>-M ：以月份的名字来排序，例如JAN, DEC 等等的排序方法；<br>-n ：使用『纯数字』进行排序(预设是以文字型态来排序的)；<br>-r  ：反向排序；<br>-u ：就是uniq ，相同的资料中，仅出现一行代表；<br>-t ：分隔符号，预设是用[tab] 键来分隔；<br>-k ：以那个区间(field) 来进行排序的意思</p>
<p>uniq 排序完成后 想要将重复的资料仅列出一个显示</p>
<p><code>uniq [-ic]</code><br>选项与参数：<br>-i ：忽略大小写字元的不同；<br>-c ：进行计数</p>
<p>wc 计算输出的信息的整体资料(如行，列，字数)<br><code>wc [-lwm]</code><br>选项与参数：<br>-l ：仅列出行；<br>-w ：仅列出多少字(英文单字)；<br>-m  ：多少字元；</p>
<h3 id="双向重定向-tee"><a href="#双向重定向-tee" class="headerlink" title="双向重定向 tee"></a>双向重定向 tee</h3><p>tee 会同时将资料流分送到文件与萤幕(screen)上<br><code>tee [-a] file</code><br>选项与参数：<br>-a ：以累加(append) 的方式，将资料加入file 当中！</p>
<h3 id="字符转换命令：-tr-col-join-paste-expand"><a href="#字符转换命令：-tr-col-join-paste-expand" class="headerlink" title="字符转换命令： tr, col, join, paste, expand"></a>字符转换命令： tr, col, join, paste, expand</h3><h3 id="参数代换：-xargs"><a href="#参数代换：-xargs" class="headerlink" title="参数代换： xargs"></a>参数代换： xargs</h3><h3 id="关于减号-的用途"><a href="#关于减号-的用途" class="headerlink" title="关于减号 - 的用途"></a>关于减号 - 的用途</h3><p>当 我们需要将一个命令的的stdout 作为这次的stdin ， 而这个命令需要用到文件名称(例如tar) 来进行处理时 ，我们就可以使用<code>-</code> 代替filename.</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vim的使用]]></title>
      <url>/2016/03/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-vim%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="vim-简单操作"><a href="#vim-简单操作" class="headerlink" title="vim 简单操作"></a>vim 简单操作</h2><p>vi 三种模式：<br>command mode 一般命令模式；insert mode 编辑模式 ；command-line mode 命令行模式<br>操作：</p>
<ol>
<li><p>使用<code>vi filename</code>进入一般指令模式</p>
</li>
<li><p>按下<code>i</code>进入编辑模式，开始编辑文字</p>
</li>
<li><p>按下[ESC] 按钮回到一般指令模式<a id="more"></a></p>
</li>
<li><p>输入:wq即可存档离开！（如果你的文件权限不对，例如为-r–r–r–时，那么可能会无法写入，此时可以使用<code>:wq!</code>强制写入.</p>
</li>
</ol>
<h2 id="常用按键"><a href="#常用按键" class="headerlink" title="常用按键"></a>常用按键</h2><table>
<thead>
<tr>
<th>按键</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>光标移动</strong></td>
</tr>
<tr>
<td>h 或向左方向键(←)</td>
<td style="text-align:left">游标向左移动一个字母</td>
</tr>
<tr>
<td>j 或向下方向键(↓)</td>
<td style="text-align:left">游标向下移动一个字母</td>
</tr>
<tr>
<td>k 或向上方向键(↑)</td>
<td style="text-align:left">游标向上移动一个字母</td>
</tr>
<tr>
<td>l 或向右方向键(→)</td>
<td style="text-align:left">游标向右移动一个字母</td>
</tr>
<tr>
<td>如果你将右手放在键盘上的话，你会发现hjkl是排列在一起的，因此可以使用这四个按钮来移动游标。如果想要进行多次移动的话，例如向下移动30 列，可以使用”30j” 或”30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td>
</tr>
<tr>
<td>[Ctrl] + [f]</td>
<td style="text-align:left">萤幕向下移动一页，相当于[Page Down]按键( <strong>常用</strong> )</td>
</tr>
<tr>
<td>[Ctrl] + [b]</td>
<td style="text-align:left">萤幕向上移动一页，相当于[Page Up]按键( <strong>常用</strong> )</td>
</tr>
<tr>
<td>[Ctrl] + [d]</td>
<td style="text-align:left">萤幕向下移动半页</td>
</tr>
<tr>
<td>[Ctrl] + [u]</td>
<td style="text-align:left">萤幕向上移动半页</td>
</tr>
<tr>
<td>+</td>
<td style="text-align:left">游标移动到非空白字母的下一列</td>
</tr>
<tr>
<td>-</td>
<td style="text-align:left">游标移动到非空白字母的上一列</td>
</tr>
<tr>
<td>n<space></space></td>
<td style="text-align:left">那个n 表示数字，例如20 。按下数字后再按空白键，游标会向右移动这一列的n 个字母。例如20<space> 则游标会向后面移动20 个字母距离。</space></td>
</tr>
<tr>
<td>0 或功能键[Home]</td>
<td style="text-align:left">这是数字 0 ：移动到这一列的最前面字母处( <strong>常用</strong> )</td>
</tr>
<tr>
<td>$ 或功能键[End]</td>
<td style="text-align:left">移动到这一列的最后面字母处( <strong>常用</strong>)</td>
</tr>
<tr>
<td>H</td>
<td style="text-align:left">游标移动到这个萤幕的最上方那一列的第一个字母</td>
</tr>
<tr>
<td>M</td>
<td style="text-align:left">游标移动到这个萤幕的中央那一列的第一个字母</td>
</tr>
<tr>
<td>L</td>
<td style="text-align:left">游标移动到这个萤幕的最下方那一列的第一个字母</td>
</tr>
<tr>
<td>G</td>
<td style="text-align:left">移动到这个档案的最后一列(<strong> 常用</strong> )</td>
</tr>
<tr>
<td>nG</td>
<td style="text-align:left">n 为数字。移动到这个档案的第n 列。例如20G 则会移动到这个档案的第20 列(可配合:set nu)</td>
</tr>
<tr>
<td>gg</td>
<td style="text-align:left">移动到这个档案的第一列，相当于1G啊！( <strong>常用</strong> )</td>
</tr>
<tr>
<td>n<enter></enter></td>
<td style="text-align:left">n为数字。游标向下移动n列( <strong>常用</strong> )</td>
</tr>
<tr>
<td><strong>搜寻与取代</strong></td>
</tr>
<tr>
<td><code>/word</code></td>
<td style="text-align:left">向游标之下寻找一个名称为word的字串。例如要在档案内搜寻vbird这个字串，就输入<code>/vbird</code>即可！( <strong>常用 </strong>)</td>
</tr>
<tr>
<td><code>?word</code></td>
<td style="text-align:left">向游标之上寻找一个字串名称为word 的字串。</td>
</tr>
<tr>
<td><code>n</code></td>
<td style="text-align:left">这个n是英文按键。代表重复前一个搜寻的动作。举例来说，如果刚刚我们执行/vbird去向下搜寻vbird这个字串，则按下n后，会向下继续搜寻下一个名称为vbird的字串。如果是执行?vbird的话，那么按下n则会向上继续搜寻名称为vbird的字串！</td>
</tr>
<tr>
<td><code>N</code></td>
<td style="text-align:left">这个N 是英文按键。与n 刚好相反，为反向进行前一个搜寻动作。例如/vbird 后，按下N 则表示向上搜寻vbird 。</td>
</tr>
<tr>
<td><code>:n1,n2s/word1/word2/g</code></td>
<td style="text-align:left">n1与n2为数字。在第n1与n2列之间寻找word1这个字串，并将该字串取代为word2</td>
</tr>
<tr>
<td><code>:1,$s/word1/word2/g</code></td>
<td style="text-align:left">从第一列到最后一列寻找word1字串，并将该字串取代为word2 ！( <strong>常用</strong> )</td>
</tr>
<tr>
<td><code>:1,$s/word1/word2/gc</code></td>
<td style="text-align:left">从第一列到最后一列寻找word1字串，并将该字串取代为word2 ！且在取代前显示提示字母给使用者确认(confirm)是否需要取代！( <strong>常用</strong> )</td>
</tr>
<tr>
<td><strong><em>删除、复制与贴上</em></strong></td>
</tr>
<tr>
<td><code>x, X</code></td>
<td style="text-align:left">在一列字当中，x为向后删除一个字母(相当于[del]按键)， X为向前删除一个字母(相当于[backspace]亦即是倒退键) ( <strong>常用</strong> )</td>
</tr>
<tr>
<td><code>nx</code></td>
<td style="text-align:left">n 为数字，连续向后删除n 个字母。举例来说，我要连续删除10 个字母， 10xdd    删除游标所在的那一整列( <strong>常用</strong> )</td>
</tr>
<tr>
<td><code>ndd</code></td>
<td style="text-align:left">n为数字。删除游标所在的向下n列，例如20dd则是删除20列( <strong>常用</strong> )</td>
</tr>
<tr>
<td><code>d1G</code></td>
<td style="text-align:left">删除游标所在到第一列的所有资料</td>
</tr>
<tr>
<td><code>dG</code></td>
<td style="text-align:left">删除游标所在到最后一列的所有资料</td>
</tr>
<tr>
<td><code>d$</code></td>
<td style="text-align:left">删除游标所在处，到该列的最后一个字母</td>
</tr>
<tr>
<td><code>d0</code></td>
<td style="text-align:left">那个是数字的0 ，删除游标所在处，到该列的最前面一个字母</td>
</tr>
<tr>
<td><code>yy</code></td>
<td style="text-align:left">复制游标所在的那一列( <strong>常用</strong> )</td>
</tr>
<tr>
<td><code>nyy</code></td>
<td style="text-align:left">n为数字。复制游标所在的向下n列，例如20yy则是复制20列( <strong>常用</strong> )</td>
</tr>
<tr>
<td><code>y1G</code></td>
<td style="text-align:left">复制游标所在列到第一列的所有资料</td>
</tr>
<tr>
<td><code>yG</code></td>
<td style="text-align:left">复制游标所在列到最后一列的所有资料</td>
</tr>
<tr>
<td><code>y0</code></td>
<td style="text-align:left">复制游标所在的那个字母到该列行首的所有资料</td>
</tr>
<tr>
<td><code>y$</code></td>
<td style="text-align:left">复制游标所在的那个字母到该列行尾的所有资料</td>
</tr>
<tr>
<td><code>p, P</code></td>
<td style="text-align:left">p为将已复制的资料在游标下一列贴上，P则为贴在游标上一列！举例来说，我目前游标在第20列，且已经复制了10列资料。则按下p后，那10列资料会贴在原本的20列之后，亦即由21列开始贴。但如果是按下P呢？那么原本的第20列会被推到变成30列。( <strong>常用</strong> )</td>
</tr>
<tr>
<td><code>J</code></td>
<td style="text-align:left">将游标所在列与下一列的资料结合成同一列</td>
</tr>
<tr>
<td><code>c</code></td>
<td style="text-align:left">重复删除多个资料，例如向下删除10 列，[ 10cj ]</td>
</tr>
<tr>
<td><code>u</code></td>
<td style="text-align:left">复原前一个动作。( <strong>常用</strong> )</td>
</tr>
<tr>
<td><code>[Ctrl]+r</code></td>
<td style="text-align:left">重做上一个动作。( <strong>常用</strong> )</td>
</tr>
<tr>
<td>这个u 与[Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td>
</tr>
<tr>
<td><code>.</code></td>
<td style="text-align:left">不要怀疑！这就是小数点！意思是重复前一个动作的意思。如果你想要重复删除、重复贴上等等动作，按下小数点.就好了！( <strong>常用</strong> )</td>
</tr>
<tr>
<td><strong>进入插入或取代的编辑模式</strong></td>
</tr>
<tr>
<td><code>i, I</code></td>
<td style="text-align:left">进入插入模式(Insert mode)：i为从目前游标所在处插入， I为在目前所在列的第一个非空白字母处开始插入。( <strong>常用</strong> )</td>
</tr>
<tr>
<td><code>a, A</code></td>
<td style="text-align:left">进入插入模式(Insert mode)：a为从目前游标所在的下一个字母处开始插入， A为从游标所在列的最后一个字母处开始插入。( <strong>常用</strong>)</td>
</tr>
<tr>
<td><code>o, O</code></td>
<td style="text-align:left">进入插入模式(Insert mode)：这是英文字母o的大小写。o为在目前游标所在的下一列处插入新的一列；O为在目前游标所在处的上一列插入新的一列！( <strong>常用</strong> )</td>
</tr>
<tr>
<td><code>r, R</code></td>
<td style="text-align:left">进入取代模式(Replace mode)：r只会取代游标所在的那一个字母一次；R会一直取代游标所在的文字，直到按下ESC为止；( <strong>常用</strong> )</td>
</tr>
<tr>
<td>上面这些按键中，在vi 画面的左下角处会出现<code>--INSERT--</code>或<code>--REPLACE--</code>的字样。由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字母时， 一定要在左下角处看到INSERT 或REPLACE 才能输入喔！</td>
</tr>
<tr>
<td><code>[Esc]</code></td>
<td style="text-align:left">退出编辑模式，回到一般指令模式中(<strong>常用</strong> )</td>
</tr>
<tr>
<td><strong>指令列模式的储存、离开等指令</strong></td>
</tr>
<tr>
<td><code>:w</code></td>
<td style="text-align:left">将编辑的资料写入硬碟档案中( <strong>常用</strong> )</td>
</tr>
<tr>
<td><code>:w!</code></td>
<td style="text-align:left">若档案属性为只读时，强制写入该档案。</td>
</tr>
<tr>
<td><code>:q</code></td>
<td style="text-align:left">离开vi ( <strong>常用</strong>)</td>
</tr>
<tr>
<td><code>:q!</code></td>
<td style="text-align:left">若曾修改过档案，又不想储存，使用! 为强制离开不储存档案。</td>
</tr>
<tr>
<td><code>:wq</code></td>
<td style="text-align:left">储存后离开，若为:wq!则为强制储存后离开( <strong>常用</strong> )</td>
</tr>
<tr>
<td><code>ZZ</code></td>
<td style="text-align:left">若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td>
</tr>
<tr>
<td><code>:w [filename]</code></td>
<td style="text-align:left">将编辑的资料储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td><code>:r [filename]</code></td>
<td style="text-align:left">在编辑的资料中，读入另一个档案的资料。亦即将filename这个档案内容加到游标所在列后面</td>
</tr>
<tr>
<td><code>:n1,n2 w [filename]</code></td>
<td style="text-align:left">将n1 到n2 的内容储存成filename 这个档案。</td>
</tr>
<tr>
<td><code>:! command</code></td>
<td style="text-align:left">暂时离开vi到指令列模式下执行command的显示结果！例如<code>:! ls /home</code>即可在vi当中察看/home底下以ls输出的档案资讯！</td>
</tr>
<tr>
<td><strong>vim 环境的变更</strong></td>
</tr>
<tr>
<td><code>:set nu</code></td>
<td style="text-align:left">显示行号，设定之后，会在每一列的字首显示该列的行号</td>
</tr>
<tr>
<td><code>:set nonu</code></td>
<td style="text-align:left">与set nu 相反，为取消行号！</td>
</tr>
</tbody>
</table>
<h2 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h2><p>指令列模式输入<code>:sp {filename}</code>那个filename可有可无，如果想要在新视窗启动另一个档案，就加入档名，否则仅输入:sp时，出现的则是同一个档案在两个视窗间</p>
<table>
<thead>
<tr>
<th>按键</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>多视窗情况下的按键功能</strong></td>
</tr>
<tr>
<td><code>:sp [filename]</code></td>
<td style="text-align:left">开启一个新视窗，如果有加filename，表示在新视窗开启一个新档案，否则表示两个视窗为同一个档案内容(同步显示)。</td>
</tr>
<tr>
<td><code>[ctrl]+w+ j`` [ctrl]+w+↓</code></td>
<td style="text-align:left">按键的按法是：先按下[ctrl] 不放， 再按下w后放开所有的按键，然后再按下j (或向下方向键)，则游标可移动到下方的视窗。</td>
</tr>
<tr>
<td><code>[ctrl]+w+ k</code> <code>[ctrl]+w+↑</code></td>
<td style="text-align:left">同上，不过游标移动到上面的视窗。</td>
</tr>
<tr>
<td><code>[ctrl]+w+ q</code></td>
<td style="text-align:left">其实就是:q 结束离开啦！举例来说，如果我想要结束下方的视窗，那么利用[ctrl]+w+↓ 移动到下方视窗后，按下:q 即可离开， 也可以按下[ctrl]+w+q 啊！</td>
</tr>
</tbody>
</table>
<h2 id="vim语法补全"><a href="#vim语法补全" class="headerlink" title="vim语法补全"></a>vim语法补全</h2><h2 id="vim-环境设定与记录：-vimrc-viminfo"><a href="#vim-环境设定与记录：-vimrc-viminfo" class="headerlink" title="vim 环境设定与记录： ~/.vimrc, ~/.viminfo"></a>vim 环境设定与记录： <code>~/.vimrc, ~/.viminfo</code></h2><h2 id="与系统相关注意"><a href="#与系统相关注意" class="headerlink" title="与系统相关注意"></a>与系统相关注意</h2><h3 id="语系编码转换"><a href="#语系编码转换" class="headerlink" title="语系编码转换"></a>语系编码转换</h3><p>举例来说，想要将big5 编码转成utf8<br><code>iconv --list</code><br><code>iconv -f 原本编码 -t 新编码 filename [-o newfile]</code><br>选项与参数：<br>–list ：列出iconv 支援的语​​系资料<br>-f ：from ，亦即来源之意，后接原本的编码格式；<br>-t ：to ，亦即后来的新编码要是什么格式；<br>-o file：如果要保留原本的档案，那么使用-o 新档名，可以建立新编码档案。</p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
            <tag> 优化 </tag>
            
            <tag> vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux基本功操作]]></title>
      <url>/2016/03/%E5%BE%85%E6%95%B4%E7%90%86/Linux-%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%BA%A7%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="安装相关"><a href="#安装相关" class="headerlink" title="安装相关"></a>安装相关</h2><h2 id="MSDOS-MBR-分割表格式"><a href="#MSDOS-MBR-分割表格式" class="headerlink" title="MSDOS (MBR) 分割表格式"></a>MSDOS (MBR) 分割表格式</h2><p>其是兼容windows的</p>
<p>在目前的 Linux 环境下， 如果你的磁碟没有超过 2TB 的话，那么 Linux 预设是会以 MBR 模式来处理你的分割表的。</p>
<p>由于分割表所在内存块仅有64bytes容量，因此最多仅能有四组记录区，每组记录区记录了该区段的启始与结束的磁柱号码。<a id="more"></a></p>
<p>几个要点：</p>
<p>. 其实所谓的『分割』只是针对那个64 bytes的分割表进行设定而已！</p>
<p>. 硬盘预设的分割表仅能写入四组分割信息</p>
<p>. 这四组分割信息我们称为主要（Primary）或延伸（Extended）分割槽</p>
<p>. 分割槽的最小单位『通常』为磁柱（cylinder）</p>
<p>. 当系统要写入磁盘时，一定会参考磁盘分割表，才能针对某个分割槽进行数据的处理</p>
<h2 id="Linux安装模式下，磁碟分割的选择"><a href="#Linux安装模式下，磁碟分割的选择" class="headerlink" title="Linux安装模式下，磁碟分割的选择"></a>Linux安装模式下，磁碟分割的选择</h2><p>整个目录树架构最重要的就是那个根目录(root directory)，这个根目录的表示方法为一条斜线『/』</p>
<p>『挂载』就是利用一个目录当成进入点，将磁碟分割区的资料放置在该目录下； 也就是说，进入该目录就可以读取该分割槽的意思。</p>
<p>现在的虚拟机器的磁碟机制，大多使用 qcow2 这个虚拟磁碟格式，这种格式是『用多少纪录多少』喔， 与你的实际使用量有关。</p>
<p>系统会将[F1] ~ [F6]命名为tty1 ~ tty6的操作介面环境。也就是说，当你按下[crtl] + [Alt] + [F1]这三个组合按钮时(按着[ctrl]与[Alt]不放，再按下[F1]功能键)， 就会进入到tty1的terminal介面中了。</p>
<h2 id="基础命令行"><a href="#基础命令行" class="headerlink" title="基础命令行"></a>基础命令行</h2><p>在 Linux 系统中，是区分大小写的（和java一样）cd 与 CD 并不同。</p>
<p>指令太长的时候，可以使用反斜线 <code>\ + Enter</code>来换行Enter符号，使指令连续到下一行。注意！反斜线后就立刻接特殊字符，才能换行data！<br>指令之后的选项除了前面带有减号『-』之外，某些特殊情况下， 选项或参数前面也会带有正号『+』的情况！ </p>
<ol>
<li><p>日期 <code>date</code></p>
</li>
<li><p>日历 <code>cal</code><br> 默认是当前的日历，也可以键入：<code>cal [month] [year]</code></p>
</li>
<li><p>自带计算机 <code>bc</code><br> 支持 <code>+ 加法- 减法&amp; 乘法/ 除法^ 指数% 余数</code>; 退出 <code>quit</code></p>
</li>
</ol>
<h2 id="几个常见热键"><a href="#几个常见热键" class="headerlink" title="几个常见热键"></a>几个常见热键</h2><ol>
<li><p><code>tab</code><br>命令補全』與『檔案補齊』的功能<br>[Tab] 接在一串指令的第一個字的後面，則為『命令補全』；<br>[Tab] 接在一串指令的第二個字以後時，則為『檔案補齊』！</p>
</li>
<li><p><code>Ctrl + c</code> 可以將正在運作中的指令中斷</p>
</li>
<li><p><code>Ctrl + d</code> 『鍵盤輸入結束(End Of File, EOF 或 End Of Input)』的意思！ 另外，他也可以用來取代<code>exit</code>的輸入呢！例如你想要直接離開文字介面，可以直接按下[<code>Ctrl]-d</code>就能夠直接離開了(相當於輸入<code>exit</code>啊！)。</p>
</li>
<li><p><code>[shift]+{[PageUP]|[Page Down]}</code>按鍵  翻页的功能</p>
</li>
</ol>
<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><h3 id="help"><a href="#help" class="headerlink" title="--help"></a><code>--help</code></h3><h3 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a>man page</h3><p>方法就是键入 <code>man 指令</code> 如 <code>man date</code>.<br>其后出现的页面中 ：个表格的第一行，你可以看到的是：『DATE(1)』，DATE我们知道是指令的名称， 那么(1)常见的几个数字的意义是这样的：<br>| ————| ———————————— ————|<br>|代号 | 代表内容 |<br>| 1 | 使用者在shell环境中可以操作的指令或可执行档 |<br>| 2 | 系统核心可呼叫的函数与工具等 |<br>| 3 | 一些常用的函数(function)与函式库(library)，大部分为C的函式库(libc) |<br>| 4 | 装置档案的说明，通常在/dev下的档案 |<br>| 5 | 设定档或者是某些档案的格式 |<br>| 6 | 游戏(games) |<br>| 7 | 惯例与协定等，例如Linux档案系统、网路协定、ASCII code等等的说明 |<br>| 8 | 系统管理员可用的管理指令 |<br>| 9 | 跟kernel有关的文件 |</p>
<p>一般的查看顺序：<br>先查看NAME的项目,约略看一下这个资料的意思;<br>再详看一下DESCRIPTION,这个部分会提到很多相关的资料与使用时机,从这个地方可以学到很多小细节呢;<br>而如果这个指令其实很熟悉了(例如上面的date),那么鸟哥主要就是查询关于OPTIONS的部分了! 可以知道每个选项的意义,这样就可以下达比较细部的指令内容呢!<br>最后,鸟哥会再看一下,跟这个资料有关的还有哪些东西可以使用的?举例来说,上面的SEE ALSO就告知我们还可以利用『info coreutils date』来进一步查阅资料;<br>某些说明内容还会列举有关的档案(FILES 部分)来提供我们参考!这些都是很有帮助的!</p>
<p>man page 的几个关键字</p>
<p>按键 进行工作<br><code>空白键</code>向下翻一页<br><code>[Page Down]</code>向下翻一页<br><code>[Page Up]</code> 向上翻一页<br><code>[Home]</code> 去到第一页<br><code>[End]</code> 去到最后一页<br><code>/string</code> 向『下』搜寻 string 这个字串，如果要搜寻 vbird 的话，就输入 /vbird<br><code>?string</code>向『上』搜寻 string 这个字串<br><code>n, N</code> 利用 / 或 ? 来搜寻字串时，可以用 <code>n</code> 来继续下一个搜寻 (不论是 / 或 ?) ，可以利用 <code>N</code>来进行『反向』搜寻。举例来说，我以 /vbird 搜寻 vbird 字串， 那么可以 n 继续往下查询，用 N 往上查询。若以 <code>?vbird</code> 向上查询 <code>vbird</code> 字串， 那我可以用 <code>n</code>继续『向上』查询，用<code>N</code>反向查询。<br><code>q</code>结束这次的 man page</p>
<h3 id="info-page"><a href="#info-page" class="headerlink" title="info page"></a>info page</h3><h2 id="开关机"><a href="#开关机" class="headerlink" title="开关机"></a>开关机</h2><h3 id="进入root"><a href="#进入root" class="headerlink" title="进入root"></a>进入root</h3><p>由于Linux系统的关机/重新开机是很重大的系统运作，因此只有root才能够进行例如shutdown, reboot等指令。<br>切换到root用户的的方式:</p>
<ol>
<li>执行命令 <code>sudo su</code>   (su（switch user）的意思)</li>
<li>执行<code>sudo -i</code>命令也可以将当前用户有普通用户切换到root用户模式中</li>
</ol>
<p>退出root用户的方法:</p>
<ol>
<li>在切换成root用户后，我们只要执行<code>exit</code>命令就退出root用户账号了,也可<code>Ctrl+D</code>组合键,</li>
<li>su user (user是你自己安装时候的用户名)，</li>
</ol>
<p>默认root用户是无固定密码的，并且是被锁定的，如果想给root设置一个密码只需执行命令：<code>sudo passwd root</code>然后根据提示一步一步来。注意：给root设定密码后，仍可以 sudo su 切换到root用户</p>
<p>禁用和启用root登录：</p>
<p>执行 <code>sudo passwd -l root</code>即可（只是禁用root，但是root密码还保存着），再执行su root发现认证失败，</p>
<p>要再次启动root登录，执行 <code>sudo passwd -u root</code>即可</p>
<h3 id="将资料同步写入硬碟中的指令：sync"><a href="#将资料同步写入硬碟中的指令：sync" class="headerlink" title="将资料同步写入硬碟中的指令：sync"></a>将资料同步写入硬碟中的指令：sync</h3><p>美音 <code>/sɪŋk/</code><br>在Linux系统中，为了加快资料的读取速度，所以在预设的情况中， 某些已经载入记忆体中的资料将不会直接被写回硬碟。所以在操作完之后要及时<code>sync</code><br>目前的 <code>shutdown/reboot/halt</code> 等等指令均已经在关机前进行了 <code>sync</code> 这个工具的呼叫，不过，多做几次总是比较放心点。</p>
<h3 id="惯用的关机指令shutdown"><a href="#惯用的关机指令shutdown" class="headerlink" title="惯用的关机指令shutdown"></a>惯用的关机指令shutdown</h3><p>shutdown可以达成如下的工作：<br>可以自由选择关机模式：是要关机或重新开机均可；<br>可以设定关机时间: 可以设定成现在立刻关机, 也可以设定某一个特定的时间才关机。<br>可以自订关机讯息：在关机之前，可以将自己设定的讯息传送给线上 user 。<br>可以仅发出警告讯息：有时有可能你要进行一些测试，而不想让其他的使用者干扰，或者是明白的告诉使用者某段时间要注意一下！这个时候可以使用 shutdown 来吓一吓使用者，但却不是真的要关机，呵呵。</p>
<h3 id="重新开机，关机：reboot-halt-poweroff"><a href="#重新开机，关机：reboot-halt-poweroff" class="headerlink" title="重新开机，关机：reboot/halt/poweroff"></a>重新开机，关机：reboot/halt/poweroff</h3><p>##这几个常用的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# cd /tmp                      &lt;==切换工作目录到/tmp </span><br><span class="line">[root@study tmp]# mkdir testing              &lt;==建立新目录 </span><br><span class="line">[root@study tmp]# chmod 744 testing          &lt;==变更权限 </span><br><span class="line">[ root@study tmp]# touch testing/testing      &lt;==建立空的档案 </span><br><span class="line">[root@study tmp]# chmod 600 testing/testing &lt;==变更权限</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> 基本功操作 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Algorithms-笔记-字符串排序]]></title>
      <url>/2016/02/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E7%AC%94%E8%AE%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>Java中 String 的主要性质： </p>
<ol>
<li><p>不可变性</p>
</li>
<li><p>获得索引<code>charAt()</code>、长度<code>length()</code> 、子字符串<code>substring()</code> 可以在常数时间内完成</p>
</li>
<li><p>而字符串的转接（<code>+</code>） 所用的时间秘结果字符串的长度成正比。</p>
</li>
</ol>
<h2 id="键索引计数法"><a href="#键索引计数法" class="headerlink" title="键索引计数法"></a>键索引计数法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = a.length;</span><br><span class="line">String[] aux = <span class="keyword">new</span> String[N];</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> String[R + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 频率统计</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i++ ) &#123;</span><br><span class="line">	count[a[i].key() + <span class="number">1</span>]++; <span class="comment">// 注意是count[r + 1]加上1，易错；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将频率转换为索引</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R + <span class="number">1</span> ; i++) &#123;</span><br><span class="line">	count [i + <span class="number">1</span>] += count[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据分类</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; i ++ ) &#123;</span><br><span class="line">	aux[count[a[i].key()]++] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回写</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; i ++) &#123;</span><br><span class="line">	a[i] = aux[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>键索引计数法排序N个键为0到R-1的整数的元素需要访问数组11N+4R+1次</p>
</blockquote>
<p>键索引计数法对小整数键排序非常有效，其突破了NlogN的排序算法运行时间下限，它是常数级别。</p>
<p>键索引计数法对字符串数组的<strong>排序是稳定的</strong>。这是它十分重要的特点。</p>
<h2 id="低位优先的字符串排序"><a href="#低位优先的字符串排序" class="headerlink" title="低位优先的字符串排序"></a>低位优先的字符串排序</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = a.length;</span><br><span class="line">	<span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">	String[] aux = <span class="keyword">new</span> String[N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = W - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R + <span class="number">1</span>]; <span class="comment">// 频率统计数组，注意大小是R+1 易错，</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123; <span class="comment">// 计算出现频率</span></span><br><span class="line">			count[a[j].charAt(i) + <span class="number">1</span>]++; <span class="comment">// 注意大小要+1 易错，</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; R; j++) &#123; <span class="comment">// 将频率转换为索引</span></span><br><span class="line">			count[j + <span class="number">1</span>] += count[j];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123; <span class="comment">// 元素分类</span></span><br><span class="line">			aux[count[a[j].charAt(i)]++] = a[j];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123; <span class="comment">// 回写</span></span><br><span class="line">			a[j] = aux[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的低位优先的字符串排序的应用场景是<strong>定长字符串</strong>；其依赖于键索引计数法的<strong>稳定性</strong>。</p>
<blockquote>
<p>低位优先的字符串排序算法能够稳定地将定长字符串排序。对了基于R个字符的字母表的N个以长为W的字符串为键的元素，低位优先的字符串排序 要访问~7WN+3W次数组，使用的额外空间与N+R成正比。</p>
</blockquote>
<p>低位优先的字符串排序<strong>意义重大</strong>：它是一种适用于一般应用的线性时间排序算法。——运行时间与回个话的规模成正比。</p>
<h2 id="适用于键长不用的P字符串数组的低位优先的字符串排序（待研究）"><a href="#适用于键长不用的P字符串数组的低位优先的字符串排序（待研究）" class="headerlink" title="适用于键长不用的P字符串数组的低位优先的字符串排序（待研究）"></a>适用于键长不用的P字符串数组的低位优先的字符串排序（待研究）</h2><h2 id="高位优先的排序"><a href="#高位优先的排序" class="headerlink" title="高位优先的排序"></a>高位优先的排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MSD</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> R = <span class="number">256</span>; <span class="comment">// 基数，ASCI是256 UNICODE16是65，536</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String[] aux;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">15</span>; <span class="comment">// 小组切换的辅助数组</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// return dth of Sting s,if length = d ,return -1</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">charAt</span><span class="params">(String s, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s.length() &gt; d) &#123;</span><br><span class="line">			<span class="keyword">return</span> s.charAt(d);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> N = a.length;</span><br><span class="line">		aux = <span class="keyword">new</span> String[N];</span><br><span class="line">		sort(a, <span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当字符串的长度小于m， cutoff to insertion sort</span></span><br><span class="line">		<span class="keyword">if</span> (hi &lt;= lo + M) &#123;</span><br><span class="line">			insertion(a, lo, hi, d);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// compute frequency counts</span></span><br><span class="line">		<span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R + <span class="number">2</span>]; <span class="comment">// 注意是R+2 易错</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i++) &#123;</span><br><span class="line">			count[charAt(a[i], d) + <span class="number">2</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将频率转换为索引</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R + <span class="number">1</span>; i++) &#123;</span><br><span class="line">			count[i + <span class="number">1</span>] += count[i]; <span class="comment">// 这里使用了count[0]</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 数据分类</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">			aux[count[charAt(a[i], d)]++] = a[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 回写</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">			a[i] = aux[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 递归的以每个字符为键进行排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">			sort(a, lo + count[i], hi + count[i + <span class="number">1</span>] - <span class="number">1</span>, d + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion</span><span class="params">(String[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j - <span class="number">1</span>], d); j--) &#123;</span><br><span class="line">				exch(a, j, j - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(String[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		String aux = a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = aux;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// insertion 中的于普通中不同的 less </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(String v, String w, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt; Math.min(v.length(), w.length()); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v.charAt(i) &lt; w.charAt(i)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (v.charAt(i) &gt; w.charAt(i)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> v.length()&lt; w.length();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MSD中的几个陷阱："><a href="#MSD中的几个陷阱：" class="headerlink" title="MSD中的几个陷阱："></a>MSD中的几个陷阱：</h3><ol>
<li><p>小型子数组<br>小型子数组对于高位优先的字符串排序的性能至关重要，小的数组会极大的占用性能。<br>将小数组切换到到插入排序对高位优先的排序算法是<strong>必须的！！！</strong><br>这种情况在其他的<strong>递归算法中也是必须的</strong>。</p>
</li>
<li><p>等值键问题<br>MSD最坏的情况就是所有的键均相同，同样大量含有相同前缀也会产生同样的问题。</p>
</li>
</ol>
<h3 id="性能的问题"><a href="#性能的问题" class="headerlink" title="性能的问题"></a>性能的问题</h3><p>对随机输入，算法的运行时间是亚线性的。<br>非随机输入，算法的时间是接近线性的。</p>
<p>在将长字符串排序时，令MSD自算法发挥出最大效率的主要挑战在于处理数据中的非随机因素</p>
<h2 id="三向字符快速排序"><a href="#三向字符快速排序" class="headerlink" title="三向字符快速排序"></a>三向字符快速排序</h2><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 字符串算法 </tag>
            
            <tag> 字符串排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hash table]]></title>
      <url>/2016/01/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E7%AC%94%E8%AE%B0-%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>散列表，也叫哈希表，就是通过计算一个关于键值的函数，将所需查询的数据映射到表中的一个位置来访问记录，这加快了查找速度。</p>
<p>他的实现算法分为两步：</p>
<ol>
<li><p>是用 <strong>hash Function</strong>将被查找的键转化为数组的一个索引；</p>
</li>
<li><p>collision-resolution process ，当多个键对应一个索引的时候，我们如何处理；</p>
</li>
</ol>
<p>使用 Hash table 在一般应用中拥有（均摊后）<strong><em>常数级别</em></strong>的查找 和插入操作的符号表！</p>
<p>但他的储存是无序 的，一有序性相关的操作是运行旱都将会是线性的。<br><a id="more"></a></p>
<h2 id="hash-Functions-的实现"><a href="#hash-Functions-的实现" class="headerlink" title="hash Functions 的实现"></a>hash Functions 的实现</h2><p>散列函数的计算就，就是将键转化为数组的索引。</p>
<p>对于每种类型的键我们都需要一个与这对应的散列函数。</p>
<p>在java中，所有的数据类型都继承 了一个能够返回一个32-bit的integer 的 hashCode() ,当我们重写它的时候<strong>必须</strong>要保证他们equals()的一致性。</p>
<p>自定义hashCode（）的时候，我们要尽力的<strong>将键平均散布</strong>为所有可能的32位整数。这也是散列表算法分析前提，即<strong>均匀散列假设</strong>：</p>
<blockquote>
<p>我们这使用的散列函数能够均匀并独立地将所有的键散布于0到M-1之间。</p>
</blockquote>
<h2 id="碰撞处理——拉链法"><a href="#碰撞处理——拉链法" class="headerlink" title="碰撞处理——拉链法"></a>碰撞处理——拉链法</h2><h2 id="碰撞处理——线性探测法"><a href="#碰撞处理——线性探测法" class="headerlink" title="碰撞处理——线性探测法"></a>碰撞处理——线性探测法</h2><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 散列表 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Algorithms-笔记-二叉树查找树]]></title>
      <url>/2015/12/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>一棵二叉查找树（BST）是棵二叉树，其中没个结点都含有一个Comparable的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。<br>为了程序的可读性，这里大多娄的代码使用了递归。<br>许多程序员偏爱基于二叉树的符号表，是因为他支持高效的rank().select() delete() 以及范围查找等操作。。<a id="more"></a></p>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node root; <span class="comment">// 定义根节点 （链式结构的起手式）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Key key; <span class="comment">// 键</span></span><br><span class="line">	<span class="keyword">private</span> Value value; <span class="comment">// 值</span></span><br><span class="line">	<span class="keyword">private</span> Node left, right;<span class="comment">// 左右子结点的链接</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> N; <span class="comment">// 结点计数器——以该结点为根结点的结点总数</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">		N = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> size(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以该结点为根结点的结点总数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node xNode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (xNode == <span class="keyword">null</span>) &#123; <span class="comment">// 将空链接的值当作0；（重要条件）</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> xNode.N; <span class="comment">// size(x) = size(x.left) + size(x.right) + 1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找和插入"><a href="#查找和插入" class="headerlink" title="查找和插入"></a>查找和插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找键对应的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> *            要查找的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 对应的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> get(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在以xNode 为根结点的子树中查找，并返回key所对应的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node xNode, Key key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (xNode == <span class="keyword">null</span>) &#123; <span class="comment">// 退出条件—— 如果找不到就返回null</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递归查找</span></span><br><span class="line">	<span class="keyword">int</span> cmp = key.compareTo(xNode.key);</span><br><span class="line">	<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> get(xNode.left, key); <span class="comment">// 注意不要丢了return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> get(xNode.right, key);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> xNode.value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在二叉查找树中插入键值对</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">	root = put(root, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入键值对——如果key存在于以xNode为根结点的子树中，则更新它的值;如果key不存在于以xNode为根结点的子树中，就新建一个插入到该子树中。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node xNode, Key key, Value value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (xNode == <span class="keyword">null</span>) &#123; <span class="comment">// 如果树是空的，就返回一个新的结点。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Node(key, value, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果key存在于以xNode为根结点的子树中，则更新它的值。</span></span><br><span class="line">	<span class="comment">// 递归查找——如果key小于根结点，就在左子树中插入 ，大于就在右子树中插入</span></span><br><span class="line">	<span class="keyword">int</span> cmp = key.compareTo(xNode.key);</span><br><span class="line">	<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		xNode.left = put(xNode.left, key, value); <span class="comment">// 注意递归公式的格式，易错</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		xNode.right = put(xNode.right, key, value);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		xNode.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	xNode.N = size(xNode.left) + size(xNode.right) + <span class="number">1</span>; <span class="comment">// 更新计数器，（注意公式的前提是：空链接的值当作0）</span></span><br><span class="line">	<span class="keyword">return</span> xNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><blockquote>
<p>在由N个随机键构造的二叉查找 树中，查找 命中平均为所需经比较次数为~2lnN(约1.39lgN).<br>在由N个随机键构造的二叉查找树中插入操作和查找未命中平均所需要的比较次数为~2(约1.39lgN).</p>
</blockquote>
<p>由上面可以看出：二叉查找树中查找随机键的成本比二分查找高约39%（代价），但是插入一个上新的键的成本是对数级别的。</p>
<h2 id="有序性相关操作"><a href="#有序性相关操作" class="headerlink" title="有序性相关操作"></a>有序性相关操作</h2><p>###查找最大值和最小值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找树中的最小值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> min(root).key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据如果一个结点的左链接为空，那这个结点就是最小键。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node xNode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (xNode.left == <span class="keyword">null</span>) &#123;<span class="comment">// 如果 左链接为空，那这个结点就是最小键</span></span><br><span class="line">		<span class="keyword">return</span> xNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min(xNode.left); <span class="comment">// 不空则递归左链接结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找树中的最大值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> max(root).key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和min方法类似</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">max</span><span class="params">(Node xNode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (xNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> xNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max(xNode.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="向下取整-查找比给定key小的节点的key"><a href="#向下取整-查找比给定key小的节点的key" class="headerlink" title="向下取整  查找比给定key小的节点的key"></a>向下取整  查找比给定key小的节点的key</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向下取整，查找比给定key小的节点的key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> *            给定key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比给定key小的节点的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">	Node xNode = floor(root, key);</span><br><span class="line">	<span class="keyword">if</span> (xNode == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">return</span> xNode.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node xNode, Key key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (xNode == <span class="keyword">null</span>) &#123; <span class="comment">// 跳出条件</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递归调用</span></span><br><span class="line">	<span class="keyword">int</span> cmp = key.compareTo(xNode.key);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当给定key小于等于根节点xNode的key时的递归处理：</span></span><br><span class="line">	<span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123; <span class="comment">// 当给定key等于根节点xNode的key时 那就是这个结点了，over，</span></span><br><span class="line">		<span class="keyword">return</span> xNode;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;<span class="comment">// 当给定key小于根节点xNode的key时，那小于等于key的最大键一定在左子树，——则向左递归</span></span><br><span class="line">		<span class="keyword">return</span> floor(xNode.left, key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当给定key大于根节点xNode的key时递归处理：</span></span><br><span class="line">	Node tNode = xNode.right;</span><br><span class="line">	<span class="keyword">if</span> (tNode != <span class="keyword">null</span>) &#123;<span class="comment">// 那右子树 不为空时——则向右递归</span></span><br><span class="line">		<span class="keyword">return</span> tNode;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> xNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择和排名"><a href="#选择和排名" class="headerlink" title="选择和排名"></a>选择和排名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回排名为k的的键</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> select(root, k).key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回排名为k的结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">select</span><span class="params">(Node xNode, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (xNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> t = size(xNode.left); <span class="comment">// t为指定结点的左子树结点个数。</span></span><br><span class="line">	<span class="keyword">if</span> (t &gt; k) &#123; <span class="comment">// 左子树结点个数&lt; k， 继续递归的在左子树中查找</span></span><br><span class="line">		<span class="keyword">return</span> select(xNode.left, k);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &lt; k) &#123;<span class="comment">// 左子树结点个数大于k—— 则返回指定结点在左子树中的排名（k - t</span></span><br><span class="line">						<span class="comment">// -1），并继续递归的在左子树中查找排名为（k - t -1）的结点</span></span><br><span class="line">		<span class="keyword">return</span> select(xNode.right, k - t - <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 相等了，就返回</span></span><br><span class="line">		<span class="keyword">return</span> xNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找键为key的结点排名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> rank(key, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key, Node xNode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (xNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> cmp = key.compareTo(xNode.key);</span><br><span class="line">	<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> rank(key, xNode.left);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span> + size(xNode.left) + rank(key, xNode.right); <span class="comment">// 有疑问！——注意二叉树的结构，他的左子树的结点数并不一小等于小于他的结点为的个数，因为他可能有根结点</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> size(xNode.left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除的操作"><a href="#删除的操作" class="headerlink" title="删除的操作"></a>删除的操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	root = deleteMin(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最小值,难点是删除后路径的更新</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node xNode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (xNode.left == <span class="keyword">null</span>) &#123; <span class="comment">// 不断检索左子树，直至遇见空的左链接（即最小值）</span></span><br><span class="line">		<span class="keyword">return</span> xNode.right; <span class="comment">// 将最小值的右链接的结点，链接到最小值的父结点 ，代替最小值</span></span><br><span class="line">	&#125;</span><br><span class="line">	xNode.left = deleteMin(xNode.left);</span><br><span class="line">	xNode.N = size(xNode.left) + size(xNode.right) + <span class="number">1</span>; <span class="comment">// 更新计数器</span></span><br><span class="line">	<span class="keyword">return</span> xNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定的key和他的对应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 要删除的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">	root = delete(root, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除指定的key和他的对应的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node xNode, Key key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (xNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递归查找的值</span></span><br><span class="line">	<span class="keyword">int</span> cmp = key.compareTo(xNode.key);</span><br><span class="line">	<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		xNode.left = delete(xNode.left, key);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		xNode.right = delete(xNode.right, key);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//删除操作（实际没有，就是更新路径的问题）</span></span><br><span class="line">		<span class="comment">// 左边或右边为空时处理</span></span><br><span class="line">		<span class="keyword">if</span> (xNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> xNode.left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (xNode.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> xNode.right;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当两边都不为空时如何替换后续结点：</span></span><br><span class="line">		Node tNode = xNode;</span><br><span class="line">		xNode = min(tNode.right);</span><br><span class="line">		xNode.right = deleteMin(tNode.right);</span><br><span class="line">		xNode.left = tNode.left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	xNode.N = size(xNode.left) + size(xNode.right) + <span class="number">1</span>; <span class="comment">// 更新计数器</span></span><br><span class="line">	<span class="keyword">return</span> xNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="范围查找（待补充）"><a href="#范围查找（待补充）" class="headerlink" title="范围查找（待补充）"></a>范围查找（待补充）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> keys(min(), max());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">		Queue&lt;Key&gt; queue = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">		keys(root, queue, lo, hi);</span><br><span class="line">		<span class="keyword">return</span> queue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node xNode, Queue&lt;Key&gt; queue, Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (xNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> cmplo = lo.compareTo(xNode.key);</span><br><span class="line">		<span class="keyword">int</span> cmphi = hi.compareTo(xNode.key);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 代码演示了如何递归的查找 所以子树中的键的方法</span></span><br><span class="line">		<span class="keyword">if</span> (cmplo &lt; <span class="number">0</span>) &#123; <span class="comment">// 递归查收左子树，</span></span><br><span class="line">			keys(xNode.left, queue, lo, hi);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cmplo &lt;= <span class="number">0</span> &amp;&amp; cmphi &gt;= <span class="number">0</span>) &#123; <span class="comment">// 查找根节点 ：将符合条件的key添加到queue中，</span></span><br><span class="line">			queue.enqueue(xNode.key);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cmphi &gt; <span class="number">0</span>) &#123; <span class="comment">// 再每层递归的查找右子树</span></span><br><span class="line">			keys(xNode.right, queue, lo, hi);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有序性相关操作的性能分析"><a href="#有序性相关操作的性能分析" class="headerlink" title="有序性相关操作的性能分析"></a>有序性相关操作的性能分析</h2><p>在一棵二叉查找 树中，所有的操作在最坏的情况下所需要的时间和树的高度成正比。<br>有人证明了，随机构造的树中，的所有的路径长度都是小于3lgN的。</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 二叉查找树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[查找算法基础——字典、顺序及二分查找]]></title>
      <url>/2015/12/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E7%AC%94%E8%AE%B0-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>主要讲了，对符号表，也就是字典的概念，和符号表的两种初级的实现数据结构：链表和有序数组。并介绍了基于这两种实现的算法：顺序查找和二分查找。<a id="more"></a></p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><code>延时删除</code>：将键对应的值置为空，在某个时间删去所有值为空的键。<br><code>即时删除</code> ：立即从表中删除指定的键</p>
<p><code>对象等价性</code>（1.2.5.8节讲过）：（略）<br><code>不可变数据类型</code>（1.2.5.10节讲过）：指的是盖类型的对象中的值在创建之后就无法再被改变了。 例如 String , date (可变的有，Counter java数组)</p>
<p>分符号表算法比分析排序算法更困难，因为不同的用例所进行的操作序列各不相同。性能分析主要研究最坏情况下的性能。</p>
<p><code>随机命中</code>：在查找表中的每个元素的可能性相同的情况下，一种查找平均所需要的比较数。也就查找表中的每个键，并将总时间除以N。这个模型可以很好的描述查找的性能，即使查找不是随机的情况下。</p>
<p><code>有序数组</code>是一种特殊的数组，里面的元素，按一定的顺序排列，我们这里假设由小到大排列。对于这种特殊的数组，我们可以采用二分法来查找数组中特定的元素，思想是：每查找一次，便将查找的范围缩小一半，所以叫做二分法查找。有序数组的优点就是增加了查询的效率，但是它并没有提高删除和插入元素的效率，因此，对于有序数组更适合用于查询的领域。</p>
<h2 id="Symbol-Table"><a href="#Symbol-Table" class="headerlink" title="Symbol Table"></a>Symbol Table</h2><p>Symbol Table 是一种<strong>存储键值对</strong>的数据结构，支持两种操作：<br><strong>插入(put)</strong>:将一级新键值对存入表中<br><strong>查找（get）</strong>: 根据给定的键得到相应的值</p>
<h3 id="符号表要注意的事儿："><a href="#符号表要注意的事儿：" class="headerlink" title="符号表要注意的事儿："></a>符号表要注意的事儿：</h3><ul>
<li><p>每个键只对应一个值(表中不允许存在重复的键)。</p>
</li>
<li><p>当用例向表存入的键值对和表中已有的键（及值）冲突时，新的值会代替旧的值。</p>
</li>
<li><p>键不能为空，（java中空键会产生一个运行时异常）</p>
</li>
<li><p>本书规定不允许有空值</p>
</li>
<li><p>要使用<strong>不可变的数据</strong> 类型作为键，否则表的一致性是无法保证的。</p>
</li>
<li><p>任何一种comparable类型的两个值都要保证（a.compareTo(b） == 0 和a.equal(b) 的返回值是一样的，但是为了避免二义性，我们编程的时候只用a.compareTo(b) == 0 表示相等。<strong><em>其他人的程序易错点</em></strong></p>
</li>
</ul>
<h3 id="有序符号表"><a href="#有序符号表" class="headerlink" title="有序符号表"></a>有序符号表</h3><p>指的是符号表都会保持键的有序。<br>rank(排名，找出小于指定键的键的数量)</p>
<p>select (选择，找出排名为K的键)</p>
<h3 id="成本模型"><a href="#成本模型" class="headerlink" title="成本模型"></a>成本模型</h3><p>在学习符号表的实现的时：我会统计比较的次数。在内循环不进行比较的的情况下，统计数组的访问次数。（这个比较少见）<br>学习符号表处理大型文本的性能要考虑两个方面的因素：</p>
<ol>
<li>每个单词都会被作为键进行搜索，因此处理性能和输入的总量有关；</li>
<li>输入的每个单词都会被存入符号表（输入中不重复的单词的总数也就是所有键都被插入以后的table的大小），因此输入流中不同的单词的总数也是相关的。</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p>混合使用查找和插入的操作；</p>
</li>
<li><p>大量的不同的键；</p>
</li>
<li><p>查找的操作比如插入多的多；</p>
</li>
<li><p>查找和插入的使用模式是非随机的（但是不可预测的）.</p>
</li>
</ol>
<h2 id="顺序查找（基于list）"><a href="#顺序查找（基于list）" class="headerlink" title="顺序查找（基于list）"></a>顺序查找（基于list）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SequentialSearchST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Node first; <span class="comment">// 第一个结点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 链表结点的定义</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		Key key;</span><br><span class="line">		Value value;</span><br><span class="line">		Node next;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, SequentialSearchST&lt;Key, Value&gt;.Node next)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.key = key;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line">			<span class="keyword">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (key.equals(x.key)) &#123;</span><br><span class="line">				<span class="keyword">return</span> x.value; <span class="comment">// search hit</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// search miss</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Node x = first; x.next != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (key.equals(x.key)) &#123;</span><br><span class="line">				x.value = value;  <span class="comment">//search hit : update value</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		first = <span class="keyword">new</span> Node(key, value, first);<span class="comment">// search miss : add new Node;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在含有N对键值的基于（无序）链表的符号表中，未命中的查找和插入都需要N次比较，命中的查找在最坏的情况下也需要N次比较。特别地，向一个空表中插入N个不同的键需要~ N<sup>2</sup> /2次比较。<br>向一个空表中插入N个不同的键需要~ N<sup>2</sup> /2 次比较。</p>
</blockquote>
<p>顺序查找的随机命中所需要的平均比较次数为~ N/2 ——证明了基于链表的实现以及顺序查找是非常<strong>低效</strong>的！</p>
<h2 id="二分查找（基于有序数组）"><a href="#二分查找（基于有序数组）" class="headerlink" title="二分查找（基于有序数组）"></a>二分查找（基于有序数组）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Key[] keys;</span><br><span class="line">	<span class="keyword">private</span> Value[] vals;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化，并分配内存</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BinarySearchST</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.keys = (Key[]) <span class="keyword">new</span> Comparable[capacity];<span class="comment">// 对泛型的处理</span></span><br><span class="line">		<span class="keyword">this</span>.vals = (Value[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果表中存在该键，返回该键的位置（也就是表中小于它的键的数量）；如果不存在返回表中小于它的键的数量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123; <span class="comment">// 经典的二分查找算法的实现</span></span><br><span class="line">		<span class="keyword">int</span> lo = <span class="number">0</span>, hi = N - <span class="number">1</span>;<span class="comment">// 指针初始化</span></span><br><span class="line">		<span class="keyword">while</span> (lo &gt; hi) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>; <span class="comment">// 注意中间位置如何定义，常用</span></span><br><span class="line">			<span class="keyword">int</span> cmp = key.compareTo(keys[mid]);</span><br><span class="line">			<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				hi = mid - <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				lo = mid + <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> mid; <span class="comment">// 相等 返回中间值</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> lo; <span class="comment">// 没有找到，有的程序 是返回-1的</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = rank(key); <span class="comment">// 获得表中小于key的键的数量</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>) &#123;<span class="comment">// 表中如果 存在该键——则替换值并结束</span></span><br><span class="line">			vals[i] = value;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = N; j &lt; i; j++) &#123; <span class="comment">// key不存在——则将所有大于他的键和值的位置一起后移一格腾出位置</span></span><br><span class="line">			keys[j] = keys[j - <span class="number">1</span>];</span><br><span class="line">			vals[j] = vals[j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		vals[i] = value; <span class="comment">// 在i处插入新的键值对。</span></span><br><span class="line">		keys[i] = key;</span><br><span class="line">		N++; <span class="comment">// 不要忘了计数加一</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找的分析"><a href="#二分查找的分析" class="headerlink" title="二分查找的分析"></a>二分查找的分析</h3><blockquote>
<p>在N个键的有序数组中进行二分查找最多需要（lgN+1）次比较（无论成功）——说明了二分查找所需时间必然在对数范围内。<br>向大小为N的有序数组中插入一个新的元素在最坏的情况下需要访问~2N次数组——因此向一个空符号表中插入N个元素在最坏的情况下需要访问~N<sub>2</sub>次数组。</p>
</blockquote>
<p>上面说明：二分查找<strong>无法支持大型数组的处理</strong>——其查找是对数级的，但是他构造一个新表的时间是平方级的。</p>
<p>所以，在对于一个静态的表（不需要太多插入操作的），二分查找是很适合的。其他的就不行了。</p>
<h2 id="几种符号表实现的比较"><a href="#几种符号表实现的比较" class="headerlink" title="几种符号表实现的比较"></a>几种符号表实现的比较</h2><table>
<thead>
<tr>
<th>数组结构</th>
<th>实现</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>链表</td>
<td>SequentialSearchST</td>
<td>适用于小型问题</td>
<td>对于大型数组很慢（平方级）</td>
</tr>
<tr>
<td>有序数组</td>
<td>BinarySearchST</td>
<td>最优的查找效率和空间需要，能进行有序性相关的操作（副作用）</td>
<td>插入操作很慢（平方级））</td>
</tr>
<tr>
<td>二叉查找树</td>
<td>BST</td>
<td>实现简单 能够进行有序性相关操作</td>
<td>没有性能上界的保证，链接需要额外的空间</td>
</tr>
<tr>
<td>平衡二叉查找树</td>
<td>RedBlackBST</td>
<td>最优的查找和插入效率 能够进行有序性相关操作</td>
<td>链接需要额外的空间</td>
</tr>
<tr>
<td>散列表</td>
<td>SeparateChainHashST</td>
<td>能够快速地查找和插入常见类型的数据</td>
<td>需要计算每种类型的数据的散列码；无进行有序性相关的操作；链接和空结点需要额外的空间</td>
</tr>
</tbody>
</table>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[堆（Heap）及优先队列初步]]></title>
      <url>/2015/12/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E7%AC%94%E8%AE%B0-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>当总的数据量太大时，无法排序，或不要求他们全部在有序，那就要用到<strong>优先队列</strong>了。他支持两种操作：删除最大元素和插入元素    。而这里实现的优先队列是基于<strong>二叉堆数据</strong>结构<a id="more"></a></p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h2 id="堆Heap"><a href="#堆Heap" class="headerlink" title="堆Heap"></a>堆Heap</h2><p><strong>堆有序：</strong> 当一个二叉树的每个结点都大于等于它的两个子结点时。<br><strong>根节点</strong>是堆有序的干纹树中的最大结点。<br><strong>二叉堆（简称堆）：</strong> 是一级能够用堆有序的完全二叉树排序的元素，并在<strong>数组中按照层级储存</strong>（注意，不使用数组的第一个位置）。</p>
<p>如果利用数组定义堆：</p>
<ul>
<li><p>在一个堆中，位置k的结点的父结点的位置为<code>k/2（向下取整）</code>而他的两个子结点的位置是<code>2k</code>和<code>2k+1</code>。</p>
</li>
<li><p>要是有大小为N的完全二叉树的高度为<code>lgN（向下取整</code>）。</p>
</li>
<li><p>这种实现方式的结构是严格的，利用它实现的优先队列保证了对数复杂度的性能。</p>
</li>
</ul>
<h3 id="堆的比较和交换的实现。"><a href="#堆的比较和交换的实现。" class="headerlink" title="堆的比较和交换的实现。"></a>堆的比较和交换的实现。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if pd[i] &lt; pd[j]</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// exchange pq[i] and pq[j];</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	Key temp = pq[i];</span><br><span class="line">	pq[i] = pq[j];</span><br><span class="line">	pq[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="swim-由下至上的堆有序化实现"><a href="#swim-由下至上的堆有序化实现" class="headerlink" title="swim_由下至上的堆有序化实现"></a>swim_由下至上的堆有序化实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>, k)) &#123; <span class="comment">// 达到边界（根node） 或找到比k大的父结点 后跳出</span></span><br><span class="line">		exch(k / <span class="number">2</span>, k);</span><br><span class="line">		k = k / <span class="number">2</span>; <span class="comment">// int运算默认向下取整</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sink-由上至下的堆有序化实现"><a href="#sink-由上至下的堆有序化实现" class="headerlink" title="sink_由上至下的堆有序化实现"></a>sink_由上至下的堆有序化实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由上至下的有序化堆</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">		<span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j + <span class="number">1</span>)) &#123;<span class="comment">// 查找他的两个子结点的较大的一个</span></span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (! less(k, j)) &#123; <span class="comment">//跳出条件：pa[k]小于他的子结点 就跳出</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		exch(k, j); </span><br><span class="line">		k = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于堆的优先队列"><a href="#基于堆的优先队列" class="headerlink" title="基于堆的优先队列"></a>基于堆的优先队列</h2><p>优先队列最重要的两种操作：删除最大元素和插入元素。</p>
<p>优先队列和的各种实现在最坏的情况下的远行时间的增长数量级：</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>插入元素</th>
<th>删除最大元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>有序数组</td>
<td>N</td>
<td>1</td>
</tr>
<tr>
<td>无序数组</td>
<td>1</td>
<td>N</td>
</tr>
<tr>
<td>堆</td>
<td>logN</td>
<td>logN</td>
</tr>
<tr>
<td>理想</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>对一一个含有N个元素的基于fwyr的优先队列，插入元素操作只需<code>不超过（lgN+1）</code>次比较；删除最大元素的操作需要不超过<code>2lgN次</code>比较。————这是一个重要的性能突破！</p>
<p>他在现代的应用程序 中越来越重要！——它可以在插入和删除最大元素操作混合的动态场景中保证对数级别的运行时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Key[] pq; <span class="comment">// store items at indices 1 to N</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> N; <span class="comment">// number of items on priority queue</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Initializes an empty priority queue with the given initial capacity.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> maxN</span></span><br><span class="line"><span class="comment">	 *            the initial capacity of this priority queue</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> maxN)</span> </span>&#123;</span><br><span class="line">		pq = (Key[]) <span class="keyword">new</span> Comparable[maxN + <span class="number">1</span>];</span><br><span class="line">		N = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> N;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 插入元素。</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> v 要插入的元素</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key v)</span> </span>&#123;</span><br><span class="line">		pq[++N] = v;</span><br><span class="line">		swim(N);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  删除最大元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 删除的那个最大元素</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Key max = pq[<span class="number">1</span>]; <span class="comment">//从根结点得到最大元素</span></span><br><span class="line">		pq[<span class="number">1</span>] = pq[N--];<span class="comment">// 将其和最后一个元素交换（恢复堆的秩序 的初始步骤）</span></span><br><span class="line">		pq[N + <span class="number">1</span>] = <span class="keyword">null</span>;<span class="comment">// 防止对象游离</span></span><br><span class="line">		sink(<span class="number">1</span>);  <span class="comment">// 正式恢复堆的秩序</span></span><br><span class="line">		<span class="keyword">return</span> max; </span><br><span class="line">	&#125;</span><br><span class="line">	。。。。。。。</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（待研究）一些改进方案"><a href="#（待研究）一些改进方案" class="headerlink" title="（待研究）一些改进方案"></a>（待研究）一些改进方案</h3><ol>
<li>可以在 代码中添加调整数组大小的代码</li>
</ol>
<h2 id="（待研究）索引优先队列"><a href="#（待研究）索引优先队列" class="headerlink" title="（待研究）索引优先队列"></a>（待研究）索引优先队列</h2><p>实现一个关联索引的优先队列 -<br>允许用例引用已经进入优先队列中的元素是很必要的</p>
<p>简单的实现方法是给每一个元素一个索引。<br>在一个大小为N的索引优先队列中，插入元素（insert），改变优先级（change），删除(delete)和删除最小元素(remove the mininmum)操作所需的比较次数和<code>logN</code>成正比。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote>
<p>用下沉操作由N个元素构造堆只需少于2N次比较以及少至N次交换。那么将N个元素排序，堆排序只需要少于（2NlogN+2N）次比较（以及一半次数的交换）</p>
</blockquote>
<p>优点：<br>在最坏的情况下可以保证使用<strong>~2NlgN</strong>次比较和恒定的额外空间。<br>他<strong>代码量很少</strong>，就可以实现比较好的性能，当在空间十分紧张的设备——如在<strong>嵌入式</strong>和移动设备中，很流行。</p>
<p>缺点：<br>它无法利用缓存——他的元素很少和相邻的其他的元素进行比较——现在系统的大多数应用都不怎么会使用它的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span> <span class="params">(Comparable[] pq)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = pq.length; <span class="comment">// 获取元素的个数，注意下面对pq[0]中元素的处理</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123; <span class="comment">//构造堆，并使堆有序——保证根结点的的元素是最大的</span></span><br><span class="line">		sink(pq, k, N);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;  <span class="comment">// 下沉排序——将堆中的最大元素删除，然后放入堆中缩小的后数组中空出的位置。</span></span><br><span class="line">		exch(pq, <span class="number">1</span>, N--);</span><br><span class="line">		sink(pq, <span class="number">1</span>, N);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment"> * Helper functions to restore the heap invariant.</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">		<span class="keyword">if</span> (j &lt; N &amp;&amp; less(pq[j], pq[j + <span class="number">1</span>])) &#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!less(pq, k, j)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		exch(pq, j, k);</span><br><span class="line">		k = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Indices are "off-by-one" to support 1-based indexing.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pq[i - <span class="number">1</span>].compareTo(pq[j - <span class="number">1</span>]) &lt; <span class="number">0</span>; <span class="comment">// 减一是 to support 1-based indexing.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if v &lt; w</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Indices are "off-by-one" to support 1-based indexing.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	Comparable temp = pq[i - <span class="number">1</span>];</span><br><span class="line">	pq[i] = pq[j - <span class="number">1</span>];</span><br><span class="line">	pq[j - <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 排序算法 </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[快速排序算法]]></title>
      <url>/2015/12/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E7%AC%94%E8%AE%B0-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>快速排序是应用最广泛的排序算法了。<br>其特点是：它是原地排序（只需要一个很的小辅助栈）；且将长度为<code>N</code>的数组排序所需的时间和<code>NlgN</code>成正比；其内循环比大多数排序算法都小，——意味着它无论是在理论上还是实际中都要更快。</p>
<p>主要缺点是：非常的脆弱，在实现时要非常的小心才能避免低劣的性能。<a id="more"></a></p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><a href="https://zh.wikipedia.org/zh/熵_(信息论" target="_blank" rel="noopener">香农信息量（熵）</a>)<br>不存在任何基于比较的排序算法能够保证在NH-H次比较之内将N个元素排序，其中H为由主键出现频率定义的香农信息量。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>也是一种分治的算法；它一个数组分成两个子数组，将两部分独立地排序。与归并排序不同的是，快速排序中当两个子数组都有序时，整个数组也就自然有序了。同时调用是发生在处理整个数组之后（归并是之前）。<br>它是一个<strong>随机化的算法</strong>：在排序这前必须将数组打乱。why?<br>快速排序有一个潜在缺点：切分不平衡时这个程序可能会极为低效（快速排序最多需要级N<sup>2</sup>/2次比较），随机化是为了避免这种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">	StdRandom.shuffle(a); <span class="comment">// 随机化；</span></span><br><span class="line">	sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (hi &lt;= lo) &#123; <span class="comment">// 递归出口</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> j = partition(a, lo, hi); <span class="comment">// 对 array 进行</span></span><br><span class="line">	sort(a, lo, j - <span class="number">1</span>); <span class="comment">// 对左半部分排序</span></span><br><span class="line">	sort(a, j + <span class="number">1</span>, hi); <span class="comment">// 对右半部分排序</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> left = lo; <span class="comment">// 定义左扫描指针</span></span><br><span class="line">	<span class="keyword">int</span> righ = hi + <span class="number">1</span>; <span class="comment">// 定义右扫描指针</span></span><br><span class="line"></span><br><span class="line">	Comparable v = a[lo]; <span class="comment">// 定义切分元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (less(a[++left], v)) &#123; <span class="comment">// 扫描数组左边，大于等于 V</span></span><br><span class="line">										<span class="comment">// 后结束（注意是大于等于——这样是用来处理有重复的问题）</span></span><br><span class="line">			<span class="keyword">if</span> (left == hi) &#123; <span class="comment">// 检测越界，实际上是多余的，可去掉（a[lo] 就是切分元素，不可能比自己小）</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (less(v, a[--righ])) &#123;<span class="comment">// 扫描数组右边，小于等于 V 后结束（注意同上）</span></span><br><span class="line">			<span class="keyword">if</span> (righ == lo) &#123; <span class="comment">// 检测越界，实际 上是多余的，可去掉</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (left &gt;= righ) &#123;<span class="comment">// 循环终止条件</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		exch(a, left, righ);<span class="comment">// 交换两个元素，保证左侧小于V ，。右侧大于V</span></span><br><span class="line">	&#125;</span><br><span class="line">	exch(a, lo, righ); <span class="comment">// 将V 放入正确的位置(切分点）</span></span><br><span class="line">	<span class="keyword">return</span> righ; <span class="comment">// return找到的切分点的index</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现的注意事项"><a href="#实现的注意事项" class="headerlink" title="实现的注意事项"></a>实现的注意事项</h3><ol>
<li><p>原地切分<br> 使用辅助数组的代码简单，但是切分后复制数组的开销是很大的，</p>
</li>
<li><p>越界问题<br> 要特别小心越界的问题，<br> 但上面的算法中，取样元素V中数组首端，作为<strong>哨兵</strong>，实际<code>partition()</code> 中的数组边界测试是多余的.</p>
</li>
<li><p>随机性<br> 还有一种保持随机性的方法是在<code>partition()</code> 中随机选择一个切分元素。（待研究）</p>
</li>
<li><p>防止死循环</p>
</li>
<li><p>处理切分元素有重复的情况<br> 实现的时候，左侧扫描最好在遇到<strong>大于等于</strong>切分元素时停下，右侧小于等于时停下，尽管这个可以会不必要的将下些等值元素交换，但是可以避免运行时候<strong>变为平方级别</strong>。</p>
</li>
<li><p>防止无穷递归</p>
</li>
</ol>
<h2 id="性能特点："><a href="#性能特点：" class="headerlink" title="性能特点："></a>性能特点：</h2><ol>
<li><p>内循环比大多数排序算法都小。</p>
</li>
<li><p>比较次数：<br> 长度为N的无重复数组，快速排序平均需要~<code>2NlgN</code>次比较和<code>1/6</code>次交换。（有重复的的数组的时间不好计算，不是慢的原因）。<br> 速排序最多需要级N<sup>2</sup>/2次比较。<br>总结：对于大小为N的数组，普通快速排序的运行时间在<code>1.39NlgN</code>的某个常数因子的范围之内。归并也能做到（归并要比快速排序比较次数少39%），但快速排序一般更快，因为它的移动数据的次数更少。</p>
</li>
</ol>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><h3 id="切换到插入排序：（待研究）"><a href="#切换到插入排序：（待研究）" class="headerlink" title="切换到插入排序：（待研究）"></a>切换到插入排序：（待研究）</h3><p>对于小数组; 快速排序比插入排序慢。<br>递归本身在小数组时不够高效（归并排序也有这个问题）。<br>对于参数的选择： 和系统有关，但实验证明<code>5~15</code>之间的任意值在大多数情况下是很高效的。</p>
<h3 id="三取样切分（待研究）"><a href="#三取样切分（待研究）" class="headerlink" title="三取样切分（待研究）"></a>三取样切分（待研究）</h3><p>如果使用数组的<strong>中位数</strong>来切分，那切分更好，但是计算中位数的代价是<strong>得不偿失的</strong>。<br>那我们就使用子数组中的一小部分的中位数来切分：取样大小设为3，并用大小居中的元素切分的效果最好。</p>
<h3 id="熵最优的排序"><a href="#熵最优的排序" class="headerlink" title="熵最优的排序"></a>熵最优的排序</h3><p>针对元素重复的数组——将当前实现的线性对数级的性能提高到<strong>线性级别</strong>。<br>使用三向切分快速排序：<br>三向切分快速排序：</p>
<ul>
<li><p>是<strong>信息量（熵）</strong>最优的！——对于包含大量元素重复的数组将运行时间从线性对数级的降低到线性级别。</p>
</li>
<li><p>三向切分快速排序是<strong>排序库元素</strong>的最佳算法选择。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">	StdRandom.shuffle(a); <span class="comment">// 随机化；</span></span><br><span class="line">	sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (hi &lt;= lo) &#123; <span class="comment">// 递归出口</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 三向切分</span></span><br><span class="line">	<span class="keyword">int</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi; <span class="comment">// 定义三个扫描指针：lt后的元素都小于V，i后的元素都=V，gt前的元素都大于V</span></span><br><span class="line">	Comparable v = a[lo]; <span class="comment">// 定义切分元素</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">		<span class="keyword">int</span> cmp = a[i].compareTo(v);</span><br><span class="line">		<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123; <span class="comment">// a[i]小于V，交换元素，指针lt、 i前移</span></span><br><span class="line">			exch(a, lt++, i++);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123; <span class="comment">//  a[i]大于V 交换元素，指针gt后移，i不变（不确定这个数是否等于V，等下一轮判断）</span></span><br><span class="line">			exch(a, i, gt--);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;  <span class="comment">// a[i]等于V，i前移</span></span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递归调用</span></span><br><span class="line">	sort(a, lo, lt - <span class="number">1</span>); <span class="comment">// 对左半部分排序</span></span><br><span class="line">	sort(a, gt + <span class="number">1</span>, hi); <span class="comment">// 对右半部分排序</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数学-普遍-总结-数学归纳法]]></title>
      <url>/2015/12/%E5%9F%BA%E7%A1%80_%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6-%E6%99%AE%E9%81%8D-%E6%80%BB%E7%BB%93-%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<p><code>数学归纳法</code>（Mathematical Induction, MI）是一种数学证明方法，通常被用于证明某个给定命题在整个（或者局部）自然数范围内成立。除了自然数以外，广义上的数学归纳法也可以用于证明一般良基结构，例如：集合论中的树。这种广义的数学归纳法应用于数学逻辑和计算机科学领域，称作<code>结构归纳法</code>。</p>
<h2 id="数学归纳法（普通）"><a href="#数学归纳法（普通）" class="headerlink" title="数学归纳法（普通）"></a>数学归纳法（普通）</h2><p>最简单和常见的数学归纳法是证明当n等于任意一个自然数时某命题成立。证明分下面两步：</p>
<ol>
<li><p>证明当n = 1时命题成立。</p>
</li>
<li><p>证明如果在n = m时命题成立，那么可以推导出在n = m+1时命题也成立。（m代表任意自然数）</p>
</li>
</ol>
<p><code>原理</code>在于：首先证明在某个起点值时命题成立，然后证明从一个值到下一个值的过程有效。当这两点都已经证明，那么任意值都可以通过反复使用这个方法推导出来。</p>
<h2 id="归纳法的几种变体"><a href="#归纳法的几种变体" class="headerlink" title="归纳法的几种变体"></a>归纳法的几种变体</h2><h3 id="从0以外的自然数开始"><a href="#从0以外的自然数开始" class="headerlink" title="从0以外的自然数开始"></a>从0以外的自然数开始</h3><p>第一种情况： 如果欲证明的命题并不是针对全部自然数，而只是针对所有大于等于某个数字b的自然数，那么证明的步骤需要做如下修改：</p>
<p>第一步，证明当n = b时命题成立。<br>第二步，证明如果n = m（m ≥ b） 成立，那么可以推导出n = m+1也成立。<br>用这个方法可以证明诸如“当n ≥ 3时，n2 &gt; 2n”这一类命题。</p>
<p>第二种情况： 如果欲证明的命题针对全部自然数，但仅当大于等于某个数字b时比较容易证明，则可参考如下步骤：</p>
<p>第一步，证明当n =0，1，2，… b时命题成立。<br>第二步，证明如果n = m（m ≥ b） 成立，那么可以推导出n = m+1也成立。<br>用这种方法可以证明一些需要通过放缩来证明的不等式。</p>
<h3 id="只針對偶数或只針對奇数"><a href="#只針對偶数或只針對奇数" class="headerlink" title="只針對偶数或只針對奇数["></a>只針對偶数或只針對奇数[</h3><p>如果我们想证明的命题并不是针对全部自然数，而只是针对所有奇数或偶数，那么证明的步骤需要做如下修改：</p>
<p>奇数方面：</p>
<p>第一步，证明当n = 1时命题成立。<br>第二步，证明如果n = m成立，那么可以推导出<strong>n = m+2</strong>也成立。<br>偶数方面：</p>
<p>第一步，证明当n = 0或2时命题成立。<br>第二步，证明如果n = m成立，那么可以推导出<strong>n = m+2</strong>也成立。</p>
<h3 id="递降归纳法"><a href="#递降归纳法" class="headerlink" title="递降归纳法"></a>递降归纳法</h3><p>数学归纳法并不是只能应用于形如“对任意的n”这样的命题。对于形如“对任意的n=0,1,2,…,m”这样的命题，如果对一般的n比较复杂，而n=m比较容易验证，并且我们可以实现从k到k-1的递推，k=1,…,m的话，我们就能应用归纳法得到对于任意的n=0,1,2,…,m，原命题均成立。</p>
<h3 id="完整归纳法"><a href="#完整归纳法" class="headerlink" title="完整归纳法"></a>完整归纳法</h3><p>另一个一般化的方法叫完整归纳法（也称第二数学归纳法），在第二步中我们假定式子不仅当n = m时成立，当n小于或等于m时也成立.这样可以设计出这样两步:</p>
<p>证明当n = 0时式子成立.<br>证明当<strong>n ≤ m</strong>时成立，那么当n = m + 1时式子也成立.<br>例如 ：<br>这种方法也是第一种形式的特殊化：</p>
<p>定义P（n） 是我们将证的式子,<br>P（0）和P（1）成立<br><strong>P（m + 1）在P（m）和P（m − 1）成立时成立。</strong><br>结论：P（n）对一切自然数n成立。</p>
<h2 id="结构归纳法（待研究）"><a href="#结构归纳法（待研究）" class="headerlink" title="结构归纳法（待研究）"></a>结构归纳法（待研究）</h2><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 归纳法 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[归并排序算法]]></title>
      <url>/2015/12/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%BD%92%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>归并排序是在算法设计中<strong>分治思想</strong>的典型应用。<br><strong>优点：</strong><br>只要比遍历数组多个对数因子的时间就能排序好一个数组，可以用归并排序处理数百万甚至大规模的数组，这是插入排序或者选择排序做不到的。<br><strong>缺点：</strong><br>辅助数组所使用的<strong>额外空间</strong>和N大小成正比。。<a id="more"></a></p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><a href="https://zh.wikipedia.org/zh/分治法" target="_blank" rel="noopener">分治思想</a>:将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。<br>分治法解题的一般步骤：<br>（1）分解，将要解决的问题划分成若干规模较小的同类问题；<br>（2）求解，当子问题划分得足够小时，用较简单的方法解决；<br>（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。</p>
<p><strong>二叉树</strong>：是描述算法中的比较的一个数学 工具。<br>二叉树一的个基本性质： 高度为h的树最多只可能有2<sup>K</sup>个叶子结点。<br><strong>完全树</strong>：拥有2<sup>h</sup>个叶子结点的树，（又称平衡树）</p>
<p>任意基于比较的排序算法都对应着一棵高为H的比较树，其中：<br>N! /&lt;= 叶子结点的数量 /&lt;= 2<sup>K=h</sup></p>
<h2 id="原地归并方法"><a href="#原地归并方法" class="headerlink" title="原地归并方法"></a>原地归并方法</h2><p>原地归并的<strong>实现很复杂</strong>，尤其和使用使用额外空间的方法相比。<br>下面是一种实现方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux; <span class="comment">// 辅助数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;<span class="comment">// 将数组a copy到辅助数组aux中</span></span><br><span class="line">		aux[k] = a[k];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = lo;</span><br><span class="line">	<span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; mid) &#123; <span class="comment">// 左边用尽时：取右边的元素</span></span><br><span class="line">			a[k] = aux[j++];</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123; <span class="comment">// 右边用尽时： 取左边的元素</span></span><br><span class="line">			a[k] = aux[i++];</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) &#123; <span class="comment">//比较两边，取大的那边的元素。</span></span><br><span class="line">			a[k] = aux[j++];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			a[k] = aux[i++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自顶向下的归并"><a href="#自顶向下的归并" class="headerlink" title="自顶向下的归并"></a>自顶向下的归并</h2><p>对于长度为<code>N</code>的任意数组，自顶向下的归并排序需要<code>1/2NlgN 至 NlgN</code> 次比较.<br>对于长度为<code>N</code>的任意数组,自顶向下的归并排序需要访问数组<code>6NlgN次</code>.<br><strong>总结：</strong>归并排序所需要的时间和<code>NlgN成正比</code>。</p>
<p>java 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Rearranges the array in ascending order, using the natural order</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">	 *            the array to be sorted</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">		aux = <span class="keyword">new</span> Comparable[a.length]; <span class="comment">// 一次性分配空间</span></span><br><span class="line"></span><br><span class="line">		sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// mergesort a[lo..hi]</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (hi &lt;= lo) &#123; <span class="comment">// 递归跳出条件</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>; <span class="comment">// 注意，看如何计算中间值的方法</span></span><br><span class="line"></span><br><span class="line">		sort(a, lo, mid);</span><br><span class="line">		sort(a, mid + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">		merge(a, lo, mid, hi); <span class="comment">// 并归结果</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（待研究）改进方案"><a href="#（待研究）改进方案" class="headerlink" title="（待研究）改进方案"></a>（待研究）改进方案</h3><p>对小规模的数组使用插入排序（例如长度小于15的） ：递归会使小规模的问题方法调用过于频繁。</p>
<p>测试数组是否已经有序： 任意有序子数组组算法的运行时间就变为线性的了。</p>
<p>不将元素复制到辅助数组： 将节省将数组元素复制 到用于归并的辅助数组所用的时间，（但空间不行。）</p>
<p>将aux[] 变为sort()方法的一个局部变量，并将它作为参数传递给merge() —— 避免每次归并 时，都创建一个新数组。</p>
<h2 id="自底向上的归并"><a href="#自底向上的归并" class="headerlink" title="自底向上的归并"></a>自底向上的归并</h2><p>代码量要更小（与标准递归方法相比）。</p>
<p>对于长度为N的任意数组，自底向上的归并排序需要<code>1/2NlgN 至 NlgN</code> 次比较。访问数组<code>6NlgN次</code>。</p>
<p>当数组<strong>长度为2的幂</strong>时，自顶向下和自底向上的的归并排序所用的比较次数和数组访问次数正好相同。</p>
<p>自底向上的归并排序比较适合用链表组织的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rearranges the array in ascending order, using the natural order</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> *            the array to be sorted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = a.length;</span><br><span class="line">	aux = <span class="keyword">new</span> Comparable[a.length]; <span class="comment">// 一次性分配空间</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">1</span>; size &lt; N; size = size + size) &#123; <span class="comment">// 确定子数组的大小</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N - size; lo += size + size) &#123; <span class="comment">// 子</span></span><br><span class="line">			merge(a, lo, lo + size - <span class="number">1</span>, Math.min(lo + size - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序的时间复杂度分析"><a href="#排序的时间复杂度分析" class="headerlink" title="排序的时间复杂度分析"></a>排序的时间复杂度分析</h2><p>没有任何基于比较的算法能够保证使用少于lg(N!)~NlgN次比较将长度为N的数组排序。</p>
<p>归并排序是一种<strong>渐进最优</strong>的基于比较排序的算法。</p>
<h2 id="与快速算法相比"><a href="#与快速算法相比" class="headerlink" title="与快速算法相比"></a>与快速算法相比</h2><p>对于含有任意概率分布的重复元素的输入，归并排序无法保证最佳性能。<br>对于含有不若干不同主键的随机数组，归并排序的时间复杂度是线性对数的，三向切分快速排序是线性的。</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Algorithms-笔记-排序基础]]></title>
      <url>/2015/12/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>主要描绘了插入排序，选择排序 ，希尔排序的实现、特点等。、。<a id="more"></a></p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><a href="https://zh.wikipedia.org/wiki/关系键" target="_blank" rel="noopener">主键的概念(wiki)</a></p>
<p><strong>全序关系</strong> 的概念：（离散数学中讲过）：自反性；反对称性；传递性。<br>（插入算法中使用） ：<strong>部分有序</strong> 的概念：</p>
<p>（希尔算法中使用）： <strong>递增序列</strong>的概念：</p>
<p>（希尔算法中使用）： <strong>有序数组</strong>的概念：数组中任意间隔为H的元素都是有序的。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>排序算法类模板：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sort()</td>
<td style="text-align:left">排序代码</td>
</tr>
<tr>
<td>less()</td>
<td style="text-align:left">对元素进行比较 （通过Comparable接口）</td>
</tr>
<tr>
<td>exch()</td>
<td style="text-align:left">将元素交换位置</td>
</tr>
<tr>
<td>main()</td>
<td style="text-align:left">测试用</td>
</tr>
</tbody>
</table>
<p>这种<strong>将数据操作限制在不同的方法</strong>中，使得代码的可读性和可移植性更好，更容易难代码的正确性，和分析性能 。</p>
<p>评估排序算法性能时的<strong>排序成本模型</strong> 是：要计算比较和交换的数量，在不交换的算法中，计算访问数组的次数。</p>
<p>排序算法的<strong>额外内存开销</strong>和运行时间是同等重要的，我们把无需额外内存的算法：称之为<strong>原地排序算法</strong>。</p>
<p>排序算法要求要实现排序算法的数据类型必须实现<strong>Comparable 接口</strong> ，而Comparable接口中要实现 <strong>compareTo()方法</strong>定义对象的<strong>自然次序</strong>。</p>
<p><code>compareTo()</code>方法<strong>必须</strong>实现一个<strong>全序关系</strong> 。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>对于长度为的数组，选择排序需要约<strong>N<sup>2</sup>/2 次比较</strong>和<strong>N次交换</strong>。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><p>运行时候和输入无关</p>
</li>
<li><p>数据移动是最少的 —— 每次交换只改变两个数组元素的值，因此 选择排序用了N次交换——交换的次数和数组的大小是线性关系。</p>
</li>
</ul>
<h3 id="实现代码-主要部分"><a href="#实现代码-主要部分" class="headerlink" title="实现代码(主要部分)"></a>实现代码(主要部分)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rearranges the array in ascending order, using the natural order.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a the array to be sorted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, i, min);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, <span class="number">0</span>, i)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>对于随机排列的长为N的且主键不重复的数组，平均情况下插入排序需要<strong>N<sup>2</sup>/4 次比较</strong>和<strong>N<sup>2</sup>/4次交换</strong>。<br>最坏的情况下，需要<strong>N<sup>2</sup>/2 次比较</strong>和<strong>N<sup>2</sup>/2 次交换</strong>。最好的情况下，需要<strong>N-1次比较</strong>和<strong>0次交换</strong>。</p>
<p>插入排序 对<code>非随机数组</code>很有效。当一个数组中<code>倒置</code>的数量很少时，插入排序的是所有常见算法中最快的。总的来说，插入排序对于<code>部分有序</code>的数组十分高效，也很适合小规模数组。（大型数组不合适）</p>
<p>总的来说，它的复杂度是取决于输入元素的排列情况的。</p>
<h3 id="（待研究）如何大幅度提高插入排序的速度"><a href="#（待研究）如何大幅度提高插入排序的速度" class="headerlink" title="（待研究）如何大幅度提高插入排序的速度"></a>（待研究）如何大幅度提高插入排序的速度</h3><p>内循环中将较大的元素都向右移动，而不是总是交换两个元素——这样访问数组的次数就能<strong>减半</strong>。</p>
<h3 id="实现代码-主要部分-1"><a href="#实现代码-主要部分-1" class="headerlink" title="实现代码(主要部分)"></a>实现代码(主要部分)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--) &#123;</span><br><span class="line">            exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, <span class="number">0</span>, i)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>是一种基于插入排序的快速的排序算法。</p>
<p>其更高效的原因：权衡了子数组的规模和有序性。</p>
<p>希尔排序也可以用于大型数组，它对任意排序（不一定是随机的）的数组表现也很好。希尔排序比插入排序和选择排序要快得多，且数组越大优势越大。在实际应用中，对于中等大小的数组它的运行时间是可以接受的。它的代码量很小，且不需要使用额外的内存空间。</p>
<p>理论上，还没有人能够证明希尔排序对于随机数组的运行时间是线性对数级别，因此存在平均情况下希尔的性能的<strong>渐进增长率</strong>更高的可能性。（在最坏的情况下，这种差距的存在已经被证实了，但对实际没有影响）。<br>也就是说希尔排序的复杂度只是一个<strong>近似值</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable&lt;T&gt;[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length; <span class="comment">// the length of array</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>; <span class="comment">// array 的有序元素的间隔</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) &#123;</span><br><span class="line">        h = h * <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// 1, 4,13, 40, 121, 364, 1093 .......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// h-sort the array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123;</span><br><span class="line">                exch(a, j, j - h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript进阶——浏览器对象]]></title>
      <url>/2015/12/coding/Java-Web-%E7%AC%94%E8%AE%B0-JavaScript%E8%BF%9B%E9%98%B6-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><h3 id="javascript组成部分："><a href="#javascript组成部分：" class="headerlink" title="javascript组成部分："></a>javascript组成部分：</h3><p>EMCAScript（基本语法）<br>BOM( Browser Object MOdel) 浏览器对象模型.<br>浏览器对象模型中把浏览器 的各个部分都是用了一个对象进行描述，如果我们要<br>操作浏览器的一些属性，我就可以通过浏览器对象模型 的对象进行操作。</p>
<h3 id="常见的几个对象"><a href="#常见的几个对象" class="headerlink" title="常见的几个对象"></a>常见的几个对象</h3><p><code>window</code>  代表了一个新开的窗口<br><code>location</code>代表了地址栏对象。<br><code>screen</code>  代表了整个屏幕的对象</p>
<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><h3 id="window对象常用的方法："><a href="#window对象常用的方法：" class="headerlink" title="window对象常用的方法："></a>window对象常用的方法：</h3><table>
<thead>
<tr>
<th></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td>open()</td>
<td style="text-align:left">打开新窗口并装入给定 URL 的文档。</td>
</tr>
<tr>
<td>resizeTo()</td>
<td style="text-align:left">将窗口的大小更改为指定的宽度和高度值。<strong>在多标签窗口中无效</strong>。</td>
</tr>
<tr>
<td>moveBy()</td>
<td style="text-align:left">相对于原来的窗口移动指定的x、y值。</td>
</tr>
<tr>
<td>moveTo()</td>
<td style="text-align:left">将窗口左上角的屏幕位置移动到指定的 x 和 y 位置。</td>
</tr>
<tr>
<td>setInterval()</td>
<td style="text-align:left">每经过指定毫秒值后就会执行指定的代码。</td>
</tr>
<tr>
<td>clearInterval()</td>
<td style="text-align:left">根据一个任务的ID取消的定时任务。</td>
</tr>
<tr>
<td>setTimeout()</td>
<td style="text-align:left">经过指定毫秒值后执行指定 的代码一次。</td>
</tr>
</tbody>
</table>
<p>注意： 使用window对象的任何属性与方法都可以省略window对象不写的</p>
<h3 id="使用Demo"><a href="#使用Demo" class="headerlink" title="使用Demo"></a>使用Demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>window对象Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">		function showURL() &#123; //打开一个新的窗口。</span></span><br><span class="line"><span class="undefined">			window.open("Demo-Javascript-当前系统时间.html","_blank","height=400px, width=400px, toolbar=no,laction=no,top=500px");</span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">		function small() &#123;//注意在多标签窗口中无效。</span></span><br><span class="line"><span class="undefined">			window.resizeTo(500,500);//相对于原本窗口改变指定的大小。</span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">		function move() &#123;</span></span><br><span class="line"><span class="undefined">			moveBy(50,0);// 相对于原来的窗口移动指定的x、y值.</span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">		function move2() &#123;</span></span><br><span class="line"><span class="undefined">			window.moveTo(500,500);</span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="undefined"> </span></span><br><span class="line"><span class="undefined">		var id1 = window.setInterval("showURL()", 1000);//没显示可能就是被浏览器拦截了……&amp;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">		function clear001() &#123;</span></span><br><span class="line"><span class="undefined">			window.clearInterval(id);</span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="undefined"> 	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"showURL()"</span> <span class="attr">value</span>=<span class="string">"download"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"small()"</span>  <span class="attr">value</span> =<span class="string">"smaller"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"move()"</span>  <span class="attr">value</span> =<span class="string">"move"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"move2()"</span>  <span class="attr">value</span> =<span class="string">"moveTo"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"clear001()"</span>  <span class="attr">value</span> =<span class="string">"clear"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Window事件"><a href="#Window事件" class="headerlink" title="Window事件"></a>Window事件</h2><h3 id="注册事件的方式："><a href="#注册事件的方式：" class="headerlink" title="注册事件的方式："></a>注册事件的方式：</h3><p>方式一： 直接在html元素上注册</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"ready()"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   function ready()&#123;</span><br><span class="line">       alert("body的元素被加载完毕了..");	</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>方式二：可以js代码向找到对应的对象再注册。 <strong>推荐使用</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bodyNode = <span class="built_in">document</span>.getElementById(<span class="string">"body"</span>);</span><br><span class="line">bodyNode.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"body的元素被加载完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;body id=<span class="string">"body"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="常用的事件"><a href="#常用的事件" class="headerlink" title="常用的事件"></a>常用的事件</h3><p>鼠标点击相关：<br><code>onclick</code> 在用户用鼠标左键单击对象时触发。<br><code>ondblclick</code>当用户双击对象时触发。<br><code>onmousedown</code> 当用户用任何鼠标按钮单击对象时触发。<br><code>onmouseup</code> 当用户在鼠标位于对象之上时释放鼠标按钮时触发。 </p>
<p>鼠标移动相关：<br><code>onmouseout</code>  当用户将鼠标指针移出对象边界时触发。<br><code>onmousemove</code> 当用户将鼠标划过对象时触发。 </p>
<p>焦点相关的：<br><code>onblur</code> 在对象失去输入焦点时触发。<br><code>onfocus</code> 当对象获得焦点时触发。</p>
<p>其他：<br><code>onchange</code> 当对象或选中区的内容改变时触发。<br><code>onload</code> 在浏览器完成对象的装载后立即触发。<br><code>onsubmit</code> 当表单将要被提交时触发。 </p>
<h3 id="使用Demo-1"><a href="#使用Demo-1" class="headerlink" title="使用Demo"></a>使用Demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">clickTest</span>(<span class="params"></span>)</span>&#123; <span class="comment">//打开一个新的窗口。</span></span></span><br><span class="line"><span class="javascript">			alert(<span class="string">"over"</span>);</span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">showTime</span>(<span class="params"></span>)</span>&#123;<span class="comment">//被触发后，以红色字体显示当前时间</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> timeSpan = <span class="built_in">document</span>.getElementById(<span class="string">"timeSpan"</span>);</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> date  = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString();<span class="comment">//获取系统当前时间</span></span></span><br><span class="line"><span class="javascript">			timeSpan.innerHTML = date.fontcolor(<span class="string">"red"</span>);<span class="comment">//以红色字体显示</span></span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">hideTime</span>(<span class="params"></span>)</span>&#123;<span class="comment">//被触发 ，显示空白</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> timeSpan = <span class="built_in">document</span>.getElementById(<span class="string">"timeSpan"</span>);</span></span><br><span class="line"><span class="javascript">			timeSpan.innerHTML = <span class="string">""</span>;</span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">showInfo</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> myinfo = <span class="built_in">document</span>.getElementById(<span class="string">"userName"</span>);</span></span><br><span class="line"><span class="javascript">			myinfo.innerHTML = <span class="string">"userName"</span>.fontcolor(<span class="string">"green"</span>);</span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">hideInfo</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">			 <span class="keyword">var</span> myinfo = <span class="built_in">document</span>.getElementById(<span class="string">"userName"</span>);</span></span><br><span class="line"><span class="javascript">			myinfo.innerHTML = <span class="string">" "</span>;</span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"> 	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"clickTest()"</span> <span class="attr">value</span>=<span class="string">"clickTest"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span> <span class="attr">onmousemove</span>=<span class="string">"showTime()"</span> <span class="attr">onmouseout</span>=<span class="string">"hideTime()"</span> &gt;</span>查看当前系统时间：<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"timeSpan"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	用户名<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">onfocus</span> = <span class="string">"showInfo()"</span> <span class="attr">onblur</span> = <span class="string">"hideInfo()"</span> /&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span> = <span class="string">"userName"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Java </tag>
            
            <tag> JavaWeb </tag>
            
            <tag> Javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对行列式的理解]]></title>
      <url>/2015/12/%E5%BE%85%E6%95%B4%E7%90%86/%E6%95%B0%E5%AD%A6-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E6%80%BB%E7%BB%93-%E5%AF%B9%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<h2 id="什么是行列式"><a href="#什么是行列式" class="headerlink" title="什么是行列式"></a>什么是行列式</h2><h3 id="简单的说："><a href="#简单的说：" class="headerlink" title="简单的说："></a>简单的说：</h3><p>行列式是一个函数。他取一个方矩阵为变量，得到一个数。这个函数的返回值是一个体积。例如：<code>2 x 2</code>的行列式明显就是一个平行四边形的有向面积.<br>矩阵和行列式从发明以来，就用来处理两个问题：<strong>方程组</strong>，<strong>空间变换</strong>。</p>
<h3 id="wiki中是这样说的："><a href="#wiki中是这样说的：" class="headerlink" title="wiki中是这样说的："></a><a href="https://zh.wikipedia.org/wiki/行列式" target="_blank" rel="noopener">wiki</a>中是这样说的：</h3><blockquote>
<p>行列式是数学中的一個函數，将一个n * n的矩陣A映射到一個純量，记作<code>det(A)</code>或<code>|A|</code>。行列式可以看做是有向面积或体积的概念在一般的欧几里得空间中的推广。或者说，在n 维欧几里得空间中，行列式描述的是一个线性变换对“体积”所造成的影响。<br>行列式概念最早出现在解线性方程组的过程中。十七世纪晚期，关孝和与莱布尼茨的著作中已经使用行列式来确定线性方程组解的个数以及形式。十八世纪开始，行列式开始作为独立的数学概念被研究。十九世纪以后，行列式理论进一步得到发展和完善。矩阵概念的引入使得更多有关行列式的性质被发现，行列式在许多领域都逐渐显现出重要的意义和作用，出现了线性自同态和向量组的行列式的定义。<br>行列式的特性可以被概括为<strong>一个交替多线性形式</strong>，这个本质使得行列式在欧几里德空间中可以成为描述<strong>“体积”</strong>的函数。</p>
</blockquote>
<h2 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h2><h3 id="二维向量组"><a href="#二维向量组" class="headerlink" title="二维向量组"></a>二维向量组</h3><p>行列式表示的是一个平行四边形的<strong>有向面积</strong>，而当行列式为零当且仅当两个向量共线（线性相关），这时平行四边形退化成一条直线。这时面积自然是0了。</p>
<h3 id="三维向量组"><a href="#三维向量组" class="headerlink" title="三维向量组"></a>三维向量组</h3><p>行列式表示三个向量形成的平行六面体的<strong>有向体积</strong><br>而行列式为零当且仅当三个向量共线或者共面（三者线性相关），这时平行六面体退化为平面图形，体积自然是零。</p>
<h3 id="n维欧几里得空间"><a href="#n维欧几里得空间" class="headerlink" title="n维欧几里得空间"></a>n维欧几里得空间</h3><p>行列式的一个自然的源起是n维平行体的体积。行列式的定义和n维平行体的体积有着本质上的关联。<br>待buchou</p>
<h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>行列式表示的是线性变换前后平行六面体的体积的<strong>变化系数</strong>。</p>
<h3 id="注意的几个问题"><a href="#注意的几个问题" class="headerlink" title="注意的几个问题"></a>注意的几个问题</h3><p><strong>有向体积</strong>的问题：参考有向角；<br><strong>基底</strong>的选择：基底可以理解为直角坐标系。那么可以这么说，如果我们选择的基底都是“单位长度”，并且两两正交，那么在这样的基之下，平行六面体的<strong>体积</strong>的绝对值是唯一的。</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.zhihu.com/question/19919917/answer/13352682" target="_blank" rel="noopener">知乎</a><br><a href="https://zh.wikipedia.org/wiki/行列式" target="_blank" rel="noopener">wiki</a></p>
]]></content>
      
        <categories>
            
            <category> 数学 </category>
            
            <category> 矩阵分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 矩阵分析 </tag>
            
            <tag> 行列式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数学-矩阵分析-笔记-2阶方阵性质]]></title>
      <url>/2015/12/%E5%BE%85%E6%95%B4%E7%90%86/%E6%95%B0%E5%AD%A6-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%94%E8%AE%B0-2%E9%98%B6%E6%96%B9%E9%98%B5%E6%80%A7%E8%B4%A8/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="tr-A-怎么求？"><a href="#tr-A-怎么求？" class="headerlink" title="tr(A)怎么求？"></a>tr(A)怎么求？</h3><p>一个矩阵的迹等于特征值之和。<br>矩阵的迹具有相似不变性。（这是个大杀器）<br>Geometrically, the trace can be interpreted as the infinitesimal change in volume (as the derivative of the determinant), which is made precise in Jacobi’s formula.</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 数学 </category>
            
            <category> 矩阵分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 矩阵分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[矩阵分析笔记-第一节课 背景介绍]]></title>
      <url>/2015/12/%E5%BE%85%E6%95%B4%E7%90%86/%E6%95%B0%E5%AD%A6-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h3><p>线性变换  T ：V<sub>1</sub> —–&gt; V<sub>1</sub></p>
<p>维数 dim V （我们考虑有限维）</p>
<p>矩阵 &lt;—–相互对应—-&gt; 线性变换</p>
<p>同一个线性变换可以对应不同的矩阵（因有不同的basis）</p>
<p>以后以讨论矩阵为主，但是矩阵的背后有线性变换的概念支撑。</p>
<h3 id="线性空间和矩阵的对应"><a href="#线性空间和矩阵的对应" class="headerlink" title="线性空间和矩阵的对应"></a>线性空间和矩阵的对应</h3><p>已知：有线性变换T ：V<sub>1</sub> —–&gt; V<sub>1</sub><br>有如下变换：<br>{e1}—T—&gt; {fj} :A<br>{e`1}—T—&gt; {fj} ：B<br>则AB矩阵的关系：<br>A(m*n) = B(m*n) X(n*n)</p>
<p>有如下变换：<br>{e1}—T—&gt; {fj} :A<br>{e`1}—T—&gt; {fj} ：B<br>则AB矩阵的关系：<br>A(m*n) = X(n*n)B(m*n) </p>
<p>如有以下关系：V<sub>1</sub> = V<sub>1</sub>  dimV = n<br>则：<br>A = X<sup>-1</sup> B X<br>我们称之为A,B similar (那我们就知道了，所谓的相似矩阵，实际上就是同一个线性变换 ，但是basis不同而已)</p>
<h3 id="内积与线性空间的对应"><a href="#内积与线性空间的对应" class="headerlink" title="内积与线性空间的对应"></a>内积与线性空间的对应</h3><p>已知: 有线性变换V<sub>1</sub>  V<sub>1</sub><br>     对应的basis {ei}             {fj}<br>同上的线性空间和矩阵的对应 则有：<br>A = B U  (Un*n 是 Unitary matrix  满足 U<sup>*</sup>U =UU<sup>*</sup> = I <sup>n</sup>)<br>A = V B<br>A = V B U<br>A = U<sup>*</sup>B U =UBU<sup>*</sup>  </p>
<h3 id="几个相关概念"><a href="#几个相关概念" class="headerlink" title="几个相关概念"></a>几个相关概念</h3><p><a href="http://baike.baidu.com/link?url=zYH2yxC2s5N3QtniCD5TupW4GVd5P6_OQZGaaqyQ_U0I2lWV9S95-_mSAhUapEjiknbciueWoFYmsJYdSKoc6K" target="_blank" rel="noopener">Unitary matrix 酉矩阵</a> ：  n阶复方阵U的n个列向量是U空间的一个标准正交基，则U是酉矩阵(Unitary Matrix)。显然酉矩阵是正交矩阵往复数域上的推广。<br><a href="http://baike.baidu.com/view/21085.htm" target="_blank" rel="noopener">正交矩阵</a> ：是实数特殊化的酉矩阵，因此总是正规矩阵。尽管我们在这里只考虑实数矩阵，这个定义可用于其元素来自任何域的矩阵。正交矩阵毕竟是从内积自然引出的，对于复数的矩阵这导致了归一要求。</p>
<h3 id="标准式的概念"><a href="#标准式的概念" class="headerlink" title="标准式的概念"></a>标准式的概念</h3><p>为了比较、判断几个矩阵的不同而产生的。所以有以下要求：要简单（好比较）；要所有的矩阵都可以化成标准式；</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 数学 </category>
            
            <category> 矩阵分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 矩阵分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Javascript基础语法笔记02]]></title>
      <url>/2015/11/coding/Java-Web-%E7%AC%94%E8%AE%B0-Javascript%E5%9F%BA%E7%A1%8002/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数:"></a>函数:</h2><p>函数的定义格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参列表</span>)</span>&#123;</span><br><span class="line">		函数体 ;</span><br></pre></td></tr></table></figure>
<h3 id="js函数要注意的细节："><a href="#js函数要注意的细节：" class="headerlink" title="js函数要注意的细节："></a>js函数要注意的细节：</h3><ol>
<li><p>在 javascript中函数 定义形参时是不能使用var关键字声明变量 的。(<strong>和java不同</strong>)</p>
</li>
<li><p>在javascript中 的函数是<strong>没有 返回值类型</strong>的，如果函数需要返回数据给调用者，直接返回即可，如果不需要返回则不返回。</p>
</li>
<li><p>在 javascript中是<strong>没有函数重载</strong>的概念 的，后定义的<strong>同名函数</strong>会直接覆盖前面定义同名函数。）</p>
</li>
<li><p>在javascript中任何的函数内部都隐式的维护了一个arguments（数组）的对象，给函数传递数据的时候，是会先传递到arguments对象中，然后再由arguments对象分配数据给形参的。(见Demo)</p>
</li>
</ol>
<h2 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h2><p>创建一个字符串的方式：<br>方式1：<code>new String(&quot;字符串的内容&quot;);</code><br>方式2：<code>var str = &quot;字符串的内容&quot;;</code> </p>
<h3 id="字符串常用的方法："><a href="#字符串常用的方法：" class="headerlink" title="字符串常用的方法："></a>字符串常用的方法：</h3><table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>anchor（）</td>
<td style="text-align:left">生产锚点(注意，必须带一个参数)</td>
</tr>
<tr>
<td>blink（）</td>
<td style="text-align:left">为元素添加blink标签</td>
</tr>
<tr>
<td>charAt()</td>
<td style="text-align:left">返回指定索引位置处的字符。</td>
</tr>
<tr>
<td>charCodeAt()</td>
<td style="text-align:left">回一个整数，代表指定位置上字符的 Unicode 编码。</td>
</tr>
<tr>
<td>fontcolor()</td>
<td style="text-align:left">把带有 COLOR 属性的一个 HTML <code>FONT</code> 标记放置在 String 对象中的文本两端</td>
</tr>
<tr>
<td>indexOf()</td>
<td style="text-align:left">返回 String 对象内第一次出现子字符串的字符位置</td>
</tr>
<tr>
<td>italics()</td>
<td style="text-align:left">把 HTML  <code>I</code>标记放置在 String 对象中的文本两端 。（文本内容设置成斜体。）</td>
</tr>
<tr>
<td>link()</td>
<td style="text-align:left">把一个有 HREF 属性的 HTML 锚点放置在 String 对象 中的文本两端。</td>
</tr>
<tr>
<td>replace()</td>
<td style="text-align:left">返回根据正则表达式进行文字替换后的字符串的复制</td>
</tr>
<tr>
<td>split()</td>
<td style="text-align:left">切割</td>
</tr>
<tr>
<td>Substr()</td>
<td style="text-align:left">截取子串</td>
</tr>
<tr>
<td>toUpperCase()</td>
<td style="text-align:left">转大写</td>
</tr>
<tr>
<td>toLowerCase</td>
<td style="text-align:left">转小写</td>
</tr>
</tbody>
</table>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="built_in">String</span> (<span class="string">"hello"</span>);</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span> (<span class="string">"hello"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write((str2 == str1));</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"&lt;br/&gt;"</span>);</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"diwuzhang"</span>.anchor(<span class="string">"five"</span>) + <span class="string">"&lt;br/&gt;"</span>);<span class="comment">//参数是必须传的</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"第五章"</span>.blink()+<span class="string">"&lt;br/&gt;"</span>);</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"abc"</span>.charAt(<span class="number">1</span>)+<span class="string">"&lt;br/&gt;"</span>); <span class="comment">//结果：b </span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"abc"</span>.charCodeAt(<span class="number">1</span>)+<span class="string">"&lt;br/&gt;"</span>); <span class="comment">//结果 98 ；chatCodeAt返回的是索引值对应的字符的码值。</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"给你点颜色看看"</span>.fontcolor(<span class="string">"red"</span>)+<span class="string">"&lt;br/&gt;"</span>);<span class="comment">//实际 上：fontcolor() 给字符串添加font标签，然后设置color的属性值。： &lt;font color="red"&gt;给你点颜色看看&lt;/font&gt;</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"italics把文本内容设置成斜体"</span>.italics()+<span class="string">"&lt;br/&gt;"</span>); <span class="comment">//给文本添加一个i标签，把文本内容设置成斜体。</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"itcast的作用我的博客"</span>.link(<span class="string">"http://chnwentao.com"</span>)+<span class="string">"&lt;br/&gt;"</span>); <span class="comment">// 给文本添加一个a标签，&lt;a href="http://chnwentao.com"&gt;itcast的作用我的博客&lt;/a&gt;</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"明天我们讲xml"</span>.replace(<span class="string">"xml"</span>,<span class="string">"DOM编程"</span>)+<span class="string">"&lt;br/&gt;"</span>); </span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> str = <span class="string">"我们-大家-好"</span>;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> arr = str.split(<span class="string">"-"</span>);</span></span><br><span class="line"><span class="javascript">	<span class="keyword">for</span>(<span class="keyword">var</span> index = <span class="number">0</span> ; index&lt;arr.length ; index++)&#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">document</span>.write(arr[index]+<span class="string">","</span>);	</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"&lt;br/&gt;"</span>);</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"abc"</span>.toUpperCase()+<span class="string">"&lt;br/&gt;"</span>); <span class="comment">//转大写</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"ABC"</span>.toLowerCase()+<span class="string">"&lt;br/&gt;"</span>);  <span class="comment">//转小写</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//获取到当前的系统时间</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"年："</span>+ date.getFullYear()+<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"月："</span>+ (date.getMonth()+<span class="number">1</span>)+<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"日："</span>+ date.getDate()+<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"时："</span>+ date.getHours()+<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"分："</span>+ date.getMinutes()+<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"秒："</span>+ date.getSeconds()+<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//xxxx年yy月dd日  hh:mm:ss</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"当前时间是："</span>+date.toLocaleString());<span class="comment">//系统自动生成的当前时间，但是格式是固定的</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"当前时间是："</span>+date.getFullYear()+<span class="string">"年"</span>+(date.getMonth()+<span class="number">1</span>)+<span class="string">"月"</span>+date.getDate()+<span class="string">"日 "</span>+ date.getHours()+<span class="string">":"</span>+date.getMinutes()+<span class="string">":"</span>+date.getSeconds())<span class="comment">//可以自己设定成的当前时间</span></span><br></pre></td></tr></table></figure>
<h3 id="日期使用Demo"><a href="#日期使用Demo" class="headerlink" title="日期使用Demo"></a>日期使用Demo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	当前系统时间：&lt;span id=<span class="string">"time"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">	&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">getCunrrentTime</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// body...</span></span><br><span class="line">		<span class="comment">// 获取到当前的系统时间</span></span><br><span class="line">		<span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">		<span class="comment">//把当前系统时间拼装成我指定的格式。</span></span><br><span class="line">		<span class="keyword">var</span> timeInfo = date.getFullYear()+<span class="string">"年"</span>+(date.getMonth()+<span class="number">1</span>)+<span class="string">"月"</span>+date.getDate()+<span class="string">"日 "</span>+ date.getHours()+<span class="string">":"</span>+date.getMinutes()+<span class="string">":"</span>+date.getSeconds();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//找span对象</span></span><br><span class="line">		<span class="keyword">var</span> spanObj = <span class="built_in">document</span>.getElementById(<span class="string">"time"</span>);</span><br><span class="line">		<span class="comment">//设置span标签体的内容</span></span><br><span class="line">		spanObj.innerHTML = timeInfo.fontcolor(<span class="string">"red"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	getCunrrentTime();</span><br><span class="line">	<span class="comment">//定时方法.(网页上显示的时间会不断的刷新)</span></span><br><span class="line">	<span class="built_in">window</span>.setInterval(<span class="string">"getCunrrentTime()"</span>, <span class="number">1000</span>);<span class="comment">/* setInterval   定时方法，第一个参数要指定调用的代码，第二参数是每                                                隔指定的毫秒数调用指定的代码。*/</span></span><br><span class="line"></span><br><span class="line">	&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h2><h3 id="创建Number对象的方式"><a href="#创建Number对象的方式" class="headerlink" title="创建Number对象的方式:"></a>创建Number对象的方式:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方式1：</span><br><span class="line">	var 变量=  new Number(数字)	</span><br><span class="line">方式2：</span><br><span class="line">	var 变量 = 数字;</span><br></pre></td></tr></table></figure>
<h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法:"></a>常用的方法:</h3><table>
<thead>
<tr>
<th></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>toString()</code></td>
<td style="text-align:left">把数字转换成<strong>指定进制</strong>形式的字符串。</td>
</tr>
<tr>
<td><code>toFixed()</code></td>
<td style="text-align:left">指定保留小数位,而且还<strong>带四舍五入的功能</strong>。</td>
</tr>
</tbody>
</table>
<h3 id="使用Demo"><a href="#使用Demo" class="headerlink" title="使用Demo"></a>使用Demo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"十进制: "</span> + num.toString());</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"十六进制："</span> + num.toString(<span class="number">16</span>));</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"二进制： "</span> + num.toString(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"保留两位小数："</span> + num2.toFixed(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><h3 id="常用的方法："><a href="#常用的方法：" class="headerlink" title="常用的方法："></a>常用的方法：</h3><table>
<thead>
<tr>
<th></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td>ceil （）</td>
<td style="text-align:left">向上取整</td>
</tr>
<tr>
<td>floor（）</td>
<td style="text-align:left">向下取整</td>
</tr>
<tr>
<td>random()</td>
<td style="text-align:left">随机数方法 ——产生的伪随机数介于 0 和 1 之间（含 0，不含 1），</td>
</tr>
<tr>
<td>round</td>
<td style="text-align:left">四舍五入到整数</td>
</tr>
</tbody>
</table>
<h3 id="使用Demo-1"><a href="#使用Demo-1" class="headerlink" title="使用Demo"></a>使用Demo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">"向上取整："</span>+ <span class="built_in">Math</span>.ceil(num2)+<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"向下取整："</span>+ <span class="built_in">Math</span>.floor(num2)+<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"随机数："</span>+ <span class="built_in">Math</span>.random()+<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"四舍五入:"</span> + <span class="built_in">Math</span>.round(num2)+<span class="string">"&lt;br/&gt;"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Array数组对象"><a href="#Array数组对象" class="headerlink" title="Array数组对象:"></a>Array数组对象:</h2><h3 id="创建数组的方式1："><a href="#创建数组的方式1：" class="headerlink" title="创建数组的方式1："></a>创建数组的方式1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方式1：(常用)</span><br><span class="line">var 变量名 = new Array();  创建一个长度为0的数组。</span><br><span class="line">方式2：（指定长度）</span><br><span class="line">var 变量名= new Array(长度) 创建一个指定长度的数组对象。</span><br><span class="line">方式3：</span><br><span class="line">var 变量名 = new Array(&quot;元素1&quot;,&quot;元素2&quot;...);  给数组指定元素创建数组 的对象。</span><br><span class="line">方式4：（练习时常用）</span><br><span class="line">var 变量名 = [&quot;元素1&quot;,&quot;元素2&quot;...];</span><br></pre></td></tr></table></figure>
<p>数组要注意的细节： 在javascript中数组的<strong>长度是可以发生变化的</strong>。</p>
<h3 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h3><table>
<thead>
<tr>
<th></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td>concat()</td>
<td style="text-align:left">把arr1与arr2的数组元素组成一个新的数组返回。</td>
</tr>
<tr>
<td>join</td>
<td style="text-align:left">使用指定的分隔符把数组中的元素拼装成一个字符串返回。</td>
</tr>
<tr>
<td>pop</td>
<td style="text-align:left">移除数组中的最后一个元素并返回该元素。(Array实际上是一个栈？)</td>
</tr>
<tr>
<td>push()</td>
<td style="text-align:left">将新元素添加到一个数组中，并返回数组的新长度值。</td>
</tr>
<tr>
<td>reverse()</td>
<td style="text-align:left">翻转数组的元素</td>
</tr>
<tr>
<td>shift()</td>
<td style="text-align:left">移除数组中第一个元素，并且返回。</td>
</tr>
<tr>
<td>slice(1,2)</td>
<td style="text-align:left">指定数组 的开始索引值与结束索引值截取数组的元素，并且返回子数组。</td>
</tr>
<tr>
<td>sort(sortNumber)</td>
<td style="text-align:left">排序，排序的时候<strong><em>一定要传入排序的方法。</em></strong></td>
</tr>
<tr>
<td>splice()</td>
<td style="text-align:left">第一个参数是开始删除元素的索引值，第二参数是删除元素的个数，往后的数据就是插入的元素。</td>
</tr>
</tbody>
</table>
<h3 id="使用Demo-2"><a href="#使用Demo-2" class="headerlink" title="使用Demo"></a>使用Demo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">"Wete"</span>,<span class="string">"Javck"</span>,<span class="string">"Leo"</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">"happy"</span>,<span class="string">"hello"</span>];</span><br><span class="line"></span><br><span class="line">arr1 = arr1.concat(arr2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> arr1) &#123;</span><br><span class="line">	<span class="built_in">document</span>.write(arr1[index] + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elements = arr1.join(<span class="string">"$"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(elements+ <span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"删除最后的一个元素并返回："</span>+arr1.pop()+<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">arr1.push(<span class="string">"New!"</span>); <span class="comment">// 将新元素添加到一个数组中，并返回数组的新长度值。</span></span><br><span class="line">arr1.reverse(); <span class="comment">//翻转数组的元素</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"删除第一个元素并返回："</span>+arr1.shift()+<span class="string">"&lt;br/&gt;"</span>); <span class="comment">//移除数组中第一个元素，并且返回。</span></span><br><span class="line"></span><br><span class="line">arr3 = [<span class="number">19</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">5</span>];</span><br><span class="line">arr3.sort(sortNumber);  <span class="comment">//排序，排序的时候一定要传入排序的方法。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumber</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1-num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> arr3)&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(arr3[index]+<span class="string">","</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr1.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"TOM"</span>,<span class="string">"Kityy"</span>,<span class="string">"Gaga"</span>); <span class="comment">//第一个参数是开始删除元素的 索引值， 第二参数是删除元素的个数，往后的数据就是插入的元素。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> arr1)&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(arr1[index]+<span class="string">","</span>);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象:"></a>自定义对象:</h2><p>在javascript没有类的概念，只要有函数即可创建对象。</p>
<p>自定义对象:<br>方式1： 使用无参的函数创建对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); <span class="comment">//创建了一个Person对象了</span></span><br><span class="line">p.id = <span class="number">110</span>;<span class="comment">//对象中增加一个域</span></span><br><span class="line">p.name = <span class="string">"Wente"</span>;</span><br><span class="line">p.say = <span class="keyword">new</span> founction () &#123;<span class="comment">//向对象中增加一个方法</span></span><br><span class="line">	alert(<span class="string">"name of the person is :"</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式2：使用带参的函数创建对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">id,name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.id = id;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(name+<span class="string">"呵呵"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="number">110</span>,<span class="string">"Wente"</span>);	<span class="comment">//创建对象</span></span><br></pre></td></tr></table></figure>
<p>方式3： 使用Object函数创建对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>();</span><br><span class="line">p.id = <span class="number">110</span>;</span><br><span class="line">p.name = <span class="string">"Wente"</span>；</span><br></pre></td></tr></table></figure>
<p>方式4：使用字面量的方式创建.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">	id:<span class="number">110</span>,</span><br><span class="line">	name:<span class="string">"狗娃"</span>,</span><br><span class="line">	say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name+<span class="string">"呵呵"</span>);	</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Prototype原型属性"><a href="#Prototype原型属性" class="headerlink" title="Prototype原型属性"></a>Prototype原型属性</h2><p>需求：想把getMax与searchEle方法添加 到数组对象中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">functoin Array()&#123;</span><br><span class="line">	this.prototype = new Object();	</span><br><span class="line">	this.getMax = function()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Prototype注意的细节：</p>
<ol>
<li><p>prototype是函数(function)的一个必备属性(书面一点的说法是”保留属性”)(只要是function,就一定有一个prototype属性)</p>
</li>
<li><p>prototype的值是一个对象</p>
</li>
<li><p>可以任意修改函数的prototype属性的值。</p>
</li>
<li><p>一个对象会自动拥有prototype的所有成员属性和方法。</p>
</li>
</ol>
<h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><p>注意，在网页抓取的数字都是字符串，数字也是的…… 所以匹配时一定要注意；</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Java </tag>
            
            <tag> JavaWeb </tag>
            
            <tag> Javascript </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Algorithms-笔记-算法分析基础]]></title>
      <url>/2015/11/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要：介绍了一如何进行算法分析，介绍了一下科学方法的原则；数量级的概念；数学模型的步骤；近似的概念；倍率实验（待研究）；对输入依赖的处理；内存占用的分析。<br><a id="more"></a><br>Knuth 证明了原则上我们只要<strong>正确并完整</strong>的使用了下面写的一方法就能够对程度作出详细，准备的预测。</p>
<p>一个程序的运行的总时间和两点有关：</p>
<ul>
<li><p>执行每条语句的耗时；——取决于编译器和操作系统</p>
</li>
<li><p>执行每条语句的频率； —— 取决于程序本身和输入；</p>
</li>
</ul>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="科学方法的原则："><a href="#科学方法的原则：" class="headerlink" title="科学方法的原则："></a>科学方法的原则：</h3><p>我们所设计的实验（分析算法的）必须是<strong>可重现的</strong>；<br>我们所以的假设也必须是<strong>可证伪的</strong>；</p>
<h2 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h2><h2 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h2><h3 id="建立的步骤"><a href="#建立的步骤" class="headerlink" title="建立的步骤"></a>建立的步骤</h3><ol>
<li><p>确成<strong>输入模型</strong></p>
</li>
<li><p>识别<strong>内循环</strong><br> 内循环：执行最频繁的指令；内循环决定了程序 执行的总时间，</p>
</li>
<li><p>根据内循环中的操作确定<strong>成本模型</strong>；</p>
</li>
</ol>
<h3 id="近似的概念"><a href="#近似的概念" class="headerlink" title="近似的概念"></a>近似的概念</h3><p>计算数量级的时候以最记数量级为准，忽略低数量级的。</p>
<h2 id="增长级数"><a href="#增长级数" class="headerlink" title="增长级数"></a>增长级数</h2><p>有的书叫算法的时<strong>间复杂度</strong><br>详细的算法分析可能会用所有的人类发明的数学工具，这是专家的事儿，我们只要掌握几种常用的就好：</p>
<h3 id="常数级别"><a href="#常数级别" class="headerlink" title="常数级别"></a>常数级别</h3><p>普通语句 如 a = b + c;</p>
<h3 id="对数级别"><a href="#对数级别" class="headerlink" title="对数级别"></a>对数级别</h3><p><code>logN</code> 二分策略 如： 二分查找<br>数学上：对娄的底数和增长的数量级无关，所以我们在说明对数级别时一般使用logN.</p>
<h3 id="线性级别"><a href="#线性级别" class="headerlink" title="线性级别"></a>线性级别</h3><p><code>N</code> 一重循环 如：<code>for (int i = 0; i &lt; N ; i++) { 。。。。。。。}</code></p>
<h3 id="线性对数级别"><a href="#线性对数级别" class="headerlink" title="线性对数级别"></a>线性对数级别</h3><p>NlogN 分治 如：归并排序</p>
<h3 id="平方级别"><a href="#平方级别" class="headerlink" title="平方级别"></a>平方级别</h3><p>N<sup>2</sup> 双层循环</p>
<h3 id="立方级别"><a href="#立方级别" class="headerlink" title="立方级别"></a>立方级别</h3><p>N<sup>3</sup> 三层循环</p>
<h3 id="指数级别"><a href="#指数级别" class="headerlink" title="指数级别"></a>指数级别</h3><p>2<sup>N</sup>  穷举查找<br>指数级别的算法<strong>非常慢</strong>——不能用它们解决大规模的问题；</p>
<h2 id="倍率实验"><a href="#倍率实验" class="headerlink" title="倍率实验"></a>倍率实验</h2><p>倍率实验是一种估计运行时间的增长数量级的简单方法；<br>在有性能压力的情况下应该考虑对编写过的所有程序进行倍率实验。<br>他可以用来：</p>
<ul>
<li><p>评估程序解决大型问题的可能性</p>
</li>
<li><p>评估使用更快的计算机所产生的价值<br>  一般来说：新的计算机比老的快X倍，那运行时间就是原来的1/x。但是这个对平方或立方级别的算法不适用，</p>
</li>
</ul>
<h2 id="算法分析中注意的事项"><a href="#算法分析中注意的事项" class="headerlink" title="算法分析中注意的事项"></a>算法分析中注意的事项</h2><h3 id="大常数"><a href="#大常数" class="headerlink" title="大常数"></a>大常数</h3><p>要对大常数保持敏感：一般情况下2N<sup>2</sup>+cN ~ 2N<sup>2</sup> 但是当C很大，比如是10<sub>3</sub>就不一样了</p>
<h3 id="非决定性的内循环"><a href="#非决定性的内循环" class="headerlink" title="非决定性的内循环"></a>非决定性的内循环</h3><h3 id="指令时间"><a href="#指令时间" class="headerlink" title="指令时间"></a>指令时间</h3><p>指令时间不一定总是相同的。</p>
<h3 id="系统因素"><a href="#系统因素" class="headerlink" title="系统因素"></a>系统因素</h3><p>（略）</p>
<h3 id="不分伯仲"><a href="#不分伯仲" class="headerlink" title="不分伯仲"></a>不分伯仲</h3><p>（略）</p>
<h3 id="对输入的强烈依赖"><a href="#对输入的强烈依赖" class="headerlink" title="对输入的强烈依赖"></a>对输入的强烈依赖</h3><p>有的程序不一样的输入，可能是不同的数量级</p>
<h3 id="多个问题参量"><a href="#多个问题参量" class="headerlink" title="多个问题参量"></a>多个问题参量</h3><p>（略）</p>
<h2 id="输入依赖的处理"><a href="#输入依赖的处理" class="headerlink" title="输入依赖的处理"></a>输入依赖的处理</h2><h3 id="建立输入模型"><a href="#建立输入模型" class="headerlink" title="建立输入模型"></a>建立输入模型</h3><p>有时建立一个输入的模型是很困难的。</p>
<h3 id="考虑对最坏的那估计看下的性能的保证"><a href="#考虑对最坏的那估计看下的性能的保证" class="headerlink" title="考虑对最坏的那估计看下的性能的保证"></a>考虑对最坏的那估计看下的性能的保证</h3><p>略</p>
<h3 id="随机化算法"><a href="#随机化算法" class="headerlink" title="随机化算法"></a>随机化算法</h3><p>为保证性能，我们在输入中要引入随机性。<br>比如常见的快带排序算法，在最坏的情况下性能可能是平方级的，但通过随机打乱输入，能够保证它的性能是线性对数的。</p>
<h3 id="操作序列的考虑"><a href="#操作序列的考虑" class="headerlink" title="操作序列的考虑"></a>操作序列的考虑</h3><p>不的操作（输入顺序 ）一个算法的性能可能是不同的。</p>
<h3 id="均摊分析的思想-待研究"><a href="#均摊分析的思想-待研究" class="headerlink" title="均摊分析的思想(待研究)"></a>均摊分析的思想(待研究)</h3><p>使我们可以允许执行一些昂贵的操作，但保持所有的操作的平均成本较低。这种模式我们还是可以接受的。</p>
<h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><p>比算法分析简单多了，总的内存占用 = 变量的数量 * 他们的对应占的字节数。</p>
<h3 id="原始数据的占用量："><a href="#原始数据的占用量：" class="headerlink" title="原始数据的占用量："></a>原始数据的占用量：</h3><p>一个字节 = 8位<br>int、float = 4个字节<br>double/long = 8个字节<br>char = 2个字节<br>boolean/byte  = 1个字节</p>
<h3 id="对象的占用量："><a href="#对象的占用量：" class="headerlink" title="对象的占用量："></a>对象的占用量：</h3><p>对象的占用量 =<code>对象开销（16byte）+ 域（int(4B)/String等的引用（8B））+  填充字节（4B） + 他引用的所有对象的占用</code></p>
<h3 id="内部类对象-如链表-的占用量"><a href="#内部类对象-如链表-的占用量" class="headerlink" title="内部类对象(如链表)的占用量"></a>内部类对象(如链表)的占用量</h3><p>内部类对象(如链表)的占用量= <code>对象开销（16byte）+ 额外开销（8B）+ 域（int(4B)/String等的引用（8B））+   他引用的所有对象的占用</code><br>额外开销（8B）是一个指向外部类的引用；</p>
<h3 id="数组的占用量："><a href="#数组的占用量：" class="headerlink" title="数组的占用量："></a>数组的占用量：</h3><p>数组的占用量： = <code>24B的头信息（=对象开销（16B）+ 长度信息（4B）+  填充字节（4B)） +  域（int(4B)/String等的引用（8B）+ 他引用的所有对象的占用</code></p>
<h3 id="字符串对象的占用量："><a href="#字符串对象的占用量：" class="headerlink" title="字符串对象的占用量："></a>字符串对象的占用量：</h3><p>Java中一个字符串对象中包含的字符串的值是一个引用，而不一个真正的字符串的拷贝，java中是多个字符串共用一个字符数组的。<br>同理，字符串的子串和字符串不但共用一个字符数组。对象中包含的字符串的引用也是一样的，就是偏移量不同而已。<br>字符串对象的占用量 =<code>对象开销（16byte）+ 指向字符数组的引用（8B） + 偏移量(4B） +度信息（4B）+ Hash值(4B） +  填充字节（4B） + 他引用的字符数组对象的占用</code></p>
<p><strong>扩展：</strong><br>在递归中创建数组或其他的对象是很危险的，——这意味着每一次递归调用都会使用大量的内存。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><blockquote>
<p>任何一个程序员都应该有能力预测他们编写的程序是会运行一秒还是一年。</p>
</blockquote>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 算法分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Algorithms-笔记-基础数据结构类型]]></title>
      <url>/2015/11/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>主要介绍三种基本数据类型： 背包，队列，栈。<a id="more"></a></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>优点：以通过索引可以访问元素，<br>缺点：在初始化的时候要知道元素的数量。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>它是一种递归的数据结构：它或者为null.或者是指向node的引用。 node含有一个泛型元素，和一个指向另一条链表的</p>
<p><strong>优点</strong>：使用的空间大小和元素数量成正比：<br><strong>缺点</strong> ：要通过引用访问任意元素；</p>
<p>当我们用链表实现一个栈的<strong>优点</strong>：<br>可以处理任意类型的数据；<br>使用的空间大小和元素数量成正比：<br>操作的时间和集合的大小无关；</p>
<h3 id="构造node"><a href="#构造node" class="headerlink" title="构造node"></a>构造node</h3><p>利用嵌套类来实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	Item item;</span><br><span class="line">	Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除和插入的实现"><a href="#删除和插入的实现" class="headerlink" title="删除和插入的实现"></a>删除和插入的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node first;<span class="comment">// 栈顶</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何在List的头部添加元素。</span></span><br><span class="line">Node oldfirst = first;</span><br><span class="line">first = <span class="keyword">new</span> Node();</span><br><span class="line">first.item = “新的元素”;</span><br><span class="line">first.next = oldfirst;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何在List的头部删除元素，好简洁啊！！</span></span><br><span class="line">first = first.next;<span class="comment">// 如此的简单！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何在List的尾部部添加元素。</span></span><br><span class="line">Node oldlist = last;</span><br><span class="line">last = <span class="keyword">new</span> Node();</span><br><span class="line">last.item = “新的元素”;</span><br><span class="line">oldfirst.next = last; <span class="comment">//这是于在表头添加的不同。</span></span><br></pre></td></tr></table></figure>
<h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><p>不支持从中删除元素的数据类型<br>背包中元素的处理是<strong>无序的</strong>；<br>他可以用来保存大量的数据；——使用范围；</p>
<h2 id="先进先出队列"><a href="#先进先出队列" class="headerlink" title="先进先出队列"></a>先进先出队列</h2><p>先进先出队列是一种基于先进先出（FIFO）的策略。<br>使用队列的原因：保存元素的同进保存它们的相对顺序；</p>
<h2 id="下压栈"><a href="#下压栈" class="headerlink" title="下压栈"></a>下压栈</h2><p>一种基于后进先出（lIFO）的集合类型。可以用来保存元素的同时<strong>颠倒</strong>他们的相对顺序。<br>主要性能特点是：push 和 pop 操作所要的时间独立于栈的长度。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>一个集合数据 类型必须实现一个<code>iterator（）</code> 方法，并返回一个Iterator对象。</p>
<p>Iterator类必须包含两个方法：<code>hasnext()</code> <code>next()</code>。</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb-Javascript基础笔记]]></title>
      <url>/2015/11/coding/Java-Web-%E7%AC%94%E8%AE%B0-Javascript%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>javascript就是处理网址和用户的互交；和java没有任何关系.<br>本文主要有：js简介；Js的变量声明和几种数据类型的介绍；字符串如何转数字；基本的运算符还有循环、判断、遍历，with(js特有的)；<br><a id="more"></a></p>
<h2 id="javascript的特点"><a href="#javascript的特点" class="headerlink" title="javascript的特点"></a>javascript的特点</h2><ul>
<li><p>跨平台</p>
</li>
<li><p>安全性。 （javascript的代码不能直接访问硬盘的内容）</p>
</li>
</ul>
<h2 id="javascript与java之间区别"><a href="#javascript与java之间区别" class="headerlink" title="javascript与java之间区别"></a>javascript与java之间区别</h2><ol>
<li><p>javascript是属于网景公司产品， java是sun公司的产品。</p>
</li>
<li><p>javascript是基于对象的语言，java是面向对象的语言。</p>
</li>
<li><p>javascript是解释型语言，java是解释、编译型语言。</p>
</li>
<li><p>javascript是弱类型语言， java 是强类型语言。<br>java中声明变量 的时候<strong>必须</strong>要明确该变量的数据类型。<br>javascript声明变量不需要明确是何种数据类型， 任何的变量都是使用一个关键字<code>var</code>去声明即可。</p>
</li>
</ol>
<h2 id="如何编写javascript的代码。"><a href="#如何编写javascript的代码。" class="headerlink" title="如何编写javascript的代码。"></a>如何编写javascript的代码。</h2><h3 id="方式1：可以使用script标签体内进行编写"><a href="#方式1：可以使用script标签体内进行编写" class="headerlink" title="方式1：可以使用script标签体内进行编写"></a>方式1：可以使用<code>script</code>标签体内进行编写</h3><p>格式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">     js代码;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="方式2：引入外部的javascript文件。"><a href="#方式2：引入外部的javascript文件。" class="headerlink" title="方式2：引入外部的javascript文件。"></a>方式2：引入外部的javascript文件。</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li><p><code>script</code>是有开始标签与结束标签的，千万不要在一个标签中结束了。<strong>(易错点)</strong></p>
</li>
<li><p>如果<code>script</code>已经用于引入了js文件，那么该<code>script</code>标签体就<strong>不能再写js代码了</strong>，无效，不报错。</p>
</li>
</ol>
<h3 id="javascript常用的函数："><a href="#javascript常用的函数：" class="headerlink" title="javascript常用的函数："></a>javascript常用的函数：</h3><p><code>alert(&quot;显示的内容..&quot;) ;</code> 弹出框<br><code>document.write(&quot;数据&quot;) ;</code>//向页面输出数据…</p>
<h2 id="总结几种页面的注释的区别："><a href="#总结几种页面的注释的区别：" class="headerlink" title="总结几种页面的注释的区别："></a>总结几种页面的注释的区别：</h2><ul>
<li><p>html <code>&lt;!--</code> 注释的内容</p>
</li>
<li><p>css的注释  <code>/* 注释的内容*/</code></p>
</li>
<li><p>javascript： <code>//注释的内容  单行注释          /* 注释的内容*/ 多行注释</code>(和java很像嘛)</p>
</li>
</ul>
<h2 id="JS的变量的声明："><a href="#JS的变量的声明：" class="headerlink" title="JS的变量的声明："></a>JS的变量的声明：</h2><p>格式：<code>var 变量名 = 数据;</code> </p>
<h3 id="声明变量要注意的事项："><a href="#声明变量要注意的事项：" class="headerlink" title="声明变量要注意的事项："></a>声明变量要注意的事项：</h3><ol>
<li><p>在javascript中声明变量是 使用var关键字声明的，javascript中的变量可以存储任意的数据类型数据.</p>
</li>
<li><p>javascript中变量数据类型是根据存储的值决定的，可以随时更改存储数据的类型。</p>
</li>
<li><p>定义了多个同名的变量是，后定义的同名变量是覆盖前面定义的同名变量。</p>
</li>
<li><p>声明变量的时候可以省略var关键字，但是不建议省略。</p>
</li>
</ol>
<h3 id="javascript的数据类型："><a href="#javascript的数据类型：" class="headerlink" title="javascript的数据类型："></a>javascript的数据类型：</h3><ul>
<li><p><code>number</code> 小数与整数(js中不分int double long 什么的)</p>
</li>
<li><p><code>string</code> 字符串 注意： javascript中没有字符的概念，只有字符串，字符串可以写在单引号或双引号中。</p>
</li>
<li><p><code>boolean</code> 布尔数据类型，</p>
</li>
<li><p><code>undefined</code>  undefined代表该变量没有定义。</p>
</li>
</ul>
<p><code>typeof</code>查看变量的数据类型。使用格式：<code>typeof 变量名</code></p>
<h2 id="字符串转数字"><a href="#字符串转数字" class="headerlink" title="字符串转数字"></a>字符串转数字</h2><p><code>parseInt()</code>  可以把一个字符串转换成整数。<br><code>parseFloat()</code> 可以把一个字符串转换成小数。<br><code>IsNaN</code>方法让我们判断该字符串是否是 一个数字。不是一个数字返回<code>true</code>，是一个数字返回<code>false</code> <strong>易错：易记反</strong></p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="string">"12"</span>;</span><br><span class="line">b = <span class="string">"123asd456"</span>;<span class="comment">/* 结果是124----parseInt方法如果接收的字符串含有非数字的字符，那么parseInt方法会从字符串的首个字符开始寻找，一直找到非数字字符为止，然后就使用前面的数字字符转换成数字， */</span></span><br><span class="line">b = <span class="string">"a111 "</span>;  <span class="comment">// 结果是NaN ----not a number(不是一个数字)</span></span><br><span class="line">b = <span class="string">"00125"</span>; <span class="comment">/* 结果是126---如果首位是0，那么就想祛除0再进行转换。*/</span></span><br><span class="line">b = <span class="string">"0x18"</span>; <span class="comment">/* 结果是25----如果一个字符串是以0x开头，那么会把字符串中的内容当成十六进行的数据处理的。 */</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">parseInt</span>(b);</span><br><span class="line"><span class="built_in">document</span>.write (<span class="string">"parseInt结果 ："</span> + (c + <span class="number">1</span>) + <span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="string">"3.14"</span>;</span><br><span class="line">d = <span class="string">"10"</span>;  <span class="comment">// 如果是一个字符串是整数的，那么使用parseFloat还是转换 成整数 。</span></span><br><span class="line">d = <span class="string">"100a"</span>; <span class="comment">//同上</span></span><br><span class="line">d = <span class="string">"abc123"</span>;<span class="comment">// 结果是NaN</span></span><br><span class="line"><span class="keyword">var</span> h = <span class="built_in">parseFloat</span>(d);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"parseFloat结果 ："</span> + h );</span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="（加法-正数-连接符）"><a href="#（加法-正数-连接符）" class="headerlink" title="+（加法 正数 连接符）"></a>+（加法 正数 连接符）</h3><p>在Js中，Booblea类型可以当做数字运算（Java不可以！！）；运算时：true 是1. false是0</p>
<h3 id="除法："><a href="#除法：" class="headerlink" title="除法："></a>除法：</h3><p>如果两个整数相除不能整数的时候结果还是小数。</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>在javascript中字符串是可以比较的（Java不可以）</p>
<ul>
<li><p><strong>字符串与字符串</strong>的比较规则是：<br>  情况1： 能找到对应位置上的不同字符，那么就比较第一个不同字符的大小。<br>  情况2： 不能找到对应位置上的不同字符，这时候比较的是两个字符串的<strong>长度</strong>。</p>
</li>
<li><p><strong>字符串与数字</strong>进行比 ：进行比较，会先把字符串转换成数字再进行比较 的。<strong>易错</strong></p>
</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>运算符是 JavaScript 中功能最多的运算符，它的形式与 Java 中的相同。<br><code>variable = boolean_expression ? true_value : false_value;</code></p>
<h2 id="控制流程语句"><a href="#控制流程语句" class="headerlink" title="控制流程语句"></a>控制流程语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(判断条件)&#123;</span><br><span class="line">			符合条件执行的代码	</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>Javascript中if语句的特殊之处：<br>在javascript中的if语句条件不单止可以写布尔表达式，还可以写任何的数据。<br><code>number</code>  非0为true, 0为false.<br><code>string</code> 内容不能空是true， 内容空的时候是false。<br><code>undefined</code>：false<br><code>NaN</code>:    false</p>
<h3 id="选择语句：switch语句"><a href="#选择语句：switch语句" class="headerlink" title="选择语句：switch语句"></a>选择语句：switch语句</h3><p>特殊之处：在javascript中case后面可以跟<code>常量</code>与<code>变量</code>还可以跟<code>表达式</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量)&#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">2</span>：</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	.....</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>：</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(判断的条件)&#123; </span><br><span class="line">	循环体内</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句; 判断的条件 ; 循环后的语句) &#123;</span><br><span class="line">	循环体语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-in语句（Js中特有的）"><a href="#for-in语句（Js中特有的）" class="headerlink" title="for-in语句（Js中特有的）"></a>for-in语句（Js中特有的）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>（<span class="keyword">var</span> 变量名 <span class="keyword">in</span> 遍历的目标） &#123;</span><br><span class="line"></span><br><span class="line">	......sth.</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for-in语句的作用：</p>
<ol>
<li><p>可以用于遍历数组的元素。  注意： 使用for-in语句遍历数组元素的时候遍历出来是数组的下标。<strong>易错点</strong></p>
</li>
<li><p>可以用于遍历对象的所有属性数据。 注意： 使用for-in语句遍历对象的属性的时候，遍历出来的是对象的属性名。不是属性值 <strong>易错点</strong></p>
</li>
</ol>
<h3 id="遍历数组元素-与别的不同）"><a href="#遍历数组元素-与别的不同）" class="headerlink" title="遍历数组元素(与别的不同）"></a>遍历数组元素(与别的不同）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">12</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">14</span> , <span class="number">1234</span>, <span class="number">15</span>];</span><br><span class="line"><span class="comment">//使用for in 循环</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> ass <span class="keyword">in</span> array) &#123;</span><br><span class="line">	<span class="built_in">document</span>.write (array[ass] + <span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用普通for循环</span></span><br><span class="line"><span class="keyword">for</span>（<span class="keyword">var</span> ass = <span class="number">0</span>; ass &lt;= array.length; ass ++） &#123;</span><br><span class="line">	<span class="built_in">document</span>.write (array[ass] + <span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="with语句-（Js中特有的）"><a href="#with语句-（Js中特有的）" class="headerlink" title="with语句 （Js中特有的）"></a>with语句 （Js中特有的）</h3><p>With 语句可以让存取对象属性和调用方法时就不用重复指定对象。<br>格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (<span class="built_in">document</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">1</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">			write(<span class="string">"*&amp;nbsp;"</span>);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		write(<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	write(<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><p>在Js中，Booblea类型可以当做数字运算（Java不可以！！）；运算时：true 是1. false是0</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Java </tag>
            
            <tag> JavaWeb </tag>
            
            <tag> Javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb-CSS基础笔记]]></title>
      <url>/2015/11/coding/Java-Web-%E7%AC%94%E8%AE%B0-CSS%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要”JavaWeb-CSS基础笔记”</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>html</strong> 在一个网页中负责的事情是一个页面的结构<br><strong>css(层叠样式表)</strong> 在一个网页中主要负责了页面的数据样式。<a id="more"></a></p>
<h2 id="html中引入css代码的方式："><a href="#html中引入css代码的方式：" class="headerlink" title="html中引入css代码的方式："></a>html中引入css代码的方式：</h2><h3 id="在style标签中编写css代码。"><a href="#在style标签中编写css代码。" class="headerlink" title="在style标签中编写css代码。"></a>在style标签中编写css代码。</h3><p>便是只能用于本页面中，复用性不强。<br>格式 ：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text\css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">	编写css的代码;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text\css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    a&#123;</span></span><br><span class="line"><span class="undefined">        color:#F00;</span></span><br><span class="line"><span class="undefined">        ext-decoration:none;</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="可以引入外部的css文件。"><a href="#可以引入外部的css文件。" class="headerlink" title="可以引入外部的css文件。"></a>可以引入外部的css文件。</h3><p>推荐使用。</p>
<p>方式1：使用link标签。   推荐使用…<br>格式： <code>&lt;link href=&quot;css文件的路径&quot; rel=&quot;stylesheet&quot;&gt;</code><br>例子: <code>&lt;link href=&quot;1.css&quot; rel=&quot;stylesheet&quot;/&gt;</code></p>
<p>方式2：使用<code>&lt;style&gt;</code>引入<br>格式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span> &gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    @import url("css的路径");</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span> &gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">	@import url("1.css");</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="直接在html标签使用style属性编写。"><a href="#直接在html标签使用style属性编写。" class="headerlink" title="直接在html标签使用style属性编写。"></a>直接在html标签使用style属性编写。</h3><p>只能用于本标签中，复用性较差。 不推荐使用。<br>例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">"color:#0F0; text-decoration:none"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>新闻的标题1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="link和-import引入外部样式的区别"><a href="#link和-import引入外部样式的区别" class="headerlink" title="link和@import引入外部样式的区别"></a>link和@import引入外部样式的区别</h2><h3 id="隶属上的差别"><a href="#隶属上的差别" class="headerlink" title="隶属上的差别"></a>隶属上的差别</h3><p><code>link</code>属于HTML标签，而<code>@import</code>完全是CSS提供的一种方式。</p>
<h3 id="import次数限制"><a href="#import次数限制" class="headerlink" title="@import次数限制"></a>@import次数限制</h3><p><code>@import</code>只能引入31次css文件。</p>
<h3 id="加载顺序的不同"><a href="#加载顺序的不同" class="headerlink" title="加载顺序的不同"></a>加载顺序的不同</h3><p>当页面被加载的时候，link引用的CSS会同时被加载，而<code>@import</code>引用的CSS 会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式，然后突然样式会出现，网速慢的时候还挺明显。</p>
<h3 id="兼容性上的差别"><a href="#兼容性上的差别" class="headerlink" title="兼容性上的差别"></a>兼容性上的差别</h3><p>由于@import是CSS2.1提出的，<code>@import</code>只有在IE5以上的才能识别，而link标签无此问题</p>
<h3 id="使用DOM控制样式时的差别"><a href="#使用DOM控制样式时的差别" class="headerlink" title="使用DOM控制样式时的差别"></a>使用DOM控制样式时的差别</h3><p>当使用javascript控制DOM(document.styleSheets)去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>选择器作用就是找到对应的数据进行样式化。</p>
<h3 id="标签选择器："><a href="#标签选择器：" class="headerlink" title="标签选择器："></a>标签选择器：</h3><p>就是找到所有指定的标签进行样式化。<br>格式：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标签名&#123;</span><br><span class="line">	样式1；样式2....	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">	color:#F00;</span><br><span class="line">	font-size:24px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器:"></a>类选择器:</h3><p>使用类选择器首先要给html标签指定对应的class属性值。Demo:<code>&lt;a class = &quot;two&quot; href = &quot;#&quot;&gt; new head1 &lt;/a&gt;</code><br>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class的属性值&#123;</span><br><span class="line">	样式1；样式2...	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">.two&#123;</span></span><br><span class="line"><span class="undefined">	background-color:#0F0;</span></span><br><span class="line"><span class="undefined">	color:#F00;</span></span><br><span class="line"><span class="undefined">	font-size:24px; /*字体大小*/</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="类选择器要注意的事项"><a href="#类选择器要注意的事项" class="headerlink" title="类选择器要注意的事项:"></a>类选择器要注意的事项:</h3><ol>
<li><p>html元素的class属性值一定<strong>不能以数字开头</strong>.</p>
</li>
<li><p>类选择器的样式是要优先于标签选择器的样式。（<strong>易错点</strong>）</p>
</li>
</ol>
<h3 id="ID选择器："><a href="#ID选择器：" class="headerlink" title="ID选择器："></a>ID选择器：</h3><p>使用ID选择器首先要给html元素添加一个id的属性值。<br>id属性值设置Demo <code>&lt;div id=&quot;one&quot; class=&quot;two&quot;&gt;这是用来测试ID属性的&lt;/div&gt;</code><br>ID选择器的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#id属性值&#123;</span><br><span class="line">	样式1；样式2...	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="id选择器要注意的事项："><a href="#id选择器要注意的事项：" class="headerlink" title="id选择器要注意的事项："></a>id选择器要注意的事项：</h3><ol>
<li><p>ID选择器的样式优先级是最高的，优先于类选择器与标签选择器。</p>
</li>
<li><p>ID的属性值也是不能以数字开头的。</p>
</li>
<li><p>ID的属性值在一个html页面中<strong>只能出现一次</strong>。</p>
</li>
</ol>
<h3 id="交集选择器："><a href="#交集选择器：" class="headerlink" title="交集选择器："></a>交集选择器：</h3><p>就是对选择器1中的选择器2里面的数据进行样式化。 <strong>注意：</strong>分隔符号用的是<code>空格</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器1 选择器2&#123;</span><br><span class="line">	样式1，样式2....	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">	.two span&#123;</span></span><br><span class="line"><span class="undefined">		background-color:#999;</span></span><br><span class="line"><span class="undefined">		ont-size:24px;</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="并集选择器："><a href="#并集选择器：" class="headerlink" title="并集选择器："></a>并集选择器：</h3><p>对指定的选择器进行统一的样式化。 注意: w分隔符号用的是<code>，</code> 与交集不同。·<br>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器1,选择器2..&#123;</span><br><span class="line">	样式1；样式2...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Demo</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">	span,a&#123;</span></span><br><span class="line"><span class="undefined">		border-style:solid;</span></span><br><span class="line"><span class="undefined">		border-color:#F00;</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="通过选择器"><a href="#通过选择器" class="headerlink" title="通过选择器:"></a>通过选择器:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">	样式1；样式2...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="伪类选择器："><a href="#伪类选择器：" class="headerlink" title="伪类选择器："></a>伪类选择器：</h3><p>伪类选择器就是对元素处于某种状态下进行样式的。<br><strong><em>易错</em></strong>：中间不能有空格啊；<code>:link</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">	a:link&#123;color:#F00&#125; /* 没有被点击过---红色 */</span></span><br><span class="line"><span class="undefined">	a:visited&#123;color:#0F0&#125; /*  已经被访问过的样式---绿色 */ </span></span><br><span class="line"><span class="undefined">	a:hover&#123;color:#00F;&#125; /* 鼠标经过的状态---蓝 */</span></span><br><span class="line"><span class="undefined">	a:active&#123;color:#FF0;&#125; /*选定的链接，就是按下鼠标没有放手的时候*/</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li><p>a:hover <strong>必须</strong>被置于 a:link 和 a:visited 之后</p>
</li>
<li><p>a:active <strong>必须</strong>被置于 a:hover 之后</p>
</li>
</ol>
<h2 id="常用的CSS设置"><a href="#常用的CSS设置" class="headerlink" title="常用的CSS设置"></a>常用的CSS设置</h2><h3 id="操作背景的属性"><a href="#操作背景的属性" class="headerlink" title="操作背景的属性"></a>操作背景的属性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">	body &#123;</span></span><br><span class="line"><span class="undefined">		background-image:url(1.jpg);/*注意是括弧，没有引号的*/</span></span><br><span class="line"><span class="undefined">		background-repeat: no-repeat;/*  设置背图片是否要重复 */</span></span><br><span class="line"><span class="undefined">		background-position: 370px 100px;/* 设置背景图片的位置， 第一个参数是左上角的左边距， 第二个参数是左上角的上边距 */</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="操作文本的样式"><a href="#操作文本的样式" class="headerlink" title="操作文本的样式"></a>操作文本的样式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">	div &#123;</span></span><br><span class="line"><span class="undefined">		color: #F00;</span></span><br><span class="line"><span class="undefined">		line-height:40px; /*  设置行高 */</span></span><br><span class="line"><span class="undefined">		letter-spacing:15px; /*  设置字符间距 */</span></span><br><span class="line"><span class="undefined">		text-align:center; /*  设置对齐方式，我们选的是居中 */</span></span><br><span class="line"><span class="undefined">		text-decoration :none;/*  设置文本的修饰:</span></span><br><span class="line"><span class="undefined">			none 什么也不做 ；</span></span><br><span class="line"><span class="undefined">		 	underline 文本下划线 ;overline 文本上划线;</span></span><br><span class="line"><span class="undefined">		 	line-through 穿过文本的线;</span></span><br><span class="line"><span class="undefined">		  	blink 定义闪烁的文本（现在浏览器都不怎么支持啦）;</span></span><br><span class="line"><span class="undefined">		   	inherit  从父元素中继承属性（注意：IE不支持）;  */</span></span><br><span class="line"><span class="undefined">		text-transform :uppercase; /* 字符 的转义： </span></span><br><span class="line"><span class="undefined">			none 什么也不做 ；</span></span><br><span class="line"><span class="undefined">			caption 每个单词都是大写开头；</span></span><br><span class="line"><span class="undefined">			uppercase 仅有大写字母；</span></span><br><span class="line"><span class="undefined">			lowercase 公有小写字母；</span></span><br><span class="line"><span class="undefined">		 	inherit 从父元素中继承属性（注意：IE不支持）;*/</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="操作表格的属性"><a href="#操作表格的属性" class="headerlink" title="操作表格的属性"></a>操作表格的属性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">	table &#123;</span></span><br><span class="line"><span class="undefined">		border-collapse: collapse; /*合并单元格的边框和表格的边框*/</span></span><br><span class="line"><span class="undefined">		border-spacing:20px;  /* 设置单元格的边框与表格的边框距离， 注意：和前一个属性设置有冲突（合并了你还有什么距离啊）*/</span></span><br><span class="line"><span class="undefined">		empty-cells: show; /* 要不是显示空的单元格，默认是hold , 可设置为show 和 inherit */</span></span><br><span class="line"><span class="undefined">		table-layout:fixed; /*automatic 默认列宽由单元格内容决定; fixed 列宽由表格宽度和列宽设定决定 (就是固定死的); inherit*/</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="操作边框的属性"><a href="#操作边框的属性" class="headerlink" title="操作边框的属性"></a>操作边框的属性</h3><p>div默认是没有边框呃。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">	div &#123;</span></span><br><span class="line"><span class="undefined">		width:100px;</span></span><br><span class="line"><span class="undefined">		height: 100px;</span></span><br><span class="line"><span class="undefined">		border-style: dotted solid double;/* 设置边框的样式 可以设置多个 上 右 下 左   </span></span><br><span class="line"><span class="undefined">			none： 没有边框</span></span><br><span class="line"><span class="undefined">			hidden ：不显示，但有有</span></span><br><span class="line"><span class="undefined">			dotted点状边框，但看起来就是实线 ；</span></span><br><span class="line"><span class="undefined">			solid： 实线；</span></span><br><span class="line"><span class="undefined">			double ： 双线；</span></span><br><span class="line"><span class="undefined">			groove ：3D凹边框；</span></span><br><span class="line"><span class="undefined">			ridge ：3D凸边框；</span></span><br><span class="line"><span class="undefined">			inset ：outset  inherit */</span></span><br><span class="line"><span class="undefined">		border-color:#F00;</span></span><br><span class="line"><span class="undefined">		border-bottom-color:#0FF;/*  设下边框颜色*/</span></span><br><span class="line"><span class="undefined">		border-top-width:100px;/*  设上边框边框的宽度*/</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>盒子模型: 盒子模型就是把一个html边框比作成了一个盒子的边框，盒子模型要做用于操作数据与边框之间的距离或者 是边框与边框之间的距离。<br>主要是用于操作<strong>内边距(padding)</strong>与<strong>外边距（margin）</strong><br><code>padding</code> 内边距 内容到边框的距离<br><code>border</code> 边框的宽度<br><code>margin</code> 两个边框间的距离<br>注意：</p>
<ul>
<li><p>当两个相邻的盒子都设置了<code>margin</code> 后，他们间的距离不是两个数据的和，而是一个并集，就是取最大的那个的值；</p>
</li>
<li><p>内边距只能设置左和上的边距，设置下 右是没能的 ，(不知道什么原理);</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>盒子模型Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    div &#123;</span></span><br><span class="line"><span class="undefined">        border-style : solid;</span></span><br><span class="line"><span class="undefined">        width : 300px; /* 注意：这个设置的是内容的宽度 */</span></span><br><span class="line"><span class="undefined">        height : 100px;</span></span><br><span class="line"><span class="undefined">        border-width : 10px;</span></span><br><span class="line"><span class="undefined">        padding-left : 50px;</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="undefined">        padding-bottom : 10px;</span></span><br><span class="line"><span class="undefined">        padding-top: 50px;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .one &#123;</span></span><br><span class="line"><span class="undefined">        margin-bottom : 50px;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    .two &#123;</span></span><br><span class="line"><span class="undefined">        margin-top :100px ;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="CSS的定位"><a href="#CSS的定位" class="headerlink" title="CSS的定位"></a>CSS的定位</h2><h3 id="相对定位："><a href="#相对定位：" class="headerlink" title="相对定位："></a>相对定位：</h3><p>相对定位是相对于元素原本的位置进行移动的。<br>使用方式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.two</span>&#123;</span><br><span class="line">		<span class="attribute">background-color</span>:<span class="number">#0F0</span>;</span><br><span class="line">		<span class="attribute">position</span>:relative; <span class="comment">/* 相对定位,对于当前位置 */</span></span><br><span class="line">		<span class="attribute">top</span>:<span class="number">10px</span>;</span><br><span class="line">		<span class="attribute">left</span>:<span class="number">10px</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绝对定位："><a href="#绝对定位：" class="headerlink" title="绝对定位："></a>绝对定位：</h3><p>绝对定位是相对于整个页面而言。（相对于页面的左上角而言的）<br><code>position:absolute;</code><br>top:200px;<br>left:380px;<br>x</p>
<h3 id="固定定位："><a href="#固定定位：" class="headerlink" title="固定定位："></a>固定定位：</h3><p>固定定位是相对于整个浏览器而已的。<br><code>position:fixed;</code></p>
<h2 id="html和Css注释的区别"><a href="#html和Css注释的区别" class="headerlink" title="html和Css注释的区别"></a>html和Css注释的区别</h2><p>html的注释：<code>&lt;!-- html的注释 --&gt;</code><br>css <code>/* css的注释 ..*/</code></p>
<h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><p>自己写的 html文件产生中文乱码问题<br>文件顶部加上<code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</code>字体的声明</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JavaWeb </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb html基础知识笔记]]></title>
      <url>/2015/11/coding/Java-Web-%E7%AC%94%E8%AE%B0-Html%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="软件结构基础"><a href="#软件结构基础" class="headerlink" title="软件结构基础"></a>软件结构基础</h3><p><strong>C/S</strong> (Client  Server)结构的软件：<br>比如： QQ、 极品飞车、 飞信 、 迅雷<br>缺点：更新的时候需要用户下载更新包然后再安装，程序员则需要开发客户端与服务端。<br>优点： 减轻服务端的压力，而且可以大量保存数据在客户端。</p>
<p><strong>B/S</strong>（Browser Server）结构的软件：<br>比如： 微博 、 webQQ 、 web飞信、 web迅雷<br>优点：软件版本升级的时候不需要用户下载更新包，直接更新服务器的程序即可。程序员则只需要开发服务端而已。<br>缺点：增加了服务端的压力；软件不能保存大量的 数据在用户机上。<a id="more"></a></p>
<h3 id="网站的类别"><a href="#网站的类别" class="headerlink" title="网站的类别:"></a>网站的类别:</h3><ul>
<li><p><strong>静态网站</strong>: 静态网页中的数据都是写死的，如果需要修改网页的内容是需要直接修改网页的代码。 是没有数据库提供数据给它。</p>
</li>
<li><p><strong>动态网站</strong>: 动态网站的数据是来自于数据库的，背后是有一个后台程序管理页面中数据的。</p>
</li>
</ul>
<h2 id="html语言概念"><a href="#html语言概念" class="headerlink" title="html语言概念"></a>html语言概念</h2><p>就是开发网页的基础语言：超文本标记语言<br>html语言是由标签来构成的。<br>特点：</p>
<ol>
<li><p>html语言是与平台无关的，任何平台只需要安装了浏览器都可以运行。</p>
</li>
<li><p>html 是不区分大小写的。（Java是区分的）。</p>
</li>
</ol>
<h2 id="html结构："><a href="#html结构：" class="headerlink" title="html结构："></a>html结构：</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>   html语言的根标签.（可以不写，是可以自动添加的。）</span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span> 网页的头信息</span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span> 网页的体部分</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">html的注释：　<span class="comment">&lt;!--  注释的内容  --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="头信息及常用标签"><a href="#头信息及常用标签" class="headerlink" title="头信息及常用标签"></a>头信息及常用标签</h2><p>html的标签作用：用于描述一个网页的结构的。<br>如果需要操作数据的样式：通过标签的属性操作的。 </p>
<h3 id="html常用的标签："><a href="#html常用的标签：" class="headerlink" title="html常用的标签："></a>html常用的标签：</h3><table>
<thead>
<tr>
<th style="text-align:left">标签代码</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&lt;h1&gt;~&lt;h6&gt;</code></td>
<td style="text-align:left">表示是一个标题</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;p&gt;</code></td>
<td style="text-align:left">段落标签</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;hr/&gt;</code></td>
<td style="text-align:left">水平线标签</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;br/&gt;</code></td>
<td style="text-align:left">换行标签</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;sub&gt;</code></td>
<td style="text-align:left">下标</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;sup&gt;</code></td>
<td style="text-align:left">上标</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;pre&gt;</code></td>
<td style="text-align:left">原样标签： 原样标签会保留空格和换行符。（在别的块里面写的空格是没用的，会不见的）还有就是这个是不能保证居中和对齐的</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;ol&gt; &lt;li&gt;</code></td>
<td style="text-align:left">有序的列表标签</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;ul&gt; &lt;li&gt;</code></td>
<td style="text-align:left">无序的列表标签</td>
</tr>
<tr>
<td style="text-align:left"><code>dl dt dd</code></td>
<td style="text-align:left">项目列表标签</td>
</tr>
<tr>
<td style="text-align:left"><code>span</code></td>
<td style="text-align:left">行内标签</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;div&gt;</code></td>
<td style="text-align:left">块标签  div标签的内容会独立占一行。</td>
</tr>
</tbody>
</table>
<h3 id="标签的类型："><a href="#标签的类型：" class="headerlink" title="标签的类型："></a>标签的类型：</h3><ol>
<li><p>有开始标签与结束标签。  <code>&lt;p&gt; &lt;/p&gt;</code>需要把网页的数据内容封装到标签中。</p>
</li>
<li><p>开始标签与结束标签都是在一个标签体内的。  比如：<code>&lt;hr/&gt;</code>   功能单一不需要封装数据到标签中。</p>
</li>
</ol>
<h3 id="头信息及常用标签使用Demo"><a href="#头信息及常用标签使用Demo" class="headerlink" title="头信息及常用标签使用Demo"></a>头信息及常用标签使用Demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--头信息的作用：</span></span><br><span class="line"><span class="comment">        1. 可以设置网页的标题</span></span><br><span class="line"><span class="comment">        2. 可以通过浏览器使用指定的码表解释html页面；</span></span><br><span class="line"><span class="comment">        3. 设置见面的关键字（注意关键字最好不要超过三个，涉及到权重、seo 的概念）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span> 这是文涛手写的第一个网页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span> "<span class="attr">keywords</span>" <span class="attr">content</span>=<span class="string">"CS, 学习, 笔记 "</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--html常用的标签:DEmo--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span> 这是我的设置的一级标题并设置为居中<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段话，没有缩进的。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span>&amp;nbsp;&amp;nbsp;这是带两个空格，有缩进的，下面我要花一个水平线了      (注意，网页中我前面加的原始空格不见了)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">		上标和下标的使用： </span><br><span class="line">		水的分子式：H<span class="tag">&lt;<span class="name">sub</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>O</span><br><span class="line">		2的16次方：2<span class="tag">&lt;<span class="name">sup</span>&gt;</span>16<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">			 		你看我的空格还在</span><br><span class="line">			 我的换行符也在，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			 		我要开始作了，哈哈</span><br><span class="line">			 		注意对齐的问题。</span><br><span class="line">		<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		有序标签的使用：(无序我就不写了)</span><br><span class="line">		<span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>一个QQ太妃糖<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>一只猪<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>我也不知道自己在写什么……<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		组织结构的使用：</span><br><span class="line">		<span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">dt</span>&gt;</span>技术总监<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>码农1号<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>码农2号<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>码农3号<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>码农4号<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>人事总监<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>妹子1号<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>妹子2号<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">span</span>&gt;</span>span(行内）标签的使用，看起来没什么用的样子，字没有变化，<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span> div标签使用，其的内容会独立占一行，你看源码和网页中的不同……。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="实体标签"><a href="#实体标签" class="headerlink" title="实体标签"></a>实体标签</h2><p>为什么要学实体标签：<br>因为<code>&gt; &lt;</code>等一些符号在html页面中是有着特殊含义，这些字符如果需要在页面中显示，这时候就应该使用实体标签。<br>注意不要丢 了后面的<code>;</code></p>
<h3 id="常用的实体标签"><a href="#常用的实体标签" class="headerlink" title="常用的实体标签"></a>常用的实体标签</h3><p>空格      <code>&amp;nbsp;</code><br>小于号    <code>&amp;lt;</code><br>大于号    <code>&amp;gt;</code><br>人民币    <code>&amp;yen;</code><br>版权      <code>&amp;copy;</code><br>商标      <code>&amp;reg;</code></p>
<h2 id="媒体标签："><a href="#媒体标签：" class="headerlink" title="媒体标签："></a>媒体标签：</h2><p><code>&lt;embed&gt;&lt;/embed&gt;</code>音乐<br><code>hidden</code>： 设置隐藏插件是否隐藏。<br><code>src</code>：用于指定音乐的路径</p>
<p><code>&lt;marquee&gt;</code>飘动标签<br><code>direction</code> : 指定飘动的方向<br><code>scrollamount</code> : 指定飘动的速度。<br><code>loop</code>:指定飘动的次数</p>
<h3 id="使用Demo"><a href="#使用Demo" class="headerlink" title="使用Demo"></a>使用Demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	.......</span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">"1.mp3"</span> &gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">marquee</span> <span class="attr">direction</span> = <span class="string">"right"</span> <span class="attr">loop</span>=<span class="string">"-5"</span> &gt;</span><span class="tag">&lt;<span class="name">font</span> <span class="attr">sine</span> = <span class="string">"+6"</span> <span class="attr">color</span> = <span class="string">"red"</span> &gt;</span> 看，猪飞起来了！<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签<a></a></h2><p><code>&lt;a&gt;</code>超链接标签</p>
<h3 id="a标签常用的属性："><a href="#a标签常用的属性：" class="headerlink" title="a标签常用的属性："></a>a标签常用的属性：</h3><p><code>href</code>  : 用于指定链接的资源<br><code>target</code>: 设置打开新资源的目标。<code>_Blank</code> 在独立的窗口上打开新资源 <code>_self</code>在当前窗口打开新资源</p>
<h3 id="超链接标签的作用："><a href="#超链接标签的作用：" class="headerlink" title="超链接标签的作用："></a>超链接标签的作用：</h3><ol>
<li><p>可以用于链接资源。</p>
</li>
<li><p>锚点点位：<br>2.1. 首先编写一个锚点  锚点的格式：<code>&lt;a name=&quot;锚点名字&quot;&gt; 数据&lt;/a&gt;</code><br>2.2. 使用a标签 的herf属性连接到锚点出。  <code>href=”#锚点的名字“</code></p>
</li>
</ol>
<h3 id="lt-a-gt-标签的原理："><a href="#lt-a-gt-标签的原理：" class="headerlink" title="&lt;a&gt;标签的原理："></a><code>&lt;a&gt;</code>标签的原理：</h3><ol>
<li><p>a标签的href属性值如果是以http开头的，那么浏览器会马上启动http解释器去解释该网址，首先会在本地机器去找一个hosts文件， 如果在hosts文件上该域名没有对应的主机，那么浏览器就去到对应的dns服务器去寻找该域名对应的主机号。如果找到了对应的主机，那么该请求就会发给对应的主机。</p>
</li>
<li><p>如果a标签的href属性值没有以任何协议开头，那么浏览就会启动file协议解释器去解释该资源路径。</p>
</li>
<li><p>如果a标签的href属性值并不是以http开始，而且其他的一些协议，那么这时候浏览器就回去到我们本地的注册表中去查找是否有处理这种协议 的应用程序，如果有，那么马上启动该应用程序处理该协议。</p>
</li>
</ol>
<h3 id="几种常用的协议："><a href="#几种常用的协议：" class="headerlink" title="几种常用的协议："></a>几种常用的协议：</h3><p><code>file</code>  file协议（文件协议）这种协议主要是用于搜索本地机器的资源文件的。<br><code>mailTo</code> 邮件的协议：<br><code>thunder</code> 迅雷的协议： </p>
<h3 id="使用Demo-1"><a href="#使用Demo-1" class="headerlink" title="使用Demo"></a>使用Demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	.......</span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.zhihu.com"</span>&gt;</span>超链接Demo 知乎网址<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_Blank"</span> <span class="attr">href</span>=<span class="string">"http://www.zhihu.com"</span>&gt;</span>在独立的新窗口打开 知乎网址<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	试一下邮件的链接：我的自己的邮箱：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailTo:me@chnwentao.com"</span>&gt;</span>me@chntao.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"thunder://abc/aa一个人的武林.avi"</span>&gt;</span>一个人的武林(高清枪版).avi<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"top"</span>&gt;</span>我们要返回的地方  一般是 顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!--锚点 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	....假设中间有好多文字.....</span><br><span class="line">	<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#top"</span>&gt;</span>一点就可以回到顶部我的自定义的文字啦%！<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="图片标签-lt-img-gt"><a href="#图片标签-lt-img-gt" class="headerlink" title="图片标签&lt;img&gt;"></a>图片标签<code>&lt;img&gt;</code></h2><p><code>&lt;img&gt;</code>图片标签：</p>
<p>###img标签常用的属性:<br><code>width</code>： 设置图片宽度<br><code>height</code> : 设置图片高度<br><code>alt</code>:    如果图片资源无法找到，那么就显示对应的文字对图片进行说明。<br>热点图：(略)</p>
<h3 id="图片和热点图使用Demo"><a href="#图片和热点图使用Demo" class="headerlink" title="图片和热点图使用Demo"></a>图片和热点图使用Demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	.......</span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span>  <span class="attr">src</span>=<span class="string">"11.jpg"</span>  <span class="attr">alt</span>=<span class="string">"这个是路飞"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"300"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">usemap</span>=<span class="string">"#Map"</span> /&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"Map"</span> <span class="attr">id</span>=<span class="string">"Map"</span>&gt;</span></span><br><span class="line">     		<span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"171,178,304,227"</span> <span class="attr">href</span>=<span class="string">"http:\\www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> /&gt;</span><span class="comment">&lt;!--形状； 距上左边距，长，宽；网站； 打开在在独立的窗口--&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">"189,135,27"</span> <span class="attr">href</span>=<span class="string">"2常用的标签.html"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> /&gt;</span><span class="comment">&lt;!--圆形的热点图--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><h3 id="表格使用到的标签："><a href="#表格使用到的标签：" class="headerlink" title="表格使用到的标签："></a>表格使用到的标签：</h3><p><code>&lt;table&gt;</code> 表格<br><code>&lt;tr&gt;</code>   行<br><code>&lt;td&gt;</code>   单元格 默认的样式是靠左对齐。<br><code>&lt;th&gt;</code>     表头   默认的样式是居中，加粗。<br><code>&lt;caption&gt;</code>  表格的标题</p>
<h3 id="表格常用的属性："><a href="#表格常用的属性：" class="headerlink" title="表格常用的属性："></a>表格常用的属性：</h3><p><code>border</code>  设置表格的边框<br><code>width</code>: 设置表格的宽度<br><code>height</code>: 设置表格的高度的。<br><code>colspan:</code> 设置单元格占据指定的列数。<br><code>rowspan</code> : 设置单元格占据指定的行数。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>以前的浏览器一旦遇到一个<code>&lt;table&gt;</code>的开始标签，就必须等到遇到<code>&lt;/table</code>的时候才会在见面中显示一个表格的内容。这样，如果 网速太慢，或表格太大，那等待的时间就很长了。所以出现了：<br><code>&lt;thead&gt;......&lt;/thead&gt;</code> 可以没有<br><code>&lt;tbody&gt;.....&lt;/tbody&gt;</code>    一个表格至少要有一个，可以多个；你代码中不写也可以，浏览器会自动加一个的，<br><code>&lt;tfoot&gt;........&lt;/tfoot&gt;</code> 可以没有<br>把一个网页分成多段显示。减少等待时间。</p>
<h3 id="使用Demo-2"><a href="#使用Demo-2" class="headerlink" title="使用Demo"></a>使用Demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	.......</span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"2px"</span> <span class="attr">bordercolor</span>=<span class="string">"#0066AA"</span> <span class="attr">width</span>=<span class="string">"600px"</span> <span class="attr">height</span> = <span class="string">"300px"</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">caption</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">th</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="comment">&lt;!--表头的演示--&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">th</span>&gt;</span>怎么样<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">td</span>&gt;</span>徐尼玛<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">td</span>&gt;</span>诶哦哟<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span><span class="comment">&lt;!--设置居中的Demo--&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">td</span>&gt;</span>456<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">td</span>&gt;</span>王尼玛<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">td</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--设置单元格占据指定的列数的Demo--&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">td</span>&gt;</span>456<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>我要占两格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        		<span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>456<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">td</span>&gt;</span>哈尼玛<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">td</span>&gt;</span>不怎么样<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">       		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">td</span>&gt;</span>哈尼玛2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">td</span>&gt;</span>不怎么样2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="框架标签frameSet"><a href="#框架标签frameSet" class="headerlink" title="框架标签frameSet"></a>框架标签frameSet</h2><p><code>frameSet</code> ： 一个frameSet可以把一个页面切割成多份。只能按照行或者列切割。<br><code>frame</code>  不能被切割的。 frame是位于frameSet中。(但是FrameSet可以嵌套的，嘿嘿)<br><code>iframe</code>:  在一个网页中分隔一部分的位置显示另外一个网页的的信息。<br><strong>注意：</strong> <code>frameSet</code>标签不能用于body标签体内容。</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">frameset</span>  <span class="attr">rows</span>=<span class="string">"20%,70%,*"</span> &gt;</span><span class="comment">&lt;!--row设置区域的大小的，按百分比--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span>  <span class="attr">src</span>=<span class="string">"top.html"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"20%,*"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"left.html"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frame</span> <span class="attr">name</span>=<span class="string">"center"</span> <span class="attr">src</span>=<span class="string">"center.html"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"foot.html"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span><span class="tag">&lt;<span class="name">noframes</span>&gt;</span><span class="tag">&lt;/<span class="name">noframes</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="表单-lt-form-gt"><a href="#表单-lt-form-gt" class="headerlink" title="表单&lt;form&gt;"></a>表单<code>&lt;form&gt;</code></h2><p>表单标签的作用是用于提交数据给服务器的。</p>
<h3 id="常用的属性："><a href="#常用的属性：" class="headerlink" title="常用的属性："></a>常用的属性：</h3><p><code>action</code>: 该属性是用于指定提交数据的地址。<br><code>method</code>： 指定表单的提交方式。<br><code>get</code> : 默认使用的提交方式。  提交的数据会显示在地址栏上。 <strong>注意：提交的数据 不能起过1KB</strong>；<br><code>post</code> ：  提交的数据不会显示在地址栏上。 提交第三数据时相对安全一点。<br><strong>注意： </strong>表单项的数据如果需要提交到服务器上面，那么表单项必须要有name的属性值。</p>
<h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	.......</span><br><span class="line">	<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span> = <span class="string">"http://www.baidu.com "</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    		<span class="comment">&lt;!-- 文本输入框 单行--&gt;</span></span><br><span class="line">    		用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span> = <span class="string">"userName"</span> <span class="attr">type</span> = <span class="string">"text"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    		<span class="comment">&lt;!-- 密码框 --&gt;</span></span><br><span class="line">    		密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span> = <span class="string">"password"</span> <span class="attr">type</span> = <span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    		<span class="comment">&lt;!-- 单选框  --&gt;</span></span><br><span class="line">    		性别： 男<span class="tag">&lt;<span class="name">input</span> <span class="attr">checked</span>=<span class="string">"true"</span> <span class="attr">value</span>=<span class="string">"man"</span>  <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">type</span>=<span class="string">"radio"</span>/&gt;</span>   女<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"woman"</span> <span class="attr">type</span>=<span class="string">"radio"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    		<span class="comment">&lt;!-- 下拉框 --&gt;</span></span><br><span class="line">    		来自的城市：<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"city"</span>&gt;</span>	</span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"BJ"</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"GZ"</span>&gt;</span>武汉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"SZ"</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 复选框  同一组的复选框name的属性值要一致 --&gt;</span></span><br><span class="line">            兴趣爱好：java <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"java"</span> <span class="attr">name</span>=<span class="string">"hobit"</span>  <span class="attr">checked</span>=<span class="string">"checked"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> /&gt;</span>javascript <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"javascript"</span> <span class="attr">name</span>=<span class="string">"hobit"</span> /&gt;</span>android <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"android"</span> <span class="attr">name</span>=<span class="string">"hobit"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 文件上传框--&gt;</span></span><br><span class="line">            照片：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"file"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- 文本域 多行--&gt;</span></span><br><span class="line">            人个简介：</span><br><span class="line">            <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span> = <span class="string">"intro"</span> <span class="attr">rows</span> = <span class="string">"10"</span> <span class="attr">cols</span>=<span class="string">"50"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">           	<span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"注册"</span>/&gt;</span></span><br><span class="line">    		<span class="comment">&lt;!--  重置按钮 --&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"重置"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JavaWeb </tag>
            
            <tag> html </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb预备知识笔记]]></title>
      <url>/2015/11/coding/Java-Web-%E7%AC%94%E8%AE%B0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要——Junit（单元测试）、Assert（断言）、Interospector（内省）、BeanUtils、配置文件。<a id="more"></a></p>
<h2 id="单元测试框架-Junit"><a href="#单元测试框架-Junit" class="headerlink" title="单元测试框架 Junit"></a>单元测试框架 Junit</h2><p>在测试方法前加注释<code>@Test</code></p>
<h3 id="junit要注意的细节："><a href="#junit要注意的细节：" class="headerlink" title="junit要注意的细节："></a>junit要注意的细节：</h3><ol>
<li><p>如果使用junit测试一个方法的时候，在junit窗口上显示绿条那么代表测试正确，如果是出现了红条，则代表该方法测试出现了异常不通过。</p>
</li>
<li><p>如果点击方法名、 类名、包名、 工程名然后右键点 <code>Run as</code>运行junit分别测试的是对应的方法，类、 包中的所有类的test方法，工程中的所有test方法。</p>
</li>
<li><p><code>@Test</code>测试的方法不能是static修饰与不能带有形参。</p>
</li>
<li><p>如果测试一个方法的时候需要准备测试的环境或者是清理测试的环境，那么可以<code>@Before、 @After 、@BeforeClass、 @AfterClass这</code>四个注解。<code>@Before、 @After</code>是在每个测试方法测试的时候都会调用一次， <code>@BeforeClass、 @AfterClass</code>是在所有的测试方法测试之前与测试之后调用一次而已。</p>
</li>
</ol>
<h3 id="junit使用规范："><a href="#junit使用规范：" class="headerlink" title="junit使用规范："></a>junit使用规范：</h3><ol>
<li>一个类如果需要测试，那么该类就应该对应着一个<strong>测试类</strong>，测试类的命名规范 ： <code>被测试类的类名+ Test.</code></li>
<li>一个被测试的方法一般对应着一个<strong>测试的方法</strong>，测试的方法的命名规范是： <code>test+ 被测试的方法的方法名</code><br>注意测试方法和测试类的命名的不同。</li>
</ol>
<h2 id="断言Assert（略）"><a href="#断言Assert（略）" class="headerlink" title="断言Assert（略）"></a>断言Assert（略）</h2><h2 id="内省Interospector"><a href="#内省Interospector" class="headerlink" title="内省Interospector"></a>内省Interospector</h2><p>专门用于操作java对象的属性，主要功能就是把对象的属性封装到一个对象中。<br>说白了，就是一种变态的反射。</p>
<h3 id="获取单个方法属性的Demo"><a href="#获取单个方法属性的Demo" class="headerlink" title="获取单个方法属性的Demo"></a>获取单个方法属性的Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProperty</span><span class="params">()</span>  <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		<span class="comment">//属性描述器（注意是单一的一个属性）</span></span><br><span class="line">		PropertyDescriptor  propertyDescriptor = <span class="keyword">new</span> PropertyDescriptor(<span class="string">"id"</span>, Person.class);</span><br><span class="line">		<span class="comment">// 获取属性的set方法</span></span><br><span class="line">		Method setMethod = propertyDescriptor.getWriteMethod();</span><br><span class="line">		<span class="comment">//执行该方法——设置属性</span></span><br><span class="line">		setMethod.invoke(p, <span class="number">110</span>);</span><br><span class="line">		<span class="comment">//获取属性的get方法</span></span><br><span class="line">		Method getMethod = propertyDescriptor.getReadMethod();</span><br><span class="line"></span><br><span class="line">		System.out.println(getMethod.invoke(p, <span class="keyword">null</span>));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="批量获取属性的的Demo"><a href="#批量获取属性的的Demo" class="headerlink" title="批量获取属性的的Demo"></a>批量获取属性的的Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllProperty</span><span class="params">()</span> <span class="keyword">throws</span> IntrospectionException </span>&#123;</span><br><span class="line">		<span class="comment">//Introspector 内省类 </span></span><br><span class="line">		BeanInfo beanInfo = Introspector.getBeanInfo(Person.class);<span class="comment">//注意，这个是要抛出异常的！</span></span><br><span class="line">		<span class="comment">////获取一个类中的所有属性描述器</span></span><br><span class="line">		PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors();</span><br><span class="line">		<span class="keyword">for</span> (PropertyDescriptor propertyDescriptor : descriptors) &#123;</span><br><span class="line">			System.out.println(propertyDescriptor.getReadMethod());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h2><p> BeanUtils主要解决的问题： 把对象的属性数据封装 到对象中。(是不是和Interospector 一样一样的)</p>
<h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><ul>
<li><p>BeanUtils设置属性值的时候，如果属性是<strong>基本数据类型</strong>，BeanUtils会自动帮我转换数据类型。</p>
</li>
<li><p>BeanUtils设置属性值的时候底层也是<strong>依赖于</strong>get或者Set方法设置以及获取属性值的。</p>
</li>
<li><p>BeanUtils设置属性值,如果设置的属性是其他的引用类型数据（是一个对象），那么这时候必须要注册一个<strong>类型转换器</strong>。（Demo中有）</p>
</li>
</ul>
<h3 id="使用Demo"><a href="#使用Demo" class="headerlink" title="使用Demo:"></a>使用Demo:</h3><p>BeanUtilss使用前要导包：<br>导包：<code>commons-logging.jar</code> 、 <code>commons-beanutils-1.8.0.jar</code><br><code>commons-logging.jar</code>没有导入的话，编译器会提示：<code>NoClassDefFoundError</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">		<span class="comment">//从文件中读取到的数据都是字符串的数据，或者是表单提交的数据获取到的时候也是字符串的数据。</span></span><br><span class="line">		String id =<span class="string">"110"</span>;</span><br><span class="line">		String name=<span class="string">"陈其"</span>;</span><br><span class="line">		String salary = <span class="string">"1000.0"</span>;</span><br><span class="line">		String birthday = <span class="string">"2013-12-10"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">////注册一个类型转换器</span></span><br><span class="line">		ConvertUtils.register( <span class="keyword">new</span> Converter()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">convert</span> <span class="params">(Class type, Object value)</span> </span>&#123; <span class="comment">//type : 目前所遇到的数据类型。  value :目前参数的值。</span></span><br><span class="line">				Date date = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat (<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">					date = (Date) dateFormat.parse((String)value);</span><br><span class="line">				&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> date;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;, Date.class);</span><br><span class="line"></span><br><span class="line">		Emp emp = <span class="keyword">new</span> Emp();</span><br><span class="line">		BeanUtils.setProperty(emp, <span class="string">"id"</span>, id);</span><br><span class="line">		BeanUtils.setProperty(emp, <span class="string">"name"</span>, name);</span><br><span class="line">		BeanUtils.setProperty(emp, <span class="string">"birthday"</span>,birthday);</span><br><span class="line">		BeanUtils.setProperty(e, <span class="string">"birthday"</span>,birthday);</span><br><span class="line">		System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置文件及其路径"><a href="#配置文件及其路径" class="headerlink" title="配置文件及其路径"></a>配置文件及其路径</h2><p>如果经常会发生变化的数据我们可以定义在配置文件上。 比如说：数据库的用户名与密码。而不应该是<strong>硬编码</strong>。</p>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><ul>
<li><p>绝对路径：一个文件的完整路径信息。一般绝对路径是包含有盘符的。绝对路径的缺陷： 因为绝对路径是有盘符开头的，有些系统是没有盘符的。（在不同的系统不兼容）</p>
</li>
<li><p>相对路径: 相对路径是相对于当前程序的路径。当前路径就是执行java命令的时候，控制台所在的路径。（也是不安全的）</p>
</li>
<li><p>类文件路径 :类文件路径就是使用了<code>classpath的路径</code>找对应的资源文件。(推荐使用，用来找配置文件)</p>
</li>
</ul>
<h3 id="类文件路径及配置文件使用的Demo"><a href="#类文件路径及配置文件使用的Demo" class="headerlink" title="类文件路径及配置文件使用的Demo"></a>类文件路径及配置文件使用的Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Properties properties ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		properties = <span class="keyword">new</span> Properties();</span><br><span class="line">		<span class="comment">//去加载配置文件  /</span></span><br><span class="line">		Class clazz = DBUtil.class;</span><br><span class="line">		<span class="comment">//定义配置文件的路径</span></span><br><span class="line">		InputStream inputStream = clazz.getResourceAsStream(<span class="string">"/db.properties"</span>); <span class="comment">//  "/"代表了Classpath的路径。           getResourceAsStream 该方法里面使用的路径就是使用了类文件路径。</span></span><br><span class="line">		<span class="comment">//加载配置文件</span></span><br><span class="line">		properties.load(inputStream);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"当前路径："</span>+ <span class="keyword">new</span> File(<span class="string">"."</span>).getAbsolutePath() );</span><br><span class="line">	<span class="comment">//如何获取配置文件中定义的属性</span></span><br><span class="line">	System.out.println(<span class="string">"用户名："</span>+ properties.getProperty(<span class="string">"userName"</span>)+<span class="string">" 密码："</span>+properties.getProperty(<span class="string">"password"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小知识："><a href="#小知识：" class="headerlink" title="小知识："></a>小知识：</h2><p>在java 中实体类习惯被称之为 <code>javaBean</code>；<br>从文件中读取到的数据都是字符串的数据，或者是表单提交的数据获取到的时候也是字符串的数据。——就是说我们以后是经常和字符串打交道。</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JavaWeb </tag>
            
            <tag> 单元测试 </tag>
            
            <tag> 内省 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中父类引用指向子类对象——向上转型、多态、动态链接]]></title>
      <url>/2015/11/coding/Java-%E9%97%AE%E9%A2%98-%E7%88%B6%E7%B1%BB%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>我发现的问题：<br><strong>父类引用指向子类对象</strong>指的是：<br>构造一个对象，代码为<code>JFrame frame = new SizedFrame()</code>; 声明的<code>JFrame</code> 是<code>SizedFrame</code>的超类。<br>即声明的是父类，实际指向的是子类的一个对象。<br>问题来了:<br>——这个代码和<code>SizedFrame frame = new SizedFrame()</code>; 有什么区别呢？那这么使用的优点是什么，为什么要这么用？<br><a id="more"></a><br>这实际是一种<strong>“向上转型”</strong> ：<br>可以这样理解，这里定义了一个<code>JFrame</code>类型<code>的 frame</code>，它指向<code>SizedFrame</code>对象实例。由于<code>SizedFrame</code>是继承与<code>JFrame</code>，所以<code>frame</code>是可以指向<code>SizedFrame</code>实例对象的。这就是一种向上转型。<br>向上转型后<code>frame</code>只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法、属性，该引用是不能使用的，包括子类<strong>重载</strong>后的方法。（这是向上转型存在的缺憾：那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。）但是若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。（这就是好处啊，子类提供比父类更加强大的功能，向上转型后的<code>frame</code> 除了能够引用父类的共性外，还可以使用子类强大的功能。）</p>
<p>这其中涉及到了<strong>动态链接（Dynamic-link）</strong>的概念：<br><em>动态链接</em>：当父类中的一个方法只有在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用； 对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。</p>
<p>由此，我们又引出了<strong>多态（polyporphism）</strong>的概念：</p>
<ul>
<li><p>使用超类型的引用指向子类的对象；</p>
</li>
<li><p>该引用只能调用超类中定义的方法和变量；</p>
</li>
<li><p>如果子类中重写了超类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）</p>
</li>
<li><p>变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了基类中的变量，那么在编译时会报错。</p>
</li>
</ul>
<p>注意:  不要将<strong>重写（override）</strong>和<strong>重载（overload）</strong>搞混淆啦~ (from 金瑾 大神）</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 辨析 </tag>
            
            <tag> 问题 </tag>
            
            <tag> 向上转型 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 动态链接 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中公有类、非公有类与内部类区别及联系]]></title>
      <url>/2015/11/coding/Java-%E6%80%BB%E7%BB%93-%E5%85%AC%E6%9C%89%E7%B1%BB&amp;%E9%9D%9E%E5%85%AC%E6%9C%89%E7%B1%BB&%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="主要区别："><a href="#主要区别：" class="headerlink" title="主要区别："></a>主要区别：</h2><p>java规定 ：</p>
<ul>
<li><p>一个源文件的文件名必须与public类（也就公有类）的名字相匹配；</p>
</li>
<li><p>在一个源文件中，只能有一个公有类，但可以包含多个非公有类或者内部类；</p>
</li>
<li><p>非公有类不能使用public关键字（一般前面不加关键字），内部类可以使用public、private、protected关键字；</p>
</li>
<li><p>非公有类是包可见的，一个包中只能有一个同名非公有类，所以在包外无法调用非公有类；但是在包外可以通过包中外部类对象调用该包中的内部类。</p>
</li>
<li><p>只用内部类可以是私有的，而常规类只可以具有包可见性或公有性</p>
<a id="more"></a>
<p>ps：<br>这时要总结一下包作用域的概念 ：<br>如果有没指定public 或private（就是修饰符缺省），这个部分（类，方法，变量）就是只可以被同一个包中的所以方法访问。也可以说默认的就是friendly</p>
</li>
</ul>
<p><img src="http://7xiuu0.com1.z0.glb.clouddn.com/Java_总结_公有类" alt=""></p>
<h2 id="调用的问题："><a href="#调用的问题：" class="headerlink" title="调用的问题："></a>调用的问题：</h2><p>非公有类在源文件中直接调用：<br>例如：在源文件Test.java中存在一个公有类Test，一个非公有类priTest，那么可以使用preTest pt = new preTest() 实例化一个非公有类的对象；包内的文件也是可以调用的。<br>而对于内部类，在非静态方法外部<em>必须使用外部类的对象来调用内部类的构造方法：</em><br>例如：在源文件Outer.java中存在一个外部类Outer，一个内部类Inner，那么使用以下方式调用内部类：Outer out = new Outer()，Inner in = out.new Inner()。也可以可以使用Out.In in = new Out.In()直接创建内部类对象。在非静态方法内部直接使用new类实例化内部类对象，即直接Inner in = new Inner()。</p>
<h2 id="变量访问："><a href="#变量访问：" class="headerlink" title="变量访问："></a>变量访问：</h2><p>非公有类只能通过创建公有类对象实现对于公有类的成员变量的使用，而内部类可以随意使用外部类的成员变量(包括私有变量)而不用生成外部类的对象。（也就是说内部类有访问特权。是不是很强大……）</p>
<h2 id="详细说一说内部类："><a href="#详细说一说内部类：" class="headerlink" title="详细说一说内部类："></a>详细说一说内部类：</h2><h3 id="变量访问：-1"><a href="#变量访问：-1" class="headerlink" title="变量访问："></a>变量访问：</h3><p>在内部类中访问变量有三种形式：<br>a、变量名–访问局部变量；<br>b、this.变量名–访问内部类变量；<br>c、外部类名.this.变量名–访问外部类变量。<br>注意：</p>
<ul>
<li><p>内部类中不能定义静态成员变量。（若有 static 修饰符，就为类级，否则为对象级。类级可以通过外部类直接访问，对象级需要先生成外部的对象后才能访问。）</p>
</li>
<li><p>如果内部类没有同名成员变量和局部变量，内部类可以直接通过变量名访问外部类变量，而不用指定”外部类名.this.变量名”。</p>
</li>
</ul>
<h3 id="静态内部类："><a href="#静态内部类：" class="headerlink" title="静态内部类："></a>静态内部类：</h3><p>如果一个内部类是静态内部类，使用关键字static，（只有在是静态内部类的情况下才能把static修复符放在类前，其他任何时候static都是不能修饰类的。）静态内部类中无法引用到其外围类的非静态成员。（与普通内部类的唯一区别。）</p>
<h3 id="私有内部类"><a href="#私有内部类" class="headerlink" title="私有内部类"></a>私有内部类</h3><p>11、如果一个内部类是“私有的”，则该类只能在外部类中生成对象进行操作，而无法再使用Out.In in = new Out().new In()生成内部类对象。</p>
<h3 id="局部内部类："><a href="#局部内部类：" class="headerlink" title="局部内部类："></a>局部内部类：</h3><p>实际上就是 在方法中定义的内部类.<br>方法内部类也有两个特点</p>
<ul>
<li><p>方法中的内部类没有访问修饰符， 即方法内部类对包围它的方法之外的任何东西都不可见。</p>
</li>
<li><p>该内部类没有任何的访问控制权限.</p>
</li>
<li><p>外围类看不见方法中的局部内部类的，但是<em>局部内部类可以访问外围类的任何成员</em>。</p>
</li>
<li><p>方法体中可以访问局部内部类，但是访问语句<em>必须</em>在定义局部内部类之后。</p>
</li>
<li><p>方法内部类只能够访问该方法中的局部变量，所以也叫局部内部类。而且这些局部变量一定要是final修饰的常量。（编译器的原因解释起来比较麻烦）</p>
</li>
</ul>
<h2 id="编译时候的那点事儿："><a href="#编译时候的那点事儿：" class="headerlink" title="编译时候的那点事儿："></a>编译时候的那点事儿：</h2><p>如果源文件中有一个公有类和多个非公有类，在编译的时候编译器会为文件中每个类创建一个单独的.class文件，文件名就是对应的类名（所以一个包中只能有一个同名的非公有类）；假如一个文件中有一个外部类，多个内部类，则在编译的时候也会为每个类创建一个.class文件，但是内部类对应的文件名为”外部类$内部类.class”，$代表这个内部类所属的外部类。——实际上就说，这几种类，对虚拟机是一样一样的……</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 编程 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 辨析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Why do we declare Loggers static final? —static和final一块用表示什么]]></title>
      <url>/2015/11/coding/Java-%E8%BD%AC%E8%BD%BD-static%E5%92%8Cfinal/</url>
      <content type="html"><![CDATA[<p><code>static final</code>用来修饰成员变量和成员方法，可简单理解为“全局常量”！<br>对于变量: 表示一旦给值就不可修改，并且通过类名可以访问。<br>对于方法:表示不可覆盖，并且可以通过类名直接访问。<br>有时你希望定义一个类成员，使它的使用完全独立于该类的任何对象。通常情况下，类成员必须通过它的类的对象访问，但是可以创建这样一个成员，它能够被它自己使用，而不必引用特定的实例。在成员的声明前面加上关键字<code>static(静态的)</code>就能创建这样的成员。<br>如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象。你可以将方法和变量都声明为<code>static</code>。<code>static</code> 成员的最常见的例子是<code>main( )</code> 。因为在程序开始执行时必须调用<code>main()</code> ，所以它被声明为<code>static</code>。<a id="more"></a></p>
<p>而对于<code>Logger</code> :<br>(1):出于资源利用的考虑，LOGGER的构造方法参数是Class，决定了LOGGER是根据类的结构来进行区分日志，所以一个类只要一个LOGGER就可以了，故static。使用static的结果是显而易见的: 只有一个日志对象在所有类的实例间共享.这显示是比较高效的内存利用; 无论创建多少实例只需要一个引用(4 or 8 字节) . 这样CPU也是非常高效的; CPU只需要在类被第一次引用的时候查找日志实例即可.<br>(2):<code>final</code>表示一种编程习惯，表示该类的LOGGER只是记录该类的信息，否则日志会无法提供可以令人信服的记录；</p>
<p>找到一篇blog如是说：<br><a href="http://www.nofluffjuststuff.com/blog/scott_leberknight/2007/03/loggerisnotstaticfinal.html" target="_blank" rel="noopener">原文链接http://www.nofluffjuststuff.com/blog/scott_leberknight/2007/03/loggerisnotstaticfinal.html</a><br>For anyone who uses PMD, the title of this blog appears in their list of PMD errors if they don’t declare their loggers static and final. Specifically, the LoggerIsNotStaticFinal rule simply says that a log should be declared static and final. I also like to make sure they are private as well. For example:</p>
<p>// Jakarta Commons Logging<br>private static final Log log = LogFactory.getLog(MyClass.class);<br>The above code also shows another good practice, which is to pass the Class object to the getLog() method, instead of a string. Why the java.util.logging.Logger class doesn’t even provide a method accepting a Class object is simply beyond me. Why did the people who developed the java.util.logging package base their API on Log4j yet omit some of the most useful parts of it? Oh well.</p>
<p>Now to the point. Why it is good practice to declare loggers private, static, and final? A logger is an internal implementation detail, so it should be private. You only need one logger for all instances of a class, hence static. And a logger should not be able to be replaced, thus final. So if this is good, what’s not so good (at least in my opinion)? Simple - any logger that is not private, static, final, and which doesn’t pass in a Class object to getLog()! For example, consider this common bit of code, declared in some base class:</p>
<p>// Not so good logger declaration<br>protected final Log log = LogFactory.getLog(getClass());<br>Why is this bad? Well, it isn’t static for one thing. For another, it uses getClass() to obtain the log. At first this seems efficient since now all subclasses automatically inherit a ready-made log of the correct runtime type. So what’s the issue here? The biggest problem with loggers declared in this manner is that you now get all the logging from the superclass mixed in with the logging from the subclass, and it is impossible in the log output to discern which messages came from which class unless you look at the source. This is really annoying if the superclass has a lot of logging that you don’t want to see, since you cannot filter it out.</p>
<p>Another problem is that your ability to set log levels differently goes away, for example if a subclass resides in a different package than the superclass. In that case, if you try to filter out logging from the superclass, you can’t because the actual runtime class was used to obtain the logger.</p>
<p>Last, having a protected logger just seems to violate basic object-oriented principles. Why in the world should subclasses know about an internal implementation detail from a superclass that is a cross-cutting concern, no less? Anyway, though this is a silly little rant it really is annoying when you extend a superclass that declares a protected logger like this.</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 辨析 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java权限修饰符概述]]></title>
      <url>/2015/11/coding/Java-%E6%80%BB%E7%BB%93-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p>java访问权限修饰符（特殊情况除外）<a id="more"></a></p>
<table>
<thead>
<tr>
<th style="text-align:left">作用域</th>
<th style="text-align:right">当前类</th>
<th style="text-align:right">同一package</th>
<th style="text-align:right">子孙类</th>
<th style="text-align:right">其他package</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">public</td>
<td style="text-align:right">√</td>
<td style="text-align:right">√</td>
<td style="text-align:right">√</td>
<td style="text-align:right">√</td>
</tr>
<tr>
<td style="text-align:left">protected</td>
<td style="text-align:right">√</td>
<td style="text-align:right">√</td>
<td style="text-align:right">√</td>
<td style="text-align:right">×</td>
</tr>
<tr>
<td style="text-align:left">friendly</td>
<td style="text-align:right">√</td>
<td style="text-align:right">√</td>
<td style="text-align:right">×</td>
<td style="text-align:right">×</td>
</tr>
<tr>
<td style="text-align:left">private</td>
<td style="text-align:right">√</td>
<td style="text-align:right">×</td>
<td style="text-align:right">×</td>
<td style="text-align:right">×</td>
</tr>
</tbody>
</table>
<p>不写时默认为friendly<br>首先声明：java中，friendly这个修饰符并没有显式的声明，在成员变量和方法前什么修饰符也不用，默认的就是friendly。为了条理清晰，分三种不同情况来总结。</p>
<h2 id="访问权限修饰符修饰成员变量和方法"><a href="#访问权限修饰符修饰成员变量和方法" class="headerlink" title="访问权限修饰符修饰成员变量和方法"></a>访问权限修饰符修饰成员变量和方法</h2><p>1.public：表明该成员变量和方法是共有的，能在任何情况下被访问。<br>2.protected：必须在同一包中才能被访问。<br>3.friendly：在一个包中或者子类中才能被访问。<br>4.private: 只能在本类中访问。<br>实际上，把重要的数据修饰为private(<em>建议：所有的数据</em>)，然后写一个public的函数访问它，正好体现了OOP的封装特性，是OOP安全性的体现。</p>
<h2 id="访问权限修饰符修饰类"><a href="#访问权限修饰符修饰类" class="headerlink" title="访问权限修饰符修饰类"></a>访问权限修饰符修饰类</h2><p>1.不能用protected和private修饰类。<br>2.用friendly修饰的类叫友好类，在另外一个类中使用友好类创建对象时，要保证它们在同一包中。</p>
<h2 id="访问权限修饰符与继承"><a href="#访问权限修饰符与继承" class="headerlink" title="访问权限修饰符与继承"></a>访问权限修饰符与继承</h2><p>这里的访问修饰符指的是修饰成员变量和方法。可以分为两种情况：<br>1.子类与父类在同一包中<br>此时只有声明为private的变量与方法不能被继承(访问)。<br>2.子类与父类不在同一包中<br>此时private与friendly均不能被继承(访问)， protected与public可以。<br>所以，访问权限修饰符权限从高到低排列是public, protected, friendly, priva</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 辨析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java-总结-常见英语词汇]]></title>
      <url>/2015/11/coding/Java-%E6%80%BB%E7%BB%93-%E5%B8%B8%E8%A7%81%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87/</url>
      <content type="html"><![CDATA[<p>总结的一些常见的英语词汇。英语总是程序员要面对的一个东西，是躲不过的。伸头是一刀，缩头也是一刀，那还不如大大方方的呢。实际上你学了就知道，一切反动派都是纸老虎。<br><a id="more"></a></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<p>##J ava基础常见英语词汇(共70个)<br>OO: object-oriented ,面向对象 [‘ɔbdʒekt] [‘ɔ:rientid]导向的<br>OOP: object-oriented programming,面向对象编程 [‘prəʊɡræmɪŋ]编程<br>JDK:Java development kit, java开发工具包 [dɪ’veləpmənt][kɪt]工具箱<br>JVM:java virtual machine ,java虚拟机    [‘dʒɑːvə]  [‘vɜːtjʊəl]虚拟的 [mə’ʃiːn]机器</p>
<p>Compile:编绎[kəm’paɪl]<br>Run:运行<br>variable:变量[‘veərɪəb(ə)l]<br>operation:操作,运算 [ɒpə’reɪʃ(ə)n]<br>parameter:参数 [pə’ræmɪtə]<br>function:函数  [‘fʌŋ(k)ʃ(ə)n]</p>
<p>member-variable:成员变量<br>member-function:成员函数</p>
<p>default:默认    [dɪ’fɔːlt]<br>access:访问    [‘ækses]<br>package:包     [‘pækɪdʒ]<br>import:导入包 [ɪm’pɔːt]<br>static:静态的 [‘stætɪk]<br>void:无(返回类型)     [vɔid]</p>
<p>parent class:父类    [‘peər(ə)nt]<br>base class:基类    beɪs]<br>super class:超类  [‘sjuːpə]<br>child class:子类    [tʃaɪld]<br>derived class:派生类  [di’raivd]</p>
<p>override:重写 [əʊvə’raɪd]<br>overload:重载 [əʊvə’ləʊd]</p>
<p>final:最终的,不能改变的 [‘faɪn(ə)l]<br>implements:实现 [‘ɪmplɪm(ə)nts]<br>Runtime:运行时    [rʌn’taim]</p>
<p>ArithmeticException:算术异常 [æriθ’metik] [ik’sepʃən]<br>ArrayIndexOutOfBoundsException:数组下标越界异常    [ə’rei] [‘indeks]  [baundz] [ik’sepʃən]<br>Null Pointer Exception:空引用异常  [nʌl] [‘pɔintə]指针<br>ClassNotFoundException:类没有发现异常<br>NumberFormatException:数字格式异常(字符串不能转化为数字)    [‘nʌmbə][‘fɔ:mæt]<br>Throws: (投掷)表示强制异常处理    [θrəuz]<br>Throwable:(可抛出的)表示所有异常类的祖先类</p>
<p>Lang:language,语言    [læŋ] [‘læŋɡwidʒ]<br>Util:工具    [ju’til]<br>Display:显示 [,dis’plei]<br>ArrayList:(数组列表)表示动态数组[ə’rei] [list]<br>HashMap: 散列表,哈希表[hæʃ] [mæp]</p>
<p>Swing:轻巧的 [swiŋ]<br>Awt:abstract window toolkit:抽象窗口工具包 [‘æbstrækt] [‘windəu] [‘tu:lkit]<br>Frame:窗体 [freim]<br>Panel:面板     ‘pænl]<br>Layout:布局 [‘leiaut]<br>Scroll:滚动    [skrəul]<br>Vertical:垂直 [‘və:tikəl]<br>Horizontal:水平 [‘hɔri’zɔntəl]<br>Label:标签 [‘leibl]<br>TextField:文本框 [tekst] [‘fi:ld]<br>TextArea:文本域 [‘εəriə]<br>Button:按钮 [‘bʌtən]<br>Checkbox:复选框 [tʃek] [bɔks]<br>Radiobutton:单选按钮    [‘reidiəu]<br>Combobox:复选框 [‘kɔmbəu]<br>Listener:监听 [‘lisənə]</p>
<p>Border:边界 [‘bɔ:də]<br>Flow:流 [fləu]<br>Grid:网格 [ɡrid]<br>MenuBar:菜单栏 [‘menju:] [bɑ:]<br>Menu:菜单 [‘menju:]<br>MenuItem:菜单项 [‘aitəm]<br>PopupMenu:弹出菜单 [‘pɔpʌp]<br>Dialog:对话框 [‘daiəlɔɡ]<br>Node:节点[nəud]<br>Jdbc:java database connectivity ：java数据库连接 [‘dʒa:və] [‘deitəbeis] [,kɔnek’tivəti]<br>DriverManager:驱动管理器    [draivə] [‘mænidʒə]<br>Connection:连接 [kə’nekʃən]<br>Statement:表示执行对象 [‘steitmənt]<br>Preparedstatement:表示预执行对象 [pri’peəd]  [ri’zʌlt]<br>Resultset:结果集<br>executeQuery:执行查询 [‘eksikju:t] [‘kwiəri]</p>
<h2 id="Jbuilder中常用英文-共33个"><a href="#Jbuilder中常用英文-共33个" class="headerlink" title="Jbuilder中常用英文(共33个)"></a>Jbuilder中常用英文(共33个)</h2><p>Close  all  except…:除了..全部关闭 [kləuz] [ik’sept] [peinz]<br>Panes:面板组<br>Bean:豆子    [bi:n]<br>Properties:属性 [‘prɔpətiz]<br>Make:编绎 [meik]<br>Build:编绎        [bild]<br>Rebuild:重编绎 ,ri:’bild]<br>Refresh:刷新 [ri’freʃ]<br>Project properties:项目属性 [‘prɔdʒekt]<br>Default project properties:默认的项目属性 [di’fɔ:lt]<br>Debug:调试 [di:’bʌɡ]<br>Preferences:参数配置 [‘prefərənsiz]<br>Configure:配置 [kən’fiɡə]<br>Libraries:库 [‘laibrəriz]</p>
<h2 id="JSP中常用英文"><a href="#JSP中常用英文" class="headerlink" title="JSP中常用英文"></a>JSP中常用英文</h2><p>URL: Universal Resource Location:统一资源定位符 [,ju:ni’və:səl] [ri’sɔ:s]  [ləu’keiʃən]<br>IE: Internet Explorer 因特网浏览器    [‘intənet] [ik’splɔ:rə]<br>JSP: java server page： java服务器页面 [‘dʒa:və] [‘sə:və] [peidʒ]<br>Model:模型 [‘mɔdəl]<br>C:controller:控制器 [kən’trəulə]<br>Tomcat:一种jsp的web服务器 [‘tɔmkæt]                                              [<br>WebModule:web模块 [‘mɔdju:l]<br>Servlet:小服务程序 [‘sə:vlet]<br>Init: initialize,初始化 [i’niʃəlaiz]<br>Startup:启动 [‘sta:tʌp]<br>Mapping:映射 [‘mæpiŋ]<br>Getparameter:获取参数 [pə’ræmitə]<br>Session:会话 [‘seʃən]<br>Application:应用程序 [,æpli’keiʃən]<br>Context:上下文 [‘kɔntekst]<br>redirect:重定向 [,ri:di’rekt]<br>dispatch:分发 [dis’pætʃ]<br>forward:转交 [‘fɔ:wəd]<br>setattribute:设置属性  [ ‘ætribju:t]<br>getattribute:获取属性<br>contentType:内容类型 [‘kɔntent] [taip]<br>charset:字符集 [tʃɑ:]<br>include:包含 [in’klu:d]<br>tag:标签 [tæɡ]<br>taglib:标签库 [lib]<br>EL:expression language,表达式语言 [ik’spreʃən] [‘læŋɡwidʒ]<br>Scope:作用域 [skəup]<br>Empty:空 [‘empti]<br>JSTL:java standard tag library ：java标准标签库 [‘stændəd] [tæɡ] [‘laibrəri]<br>TLD:taglib description,标签库描述符 [di’skripʃən][kɔ:]<br>Core:核心<br>Foreach:表示循环<br>Var:variable,变量 [va:(r)] [‘vεəriəbl]<br>Status:状态 [‘steitəs]<br>Items:项目集合 [‘aitəm]<br>Fmt:format,格式化 [‘fɔ:mæt]<br>Filter:过滤器 [filtə]</p>
<p>(报错英文<br>Data Structures 基本数据结构 [‘strʌktʃəz]<br>Dictionaries 字典 [‘dikʃənəriz]<br>Priority  Queues 堆 [prai’ɔrəti] [kju:z]<br>Graph Data Structures 图 [ɡrɑ:f] [‘deɪtə] [‘strʌktʃəz]<br>Set Data Structures 集合 [set] [‘deɪtə][‘strʌktʃəz]<br>Kd-Trees 线段树    [tri:s]<br>Numerical  Problems 数值问题 [nju:’merikəl] [‘prɔ:bləms]<br>Solving Linear Equations 线性方程组 [sɔlviŋ] [‘liniə]  [i’kweiʃənz]<br>Bandwidth Reduction 带宽压缩 [‘bændwidθ] [ri’dʌkʃən]<br>Matrix  Multiplication 矩阵乘法 [‘meitriks] [,mʌltipli’keiʃən]<br>Determinants and Permanents 行列式 [di’tə:minənt]    [‘pə:mənənt]<br>Constrained and Unconstrained Optimization 最值问题 [kən’streind]    [ʌnkən’streɪnd]  [,ɔptimai’zeiʃən]<br>Linear Programming 线性规划 [‘liniə] [‘prəuɡræmiŋ]<br>Random Number Generation 随机数生成 [‘rændəm] [‘nʌmbə] [,dʒenə’reiʃən]<br>Factoring and Primality Testing 因子分解/质数判定 [‘fæktərɪŋ]  [prai’mæləti] [‘testɪŋ]<br>Arbitrary Precision Arithmetic 高精度计算 [‘ɑːbɪtrərɪ][prɪ’sɪʒən][ə’rɪθmətɪk]<br>Knapsack Problem 背包问题 [‘næpsæk] [‘prɒbləm]<br>Discrete Fourier Transform 离散Fourier变换 [dɪ’skriːt] [‘fʊriər] [træns’fɔːm]<br>Combinatorial Problems 组合问题<br>Median and Selection 中位数<br>Generating Permutations 排列生成<br>Generating Subsets 子集生成<br>Generating Partitions 划分生成<br>Generating Graphs 图的生成<br>Calendrical Calculations 日期<br>Job Scheduling 工程安排<br>Satisfiability 可满足性<br>Graph Problems – polynomial 图论-多项式算法<br>Connected Components 连通分支<br>Topological Sorting 拓扑排序<br>Minimum Spanning Tree 最小生成树<br>Shortest Path 最短路径<br>Transitive Closure and Reduction 传递闭包<br>Matching 匹配<br>Eulerian Cycle / Chinese Postman Euler回路/中国邮路<br>Edge and Vertex Connectivity 割边/割点<br>Network Flow 网络流<br>Drawing Graphs Nicely 图的描绘<br>Drawing Trees 树的描绘<br>Planarity Detection and Embedding 平面性检测和嵌入<br>Graph Problems – hard 图论-NP问题<br>Clique 最大团<br>Independent Set 独立集<br>Vertex Cover 点覆盖<br>Traveling Salesman Problem 旅行商问题<br>Hamiltonian Cycle Hamilton回路<br>Graph Partition 图的划分<br>Vertex Coloring 点染色<br>Edge Coloring 边染色<br>Graph Isomorphism 同构<br>Steiner Tree Steiner树<br>Feedback Edge/Vertex Set 最大无环子图<br>Computational Geometry 计算几何<br>Convex Hull 凸包<br>Triangulation 三角剖分<br>Voronoi Diagrams Voronoi图<br>Nearest Neighbor Search 最近点对查询<br>Range Search 范围查询<br>Point Location 位置查询<br>Intersection Detection 碰撞测试<br>Bin Packing 装箱问题<br>Medial-Axis Transformation 中轴变换<br>Polygon Partitioning 多边形分割<br>Simplifying Polygons 多边形化简<br>Shape Similarity 相似多边形<br>Motion Planning 运动规划<br>Maintaining Line Arrangements 平面分割<br>Minkowski Sum Minkowski和<br>Set and String Problems 集合与串的问题<br>Set Cover 集合覆盖<br>Set Packing 集合配置<br>String Matching 模式匹配<br>Approximate String Matching 模糊匹配<br>Text Compression 压缩<br>Cryptography 密码<br>Finite State Machine Minimization 有穷自动机简化<br>Longest Common Substring 最长公共子串<br>Shortest Common Superstring 最短公共父串<br>DP——Dynamic Programming——动态规划<br>recursion —— 递归<br>)<br>报错英文<br>第一章：<br>JDK(Java Development Kit) java开发工具包<br>JVM(Java Virtual Machine) java虚拟机<br>Javac   编译命令<br>java   解释命令<br>Javadoc   生成java文档命令<br>classpath 类路径<br>Version   版本<br>static   静态的<br>String   字符串类        </p>
<p>JIT(just-in-time)   及时处理 </p>
<p>第二章：<br>第三章：<br>OOP   object oriented programming 面向对象编程<br>Object 对象<br>Class 类<br>Class member 类成员<br>Class method   类方法<br>Class variable 类变量<br>Constructor 构造方法<br>Package 包<br>Import package 导入包 </p>
<p>第四章：<br>Base class 基类<br>Super class 超类<br>Overloaded method 重载方法<br>Overridden method    重写方法<br>Public    公有<br>Private 私有<br>Protected 保护<br>Static 静态<br>Abstract   抽象<br>Interface 接口<br>Implements interface    实现接口 </p>
<p>第五章：<br>RuntimeExcepiton 运行时异常<br>ArithmeticException 算术异常<br>IllegalArgumentException 非法数据异常<br>ArrayIndexOutOfBoundsException 数组索引越界异常<br>NullPointerException 空指针异常<br>ClassNotFoundException 类无法加载异常（类不能找到）<br>NumberFormatException 字符串到float类型转换异常（数字格式异常）<br>IOException 输入输出异常<br>FileNotFoundException 找不到文件异常<br>EOFException 文件结束异常<br>InterruptedException （线程）中断异常<br>throws 投、掷、抛<br>print Stack Trace() 打印堆栈信息<br>get Message（） 获得错误消息<br>get Cause（） 获得异常原因<br>method 方法<br>able 能够<br>instance 实例 </p>
<p>Byte （字节类）<br>Character （字符类）<br>Integer（整型类）<br>Long （长整型类）<br>Float（浮点型类）<br>Double （双精度类）<br>Boolean（布尔类）<br>Short （短整型类）<br>Digit （数字）<br>Letter （字母）<br>Lower (小写)<br>Upper (大写)<br>Space (空格)<br>Identifier (标识符)<br>Start (开始)<br>String (字符串)<br>length （值）<br>equals (等于)<br>Ignore （忽略）<br>compare （比较）<br>sub （提取）<br>concat （连接）<br>trim （整理）<br>Buffer (缓冲器)<br>reverse (颠倒)<br>delete （删除）<br>append （添加）<br>Interrupted （中断的）</p>
<p>第七章：<br>toString    转换为字符串<br>GetInstance   获得实例<br>Util     工具，龙套<br>Components   成分，组成 Next Int    下一个整数<br>Gaussian    高斯<br>ArrayList    对列<br>LinkedList   链表<br>Hash    无用信息，杂乱信号<br>Map     地图<br>Vector    向量，矢量<br>Collection   收集<br>Shuffle    混乱，洗牌<br>RemoveFirst   移动至开头<br>RemoveLast    移动至最后<br>lastElement   最后的元素<br>Capacity    容量，生产量<br>Contains    包含，容纳<br>InsertElementAt 插入元素在某一位置 </p>
<p>第八章：<br>io-&gt;in out 输入/输出<br>File   文件<br>isFile   是文件<br>isDirectory 是目录<br>getPath   获取路径<br>getAbsolutePath 获取绝对路径<br>lastModified 最后修改日期<br>Unicode   统一的字符编码标准, 采用双字节对字符进行编码<br>FileInputStream 文件输入流<br>FileOutputStream文件输出流<br>IOException 输入输出异常<br>fileobject 文件对象<br>available 可获取的<br>BufferedReader 缓冲区读取<br>FileReader 文本文件读取<br>BufferedWriter 缓冲区输出<br>FileWriter 文本文件写出<br>flush   清空<br>close   关闭<br>DataInputStream 二进制文件读取<br>DataOutputStream二进制文件写出<br>EOF   最后<br>encoding   编码<br>Remote   远程<br>release   释放 </p>
<p>第九章：<br>JBuider   Java 集成开发环境（IDE）<br>Enterprise 企业版<br>Developer 开发版<br>Foundation 基础版<br>Messages 消息格<br>Structure 结构窗格<br>Project   工程<br>Files   文件<br>Source   源代码<br>Design   设计<br>History   历史<br>Doc   文档<br>File   文件<br>Edit   编辑<br>Search   查找<br>Refactor 要素<br>View   视图<br>Run   运行<br>Tools   工具<br>Window   窗口<br>Help   帮助<br>Vector   矢量<br>addElement 添加内容<br>Project Winzard 工程向导<br>Step   步骤<br>Title   标题<br>Description 描述<br>Copyright 版权<br>Company   公司<br>Aptech Limited Aptech有限公司<br>author    作者<br>Back   后退<br>Finish   完成<br>version   版本<br>Debug   调试<br>New   新建<br>ErrorInsight 调试 </p>
<p>第十章：<br>JFrame   窗口框架<br>JPanel    面板<br>JScrollPane 滚动面板<br>title     标题<br>Dimension 尺寸<br>Component   组件<br>Swing   JAVA轻量级组件<br>getContentPane 得到内容面板<br>LayoutManager   布局管理器<br>setVerticalScrollBarPolicy   设置垂直滚动条策略<br>AWT（Abstract Window Toolkit） 抽象窗口工具包<br>GUI （Graphical User Interface） 图形用户界面<br>VERTICAL_SCROLLEARAS_NEEDED   当内容大大面板出现滚动条<br>VERTICAL_SOROLLEARAS_ALWAYS   显示滚动条<br>VERTICAL_SOROLLEARAS_NEVER   不显示滚动条<br>JLabel   标签<br>Icon    图标<br>image   图象<br>LEFT    左对齐<br>RIGHT   右对齐<br>JTextField   单行文本<br>getColumns   得到列数<br>setLayout   设置布局<br>BorderLayout 边框布局<br>CENTER   居中对齐<br>JTextArea   多行文本<br>setFont   设置字体<br>setHorizontalAlignment   设置文本水平对齐方式<br>setDefaultCloseOperation   设置默认的关闭操作<br>add   增加<br>JButton 按钮<br>JCheckBox 复选框<br>JRadioButton单选按钮<br>addItem 增加列表项<br>getItemAt 得到位置的列表项<br>getItemCount 得到列表项个数<br>setRolloverIcon 当鼠标经过的图标<br>setSelectedIcon 当选择按钮的图标<br>getSelectedItem 得到选择的列表项<br>getSelectedIndex 得到选择的索引<br>ActionListener   按钮监听<br>ActionEvent    按钮事件<br>actionPerformed   按钮单击方法</p>
<p>(编程词汇<br>A2A integration  A2A整合<br>abstract   抽象的<br>abstract base class (ABC)抽象基类<br>abstract class 抽象类<br>abstraction 抽象、抽象物、抽象性<br>access 存取、访问<br>access level访问级别<br>access function  访问函数<br>account  账户<br>action   动作<br>activate 激活<br>active   活动的<br>actual parameter  实参<br>adapter 适配器<br>add-in  插件<br>address 地址<br>address space     地址空间<br>address-of operator 取地址操作符<br>ADL (argument-dependent lookup)<br>ADO(ActiveX Data Object)ActiveX数据对象<br>advanced    高级的<br>aggregation 聚合、聚集<br>algorithm 算法<br>alias 别名<br>align 排列、对齐<br>allocate 分配、配置<br>allocator分配器、配置器<br>angle bracket 尖括号<br>annotation   注解、评注<br>API (Application Programming Interface) 应用(程序)编程接口<br>app domain (application domain)应用域<br>application  应用、应用程序<br>application framework 应用程序框架<br>appearance 外观<br>append     附加<br>architecture 架构、体系结构<br>archive file 归档文件、存档文件<br>argument引数(传给函式的值)。参见parameter<br>array   数组<br>arrow operator  箭头操作符<br>ASP(Active Server Page)活动服务器页面<br>ASP.NET worker process ASP.NET工作者进程<br>assembly     装配件、配件<br>assembly language   汇编语言<br>assembly manifest   装配件清单<br>assert(ion) 断言<br>assign      赋值<br>assignment  赋值、分配<br>assignment operator 赋值操作符<br>associated  相关的、相关联的<br>associative container 关联式容器(对应sequential container)<br>asynchronous  异步的<br>atomic    原子的<br>atomic operation   原子操作<br>attribute   特性、属性<br>authentication service 验证服务<br>authorization  授权<br>audio   音频<br>A.I.    人工智能<br>B2B integration  B2B整合、B2B集成(business-to-business integration)<br>background   背景、后台(进程)<br>backward compatible    向后兼容、向下兼容<br>backup   备份<br>backup device备份设备<br>backup file  备份文件<br>bandwidth  带宽<br>base class 基类<br>base type  基类型<br>batch   批处理<br>BCL (base class library)基类库<br>binary  二进制<br>binary search 二分查找<br>binary tree 二叉树<br>binary function  双参函数<br>binary large object二进制大对象<br>binary operator 二元操作符<br>binding 绑定<br>bit 位<br>bitmap  位图<br>bitwise 按位…<br>bitwise copy       为单元进行复制；位元逐一复制,按位拷<br>bitwise operation  按位运算<br>block  块、区块、语句块<br>bookkeeping  簿记<br>boolean 布林值(真假值，true或false)<br>border  边框<br>bounds checking 边界检查<br>boxing  装箱、装箱转换<br>brace (curly brace) 大括号、花括号<br>bracket (square brakcet) 中括号、方括号<br>breakpoint 断点<br>browser applications  浏览器应用(程序)<br>browser-accessible application  可经由浏览器访问的应用程序<br>build  编连(专指编译和连接<br>built-in  内建、内置<br>bus  总线<br>business  业务、商务(看场合)<br>business Logic 业务逻辑<br>business rules 业务规则<br>buttons  按钮<br>bug  臭虫<br>by/through 通过<br>byte  位元组(由8 bits组成)<br>cache 高速缓存<br>calendar 日历<br>call 调用<br>callback  回调<br>call-level interface (CLI)调用级接口(CLI)<br>call operator 调用操作符<br>candidate key 候选键 (for database)<br>cascading delete 级联删除 (for database)<br>cascading update 级联更新 (for database)<br>casting   转型、造型转换<br>catalog   目录<br>chain     链(function calls)<br>character 字符<br>character format  字符格式<br>character set     字符集<br>CHECK constraints CHECK约束 (for database)<br>checkpoint 检查点 (for database)<br>check box  复选框<br>check button 复选按钮<br>child class  子类<br>CIL (common intermediate language)通用中间语言、通用中介语言<br>class    类<br>class declaration  类声明<br>class definition   类定义<br>class derivation list 类继承列表<br>class factory    类厂<br>class hierarchy  类层次结构<br>class library    类库<br>class loader     类装载器<br>class template   类模板<br>class template partial specializations 类模板部分特化<br>class template specializations         类模板特化<br>classification  分类<br>clause  子句<br>client application  客户端应用程序<br>client cursor  客户端游标 (for database)<br>code page 代码页<br>cleanup   清理、清除<br>CLI (Common Language Infrastructure)   通用语言基础设施<br>client 客户、客户端<br>client area  客户区<br>client-server 客户机/服务器、客户端/服务器<br>clipboard 剪贴板<br>clone  克隆<br>CLS (common language specification) 通用语言规范<br>code access security  代码访问安全<br>COFF (Common Object File Format)    通用对象文件格式<br>collection  集合<br>COM (Component Object Model)  组件对象模型<br>combo box 组合框<br>command line 命令行<br>comment  注释<br>commit   提交 (for database)<br>communication  通讯<br>compatible 兼容<br>compile time 编译期、编译时<br>compiler 编译器<br>component组件<br>composite index 复合索引、组合索引 (for database)<br>composite key 复合键、组合键 (for database)<br>composition   复合、组合<br>concept 概念<br>concrete具体的<br>concrete class  具体类<br>concurrency 并发、并发机制<br>constraint  约束 (for database)<br>configuration 配置、组态<br>connection    连接 (for database)<br>connection pooling 连接池<br>console    控制台<br>constant   常量<br>construct  构件、成分、概念、构造（for language）<br>constructor (ctor) 构造函数、构造器<br>container  容器<br>containment包容<br>context 环境、上下文<br>control 控件<br>cookie  (不译)<br>copy    拷贝<br>CORBA   通用对象请求中介架构(Common Object Request Broker Architecture)<br>cover   覆盖、涵盖<br>create/creation    创建、生成<br>crosstab query     交叉表查询 (for database)<br>CRTP (curiously recurring template pattern)<br>CTS (common type system)通用类型系统<br>cube   多维数据集 (for database)<br>cursor 光标<br>cursor 游标 (for database)<br>custom 定制、自定义<br>data   数据<br>data connection   数据连接 (for database)<br>Data Control Language (DCL)  数据控制语言(DCL) (for database)<br>Data Definition Language (DDL) 数据定义语言(DDL) (for database)<br>data dictionary 数据字典 (for database)<br>data dictionary view  数据字典视图 (for database)<br>data file  数据文件 (for database)<br>data integrity  数据完整性 (for database)<br>data manipulation language (DML)数据操作语言(DML) (for database)<br>data mart  数据集市 (for database)<br>data pump  数据抽取 (for database)<br>data scrubbing  数据清理 (for database)<br>data source     数据源 (for database)<br>Data source name (DSN) 数据源名称(DSN) (for database)<br>data warehouse    数据仓库 (for database)<br>dataset   数据集 (for database)<br>database  数据库 (for database)<br>database catalog  数据库目录 (for database)<br>database diagram  数据关系图 (for database)<br>database file     数据库文件 (for database)<br>database object   数据库对象 (for database)<br>database owner    数据库所有者 (for database)<br>database project  数据库工程 (for database)<br>database role     数据库角色 (for database)<br>database schema  数据库模式、数据库架构 (for database)<br>database script  数据库脚本 (for database)<br>data-bound       数据绑定 (for database)<br>data-aware control数据感知控件 (for database)<br>data member   数据成员、成员变量<br>dataset       数据集 (for database)<br>data source   数据源 (for database)<br>data structure数据结构<br>data table    数据表 (for database)<br>datagram    数据报文<br>DBMS (database management system)数据库管理系统 (for database)<br>DCOM (distributed COM)分布式COM<br>dead lock  死锁 (for database)<br>deallocate 归还<br>debug      调试<br>debugger   调试器<br>decay      退化<br>decision support 决策支持<br>declaration 声明<br>declarative referential integrity (DRI)声明引用完整性(DRI) (for database)<br>deduction  推导<br>DEFAULT constraint默认约束 (for database)<br>default database  默认数据库 (for database)<br>default instance  默认实例 (for database)<br>default result set 默认结果集 (for database)<br>default     缺省、默认值<br>defer       推迟<br>definition  定义<br>delegate    委托<br>delegation  委托<br>dependent name<br>deploy       部署<br>dereference  解引用<br>dereference operator (提领)运算子<br>derived class  派生类<br>design by contract 契约式设计<br>design pattern  设计模式<br>destroy   销毁<br>destructor(dtor)析构函数、析构器<br>device   设备<br>DHTML (dynamic HyperText Markup Language)动态超文本标记语言<br>dialog   对话框<br>digest   摘要<br>digital  数字的<br>DIME (Direct Internet Message Encapsulation)直接Internet消息封装<br>directive  (编译)指示符<br>directory  目录<br>dirty pages脏页 (for database)<br>dirty read 脏读 (for database)<br>disassembler 反汇编器<br>DISCO (Discovery of Web Services)Web Services的查找<br>disk  盘<br>dispatch 调度、分派、派发（我喜欢“调度”）<br>DISPID (Dispatch Identifier)分派标识符<br>distributed computing 分布式计算<br>distributed query     分布式查询 (for database)<br>DNA (Distributed interNet Application) 分布式网间应用程序<br>document 文档<br>DOM (Document Object Model)文档对象模型<br>dot operator  (圆)点操作符<br>driver 驱动(程序)<br>DTD (document type definition)  文档类型定义<br>double-byte character set (DBCS)双字节字符集(DBCS)<br>dump       转储<br>dump file  转储文件<br>dynamic cursor    动态游标 (for database)<br>dynamic filter    动态筛选 (for database)<br>dynamic locking   动态锁定 (for database)<br>dynamic recovery  动态恢复 (for database)<br>dynamic snapshot  动态快照 (for database)<br>dynamic SQL statements 动态SQL语句 (for database)<br>dynamic assembly 动态装配件、动态配件<br>dynamic binding  动态绑定<br>EAI (enterprise application integration)企业应用程序集成(整合)<br>EBCO (empty base class optimization)   空基类优化（机制）<br>e-business   电子商务<br>EDI (Dlectronic Data Interchange)电子数据交换<br>efficiency 效率<br>efficient  高效<br>end-to-end authentication 端对端身份验证<br>end user 最终用户<br>engine   引擎<br>entity  实体<br>encapsulation   封装<br>enclosing class 外围类别(与巢状类别 nested class有关)<br>enum (enumeration) 枚举<br>enumerators 枚举成员、枚举器<br>equal       相等<br>equality    相等性<br>equality operator  等号操作符<br>error log   错误日志 (for database)<br>escape code 转义码<br>escape character 转义符、转义字符<br>exclusive lock   排它锁 (for database)<br>explicit transaction 显式事务 (for database)<br>evaluate 评估<br>event    事件<br>event driven  事件驱动的<br>event handler 事件处理器<br>evidence  证据<br>exception 异常<br>exception declaration 异常声明<br>exception handling 异常处理、异常处理机制<br>exception-safe 异常安全的<br>exception specification 异常规范<br>exit     退出<br>explicit 显式<br>explicit specialization  显式特化<br>export      导出<br>expression  表达式<br>facility    设施、设备<br>fat client  胖客户端<br>feature     特性、特征<br>fetch 提取<br>field 字段(java)<br>field 字段 (for database)<br>field length 字段长度 (for database)<br>file   文件<br>filter 筛选 (for database)<br>finalization 终结<br>firewall  防火墙<br>finalizer 终结器<br>firmware 固件<br>flag     标记<br>flash memory 闪存<br>flush 刷新<br>font  字体<br>foreign key (FK)  外键(FK) (for database)<br>form   窗体<br>formal parameter  形参<br>forward declaration  前置声明<br>forward-only  只向前的<br>forward-only cursor  只向前游标 (for database)<br>fragmentation 碎片 (for database)<br>framework  框架<br>full specialization  完全特化<br>function  函数<br>function call operator (即operator ()) 函数调用操作符<br>function object 函数对象<br>function overloaded resolution函数重载决议<br>functionality    功能<br>function template函数模板<br>functor  仿函数<br>GAC (global assembly cache) 全局装配件缓存、全局配件缓存<br>GC (Garbage collection)     垃圾回收(机制)、垃圾收集(机制)<br>game     游戏<br>generate 生成<br>generic  泛化的、一般化的、通用的<br>generic algorithm通用算法<br>genericity 泛型<br>getter (相对于 setter)取值函数<br>global        全局的<br>global object 全局对象<br>global scope resolution operator 全局范围解析操作符<br>grant       授权 (for database)<br>granularity 粒度<br>group       组、群<br>group box   分组框<br>GUI   图形界面<br>GUID (Globally Unique Identifier) 全球唯一标识符<br>hand shaking   握手<br>handle     句柄<br>handler    处理器<br>hard-coded 硬编码的<br>hard-copy  截屏图<br>hard disk  硬盘<br>hardware   硬件<br>hash table 散列表、哈希表<br>header file头文件<br>heap       堆<br>help file  帮助文件<br>hierarchy  层次结构、继承体系<br>hierarchical data 阶层式数据、层次式数据<br>hook   钩子<br>Host (application)宿主(应用程序)<br>hot key   热键<br>hyperlink 超链接<br>HTML (HyperText Markup Language) 超文本标记语言<br>HTTP pipeline  HTTP管道<br>HTTP (HyperText Transfer Protocol) 超文本传输协议<br>icon   图标<br>IDE (Integrated Development Environment)集成开发环境<br>IDL (Interface Definition Language)    接口定义语言<br>identifier 标识符<br>idle time  空闲时间<br>if and only if当且仅当<br>IL (Intermediate Language) 中间语言、中介语言<br>image 图象<br>IME   输入法<br>immediate base      直接基类<br>immediate derived   直接派生类<br>immediate updating  即时更新 (for database)<br>implicit transaction隐式事务 (for database)<br>incremental update  增量更新 (for database)<br>index          索引 (for database)<br>implement      实现<br>implementation 实现、实现品<br>implicit       隐式<br>import         导入<br>increment operator  增加操作符<br>infinite loop       无限循环<br>infinite recursive  无限递归<br>information      信息<br>infrastructure   基础设施<br>inheritance      继承、继承机制<br>inline           内联<br>inline expansion 内联展开<br>initialization   初始化<br>initialization list 初始化列表、初始值列表<br>initialize      初始化<br>inner join      内联接 (for database)<br>in-place active 现场激活<br>instance        实例<br>instantiated    具现化、实体化(常应用于template)<br>instantiation   具现体、具现化实体(常应用于template)<br>integrate       集成、整合<br>integrity       完整性、一致性<br>integrity constraint完整性约束 (for database)<br>interprocess communication (IPC)进程间通讯(IPC)<br>interacts  交互<br>interface  接口<br>  for GUI  界面<br>interoperability 互操作性、互操作能力<br>interpreter   解释器<br>introspection 自省<br>invariants    不变性<br>invoke        调用<br>isolation level  隔离级别 (for database)<br>iterate   迭代<br>iterative 反复的、迭代的<br>iterator  迭代器<br>iteration 迭代(回圈每次轮回称为一个iteration)<br>item      项、条款、项目<br>JIT compilation  JIT编译 即时编译<br>key          键 (for database)<br>key column   键列 (for database)<br>laser        激光<br>late binding 迟绑定<br>left outer join  左向外联接 (for database)<br>level      阶、层例<br>high level 高阶、高层<br>library    库<br>lifetime   生命期、寿命<br>link       连接、链接<br>linkage    连接、链接<br>linker     连接器、链接器<br>literal constant 字面常数<br>list   列表、表、链表<br>list box 列表框<br>livelock 活锁 (for database)<br>load   装载、加载<br>load balancing  负载平衡<br>loader 装载器、载入器<br>local  局部的<br>local object    局部对象<br>lock  锁<br>log   日志<br>login 登录<br>login security mode登录安全模式 (for database)<br>lookup table   查找表 (for database)<br>loop           循环<br>loose coupling 松散耦合<br>lvalue         左值<br>machine code   机器码、机器代码<br>macro        宏<br>maintain     维护<br>managed code 受控代码、托管代码<br>Managed Extensions 受控扩充件、托管扩展<br>managed object 受控对象、托管对象<br>mangled name<br>manifest     清单<br>manipulator  操纵器(iostream预先定义的一种东西)<br>many-to-many relationship 多对多关系 (for database)<br>many-to-one relationship  多对一关系 (for database)<br>marshal  列集<br>member   成员<br>member access operator    成员取用运算子(有dot和arrow两种)<br>member function           成员函数<br>member initialization list成员初始值列表<br>memberwise  以member为单元…、members 逐一…<br>memberwise copy<br>memory      内存<br>memory leak 内存泄漏<br>menu     菜单<br>message  消息<br>message based  基于消息的<br>message loop   消息环<br>message queuing消息队列<br>metadata 元数据<br>metaprogramming元编程<br>method 方法<br>micro  微<br>middleware  中间件<br>middle tier 中间层<br>modeling    建模<br>modeling language 建模语言<br>modifier  修饰字、修饰符<br>modem     调制解调器<br>module    模块<br>most derived class最底层的派生类<br>mouse   鼠标<br>mutable 可变的<br>mutex   互斥元、互斥体<br>multidimensional OLAP (MOLAP)    多维OLAP(MOLAP) (for database)<br>multithreaded server application 多线程服务器应用程序<br>multiuser       多用户<br>multi-tasking   多任务<br>multi-thread    多线程<br>multicast delegate 组播委托、多点委托<br>named parameter    命名参数<br>named pipe  命名管道<br>namespace   名字空间、命名空间<br>native      原生的、本地的<br>native code 本地码、本机码<br>Native Image Generator (NGEN)本地映像生成器<br>nested class  嵌套类<br>nested query  嵌套查询 (for database)<br>nested table  嵌套表 (for database)<br>network       网络<br>network card  网卡<br>nondependent name<br>object        对象<br>object based  基于对象的<br>object file   目标文件<br>object model  对象模型<br>object oriented 面向对象的<br>object pooling  对象池化<br>ODBC data source ODBC数据源 (for database)<br>ODBC driver      ODBC驱动程序 (for database)<br>ODR (one-definition rule)<br>OLE Automation objects   OLE自动化对象 (for database)<br>OLE Automation server    OLE自动化服务器 (for database)<br>OLE DB consumer  OLE DB使用者 (for database)<br>OLE DB for OLAP  用于OLAP的OLE DB (for database)<br>OLE DB provider  OLE DB提供者 (for database)<br>one-to-many relationship 一对多关系 (for database)<br>one-to-one relationship  一对一关系 (for database)<br>online analytical processing (OLAP)    联机分析处理(OLAP) (for database)<br>online redo log     联机重做日志 (for database)<br>online transaction processing (OLTP)   联机事务处理(OLTP) (for database)<br>Open Data Services (ODS)   开放式数据服务(ODS) (for database)<br>Open Database Connectivity (ODBC) 开放式数据库连接(ODBC) (for database)<br>operand   操作数<br>operating system (OS) 操作系统<br>operation  操作<br>operator   操作符、运算符<br>option     选项<br>optimizer  优化器<br>outer join 外联接 (for database)<br>overflow   上限溢位(相对于underflow)<br>overhead   额外开销<br>overload   重载<br>overload resolution   重载决议<br>overloaded function   重载的函数<br>overloaded operator  被重载的操作符<br>override   覆写、重载、重新定义<br>package    包<br>packaging  打包<br>palette    调色板<br>parallel   并行<br>parameter  参数、形式参数、形参<br>parameter list 参数列表<br>parameterize   参数化<br>parent class   父类<br>parentheses    圆括弧、圆括号<br>parse    解析<br>parser   解析器<br>part     零件、部件<br>partial specialization 局部特化<br>pass by address   传址(函式引数的传递方式)(非正式用语)<br>pass by reference 传地址、按引用传递<br>pass by value 按值传递<br>pattern       模式<br>PDA (personal digital assistant)个人数字助理<br>PE (Portable Executable) file   可移植可执行文件<br>performance   性能<br>persistence   持久性<br>PInvoke (platform invoke service) 平台调用服务<br>pixel  像素<br>placement delete<br>placement new<br>placeholder 占位符<br>platform    平台<br>POD (plain old data (type))<br>POI (point of instantiation)<br>pointer  指针<br>poll     轮询<br>pooling  池化<br>polymorphism  多态<br>pop up     弹出式<br>port       端口<br>postfix    后缀<br>precedence 优先序(通常用于运算子的优先执行次序)<br>prefix     前缀<br>preprocessor    预处理器<br>primary key (PK)主键(PK)  (for database)<br>primary table   主表 (for database)<br>primary template原始模板<br>primitive type  原始类型<br>print      打印<br>printer    打印机<br>procedure  过程<br>procedural 过程式的、过程化的<br>process    进程<br>profile    评测<br>profiler   效能(性能)评测器<br>program    程序<br>programmer 程序员<br>programming编程、程序设计<br>progress bar 进度指示器<br>project    项目、工程<br>property   属性<br>protocol   协议<br>pseudo code伪码<br>qualified  经过资格修饰(例如加上scope运算子)<br>qualified name<br>qualifier 修饰符<br>quality   质量<br>queue     队列<br>race condition 竞争条件（多线程环境常用语）<br>radian         弧度<br>radio button   单选按钮<br>raise          引发(常用来表示发出一个exception)<br>random number  随机数<br>range   范围、区间<br>rank    等级<br>raw     未经处理的<br>readOnly只读<br>record  记录 (for database)<br>recordset  记录集 (for database<br>recursive  递归<br>re-direction  重定向<br>refactoring   重构<br>refer     引用、参考<br>reference 引用、参考<br>reference counting引用计数<br>referential integrity (RI)引用完整性(RI) (for database)<br>register     寄存器<br>reflection   反射<br>refresh data 刷新数据 (for database)<br>regular expression  正则表达式<br>relational database 关系数据库<br>remote         远程<br>remote request 远程请求<br>represent      表述，表现<br>resolve        解析、决议<br>resolution     解析过程<br>result set     结果集 (for database)<br>retrieve data  检索数据<br>return         返回<br>return type    返回类型<br>return value   返回值<br>right outer join  右向外联接 (for database)<br>revoke       撤销<br>robust       健壮<br>robustness   健壮性<br>roll back    回滚 (for database)<br>roll forward 前滚 (for database)<br>routine      例程<br>row          行 (for database)<br>row lock     行锁 (for database)<br>rowset       行集 (for database)<br>RPC (remote procedure call)RPC(远程过程调用)<br>runtime 执行期、运行期、执行时、运行时<br>rvalue  右值<br>save    保存<br>savepoint  保存点 (for database)<br>SAX (Simple API for XML)<br>scalable  可伸缩的、可扩展的<br>schedule  调度<br>scheduler 调度程序<br>schema    模式、纲目结构<br>scroll bar滚动条<br>scope     作用域、生存空间<br>scope operator 生存空间操作符<br>scope resolution operator 生存空间解析操作符<br>screen   屏幕<br>SDK (Software Development Kit)软件开发包<br>sealed class 密封类<br>search    查找<br>semantics 语义<br>semaphore 信号量<br>sequential container序列式容器<br>server    服务器、服务端<br>serial    串行<br>serialization/serialize 序列化<br>server cursor服务端游标、服务器游标 (for database)<br>session      会话 (for database)<br>setter       设值函数<br>shared lock  共享锁 (for database)<br>sibling      同级<br>side effect  副作用<br>signature    签名<br>single-threaded  单线程<br>slider滑块<br>slot  槽<br>smart pointer 智能指针<br>SMTP (Simple Mail Transfer Protocol)   简单邮件传输协议<br>snapshot       截屏图<br>snapshot       快照 (for database)<br>specialization 特化<br>specification  规范、规格<br>splitter       切分窗口<br>SOAP (simple object access protocol)   简单对象访问协议<br>software      软件<br>source code   源码、源代码<br>SQL (Structured Query Language)  结构化查询语言 (for database)<br>stack  栈、堆栈<br>stack unwinding   叠辗转开解(此词用于exception主题)<br>standard library  标准库<br>standard template library 标准模板库<br>stateless 无状态的<br>statement 语句、声明<br>static cursor 静态游标 (for database)<br>static SQL statements 静态SQL语句 (for database)<br>stored procedure 存储过程 (for database)<br>status bar 状态条<br>stream   流<br>string   字符串<br>stub     存根<br>subobject子对象<br>subquery 子查询 (for database)<br>subroutine  子例程<br>subscript operator 下标操作符<br>subset   子集<br>subtype  子类型<br>support  支持<br>suspend  挂起<br>symbol   记号<br>syntax   语法<br>system databases   系统数据库 (for database)<br>system tables      系统表 (for database)<br>table       表 (for database)<br>table lock  表锁 (for database)<br>table-level constraint 表级约束 (for database)<br>tape backup  磁带备份 (for database)<br>target  标的,目标<br>task switch  工作切换<br>TCP (Transport Control Protocol)       传输控制协议<br>template       模板<br>template-id<br>template argument deduction      模板参数推导<br>template explicit specialization 模板显式特化<br>template parameter   模板参数<br>template template parameter<br>temporary object 临时对象<br>temporary table  临时表 (for database)<br>text 文本<br>text file   文本文件<br>thin client 瘦客户端<br>third-party 第三方<br>thread      线程<br>thread-safe 线程安全的<br>throw 抛出、引发(常指发出一个exception)<br>token 符号、标记、令牌（看场合）<br>trace 跟踪<br>transaction 事务 (for database)<br>transaction log  事务日志 (for database)<br>transaction rollback  事务回滚 (for database)<br>transactional replication  事务复制 (for database)<br>translation unit 翻译单元<br>traverse 遍历<br>trigger  触发器 (for database)<br>two-phase commit 两阶段提交 (for database)<br>tuple<br>two-phase lookup 两阶段查找<br>type  类型<br>UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成<br>UML (unified modeling language)统一建模语言<br>unary function 单参函数<br>unary operator 一元操作符<br>unboxing       拆箱、拆箱转换<br>underflow      下限溢位(相对于overflow)<br>Union query    联合查询 (for database)<br>UNIQUE constraints  UNIQUE约束 (for database)<br>unique index   唯一索引 (for database)<br>unmanaged code 非受控代码、非托管代码<br>unmarshal      散集<br>unqualified     未经限定的、未经修饰的<br>URI (Uniform Resource identifier) 统一资源标识符<br>URL (Uniform Resource Locator)    统一资源定位器<br>user            用户<br>user interface  用户界面<br>value types 值类型<br>variable 变量<br>vector   向量(一种容器，有点类似array)<br>viable   可行的<br>video    视频<br>view     视图<br>VEE (Virtual Execution Engine)虚拟执行引擎<br>vendor  厂商<br>view    视图 (for database)<br>virtual function  虚函数<br>virtual machine   虚拟机<br>virtual memory    虚拟内存<br>vowel          元音字母<br>Web Services   web服务<br>WHERE clause   WHERE子句 (for database)<br>wildcard characters 通配符字符 (for database)<br>wildcard search     通配符搜索 (for database)<br>window function     窗口函数<br>window procedure    窗口过程<br>Windows authentication Windows身份验证<br>wizard  向导<br>word processor  字处理器<br>wrapper      包装、包装器<br>write enable 写启用 (for database)<br>write-ahead log 预写日志 (for database)<br>WSDL (Web Service Description Language)Web Service描述语言<br>XML Message Interface (XMI)       XML消息接口<br>XML (eXtensible Markup Language)  可扩展标记语言<br>XSD (XML Schema Definition)       XML模式定义语言<br>XSL (eXtensible Stylesheet Language) 可扩展样式表语言<br>XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换<br>xxx based     基于xxx的<br>xxx oriented  面向xxx<br>)</p>
<p>##编程英语：<br>access               vt.访问,存取 [‘?kses]’(n.入口,使用权)<br>algorithm            n.算法 [‘?lg?riem]<br>Annotation   [java] 代码注释 [?n?u’tei??n]<br>anonymous            adj.匿名的[?’n?nim?s]’(反义：directly adv.直接地,立即[di’rektli, dai’rektli])<br>apply                v.应用,适用 [?’plai]<br>application          n.应用,应用程序 [,?pli’kei??n]’ (application crash 程序崩溃)<br>arbitrary            a.任意的 [‘ɑ:bitr?ri]<br>argument             n.参数;争论,论据 [‘ɑ:gjum?nt]’(缩写 args)<br>assert       (关键字) 断言 [?’s?:t] ‘ (java 1.4 之后成为关键字)<br>associate            n.关联(同伴,伙伴) [?’s?u?ieit]<br>attribute            n.属性(品质,特征) [?’tribju:t]<br>boolean      (关键字) 逻辑的, 布尔型<br>call                 n.v.调用; 呼叫; [k?:l]<br>circumstance         n.事件(环境,状况) [‘s?:k?mst?ns]<br>crash                n.崩溃,破碎 [kr??]<br>cohesion             内聚,黏聚,结合 [k?u’hi:??n]<br>                     (a class is designed with a single, well-focoused purpose. 应该不止这点)<br>command              n. 命令,指令 <a href="指挥, 控制">k?’mɑ:nd</a> (command-line 命令行)<br>Comments     [java] 文本注释 [‘k?ments]<br>compile      [java] v.编译 [k?m’pail]’ Compilation n.编辑[,k?mpi’lei??n]<br>const        (保留字)<br>constant             n. 常量, 常数, 恒量 [‘k?nst?nt]<br>continue     (关键字)<br>coupling             耦合,联结 [‘k?pli?]<br>                     making sure that classes know about other classes only through their APIs.<br>declare      [java] 声明 [di’kl??]<br>default      (关键字) 默认值; 缺省值 [di’f?:lt]<br>delimiter            定义符; 定界符<br>Encapsulation[java] 封装 (hiding implementation details)<br>Exception    [java] 例外; 异常 [ik’sep??n]<br>entry                n.登录项, 输入项, 条目[‘entri]<br>enum         (关键字)<br>execute              vt.执行 [‘eksikju:t]<br>exhibit              v.显示, 陈列 [ig’zibit]<br>extends      (关键字) 继承、扩展 [ik’stend]<br>false        (关键字)<br>final        (关键字) finally (关键字)<br>fragments            段落; 代码块 [‘fr?gm?nt]<br>FrameWork    [java] 结构,框架 [‘freimw?:k]<br>Generic      [java] 泛型 [d?i’nerik]<br>goto         (保留字) 跳转<br>heap                 n.堆 [hi:p]<br>implements   (关键字) 实现 [‘implim?nt]<br>Inheritance [java] 继承 [in’herit?ns] (遗传,遗产)<br>initialize           预置 初始化 [i’ni??laiz]<br>instanceof   (关键字) 运算符，用于引用变量，以检查这个对象是否是某种类型。返回<br>invoke               vt.调用 [in’v?uk]’ ( invocation [,inv?u’kei??n])<br>Iterator     [java] 迭代器, 迭代程序<br>log                  n.日志,记录 [l?g]<br>native       (关键字) ？？ [‘neitiv]<br>nested       [java] 嵌套的 [‘nestid] ‘如：内部类(nested classes)<br>Overload     [java] 方法的重载(不同参数列表的同名方法) [,?uv?’l?ud]<br>Override     [java] 方法的覆盖(覆盖父类的方法) [,?uv?’raid]<br>polymiorphism[java] 多态 (polymorphism 多形性[,p?li’m?:fizm])<br>                     allowing a single object to be seen as having many types.<br>principle            n.原则,原理,主义 [‘prinsipl]<br>priority             n. 优先级 [prai’?riti]<br>process              n. 程序, 进程 [‘pr?ses]<br>protected    (关键字) 受保护的,私有的 [pr?’tektid]<br>provide              v.规定(供应,准备,预防)[pr?’vaid]用变量<br>Reflection   [java] 反射 [ri’flek??n]<br>script               n.手写体,小型程序 [skript]<br>serialized           vt.序列化,串行化 [‘si?ri?laiz]’(serializable adj.)(deserialize反序列化,反串行化)<br>Socket       [java] 网络套接字[‘s?kit]<br>stack                n.堆栈 [st?k] (对应 heap 堆)<br>statement            程序语句; 语句 [‘steitm?nt]’ n. 陈述,指令<br>subclass             n.子类 [‘s?bklɑ:s]’ (supertype 父类)<br>synchronized (关键字) 同步(锁) [‘si?kr?naiz]<br>Thread       [java] 线程 [θred]<br>throw        (关键字) throws (关键字) [θr?u] 抛出(异常)<br>transient    (关键字) 瞬变;临时的[‘tr?nzi?nt]’(可序列化)<br>valid                正确的,有效的 [‘v?lid]<br>variable             n.变量 a.可变的[‘v??ri?bl]<br>volatile     (关键字) 不稳定的[‘v?l?tail]<br>access               vt.访问,存取 [‘?kses]’(n.入口,使用权)<br>algorithm            n.算法 [‘?lg?riem]<br>Annotation   [java]  代码注释 [?n?u’tei??n]<br>anonymous            adj.匿名的[?’n?nim?s]’(反义：directly adv.直接地,立即[di’rektli, dai’rektli])<br>arbitrary            a.任意的 [‘ɑ:bitr?ri]<br>argument             n.参数;争论,论据 [‘ɑ:gjum?nt]’(缩写 args)<br>assert       (关键字) 断言 [?’s?:t] ‘ (java 1.4 之后成为关键字)<br>associate            n.关联(同伴,伙伴) [?’s?u?ieit]<br>attribute            n.属性(品质,特征) [?’tribju:t]<br>call                 n.v.调用; 呼叫; [k?:l]<br>circumstance         n.事件(环境,状况)  [‘s?:k?mst?ns]<br>crash                n.崩溃,破碎 [kr??]<br>cohesion             内聚,黏聚,结合 [k?u’hi:??n]<br>                     (a class is designed with a single, well-focoused purpose. 应该不止这点)<br>command              n. 命令,指令 <a href="指挥, 控制">k?’mɑ:nd</a> (command-line 命令行)<br>Comments     [java]  文本注释 [‘k?ments]<br>compile      [java]  v.编译 [k?m’pail]’  Compilation n.编辑[,k?mpi’lei??n]<br>const        (保留字)<br>constant             n. 常量, 常数, 恒量 [‘k?nst?nt]<br>coupling             耦合,联结 [‘k?pli?]<br>                     making sure that classes know about other classes only through their APIs.<br>default      (关键字) 默认值; 缺省值 [di’f?:lt]<br>delimiter            定义符; 定界符<br>Encapsulation[java]  封装 (hiding implementation details)<br>entry                n.登录项, 输入项, 条目[‘entri]<br>enum         (关键字)<br>execute              vt.执行 [‘eksikju:t]<br>exhibit              v.显示, 陈列 [ig’zibit]<br>fragments            段落; 代码块 [‘fr?gm?nt]<br>FrameWork    [java]  结构,框架 [‘freimw?:k]<br>Generic      [java]  泛型  [d?i’nerik]<br>goto         (保留字) 跳转<br>heap                 n.堆 [hi:p]<br>implements   (关键字) 实现 [‘implim?nt]<br>Inheritance  [java]  继承 [in’herit?ns] (遗传,遗产)<br>initialize           预置 初始化 [i’ni??laiz]<br>instanceof   (关键字) 运算符，用于引用变量，以检查这个对象是否是某种类型。返回 boolean 值。<br>interface    (关键字) 接口 [‘int?feis]<br>invoke               vt.调用 [in’v?uk]’  ( invocation [,inv?u’kei??n])<br>Iterator     [java]  迭代器, 迭代程序<br>log                  n.日志,记录 [l?g]<br>native       (关键字) ？？ [‘neitiv]<br>nested       [java]  嵌套的 [‘nestid] ‘如：内部类(nested classes)<br>Object       [java]  对象 [‘?bd?ekt]<br>Overload     [java]  方法的重载(不同参数列表的同名方法) [,?uv?’l?ud]<br>Override     [java]  方法的覆盖(覆盖父类的方法) [,?uv?’raid]<br>polymiorphism[java]  多态 (polymorphism 多形性[,p?li’m?:fizm])<br>                     allowing a single object to be seen as having many types.<br>引用变量<br>Reflection   [java]  反射 [ri’flek??n]<br>script               n.手写体,小型程序 [skript]<br>serialized           vt.序列化,串行化 [‘si?ri?laiz]’(serializable adj.)(deserialize反序列化,反串行化)<br>Socket       [java]  网络套接字[‘s?kit]<br>stack                n.堆栈 [st?k] (对应 heap 堆)<br>statement            程序语句; 语句 [‘steitm?nt]’ n. 陈述,指令<br>subclass             n.子类 [‘s?bklɑ:s]’ (supertype 父类)<br>synchronized (关键字) 同步(锁) [‘si?kr?naiz] </p>
<p>transient    (关键字) 瞬变;临时的[‘tr?nzi?nt]’(可序列化)<br>valid                正确的,有效的 [‘v?lid]<br>variable             n.变量 a.可变的[‘v??ri?bl]<br>volatile     (关键字) 不稳定的[‘v?l?tail]<br>while        (关键字) 循环语句。 当…的时候 [hwail]</p>
<p>argument 参量  abstract 抽象ascent 提升  already 已经  AWT(Abstract Window Toolkit)抽象窗口工具  API(Application Programming Interface)应用程序接口<br>buffer缓冲器  button 按钮  break  中断  body 身体<br>C.  count 计数  client 客户  code 代码calculation 计算  cell 单元container容器  component 组件  command 命令 cube立方,三次方 char(=character)字符  cancel取消 case 情况 choice选择 click单击 center 中心 compile编译  clone克隆，复制  continue 继续 create建立<br>D. draw 绘图 data数据 demo 示例 DLL(Dynamic Link Library)动态链接库  document 文档  descent 继承  division 分裂，除法extends 扩展  executed 执行    Echo 重复<br>  final 终结的  font 字体  factorial 阶乘<br>G. graphic 图像 grid 方格  GUI图形化用户接口  get 得到<br>H. host 主机  height 高度<br>I. init(=initialize)初始化  input 输入  implement  实现  instance 实例  io(=input/output)输出输入  interrupted  中断  int(=integer)整型  item元素 interface 接口 inner 内部的index 索引image 图像<br>JDK(Java Development Kit) Java开发工具 JSP(Java Server Page) Java服务页 JVM(Java Virtual Machine) Java虚拟机<br>K. Kit 工具<br>loop 循环 long 长整型 label 标签 layout 布局 list 列表 listener 收听者<br>M. metric 米的，公尺 motion 运动 manager 经理 main 主要的 msg(=message) 消息<br>native 本地的<br>O. override 过载 orange 橘子 output 输出 object 对象 out 外部的 oval 椭圆<br>P. public 公共的 protected 保护的 private 私有的 property 属性problem 问题 package 打包，包裹 print 打印 path 路径 po;ygon 多边形prompt 提示 parse 分析 press 按，压 panel 面板 paint 画<br>Q. q无<br>R. runnable 可捕获的 radius 半径 round 环绕 release 释放 rect(=rectangle)长方形 radio 无线电 resolve 解析<br>S seed 种子 seasonal 季节的super 超级 square 平方，二次方 sub 替代的 screen 屏幕 sound声音 state 状态status 状态 synchronize 同步发生stream 流 symbol 符号<br>T temp(=temporary)暂时的 throw 扔 thread 线程 temperate 温度<br>U. undefined 未定义 UI(User Interface) 用户接口 update 更新 URL(Uniform Resource Locator) 统一资源定位器<br>V. volatile 挥发性 visible 不可见的 virtual 虚拟的 variable 变量 value 数值 void 无返回值的 volume 列 viewer 观察者 vector 矢量</p>
<p>##我喜欢「式」：<br>constructor 建构式<br>declaration 宣告式<br>definition 定义式<br>destructor 解构式<br>expression 算式（运算式）<br>function 函式<br>pattern 范式、模式、样式<br>program 程式<br>signature 标记式（签名式/署名式） </p>
<h2 id="我喜欢「件」：（这是个弹性非常大的可组合字）"><a href="#我喜欢「件」：（这是个弹性非常大的可组合字）" class="headerlink" title="我喜欢「件」：（这是个弹性非常大的可组合字）"></a>我喜欢「件」：（这是个弹性非常大的可组合字）</h2><p>assembly （装）配件<br>component 组件<br>construct 构件<br>control 控件<br>hardware 硬件<br>object 物件<br>part 零件、部件<br>singleton 单件 </p>
<h2 id="我喜欢「器」："><a href="#我喜欢「器」：" class="headerlink" title="我喜欢「器」："></a>我喜欢「器」：</h2><p>adapter 配接器<br>allocator 配置器<br>compiler 编译器<br>container 容器<br>iterator 迭代器<br>linker 连结器<br>listener 监听器<br>interpreter 直译器<br>translator 转译器/翻译器 </p>
<h2 id="我喜欢「化」："><a href="#我喜欢「化」：" class="headerlink" title="我喜欢「化」："></a>我喜欢「化」：</h2><p>generalized 泛化<br>specialized 特化<br>overloaded 多载化（重载） </p>
<h2 id="我喜欢「型」："><a href="#我喜欢「型」：" class="headerlink" title="我喜欢「型」："></a>我喜欢「型」：</h2><p>polymorphism 多型<br>genericity 泛型<br>programming 编程 </p>
<h2 id="英中繁简编程术语对照"><a href="#英中繁简编程术语对照" class="headerlink" title="英中繁简编程术语对照"></a>英中繁简编程术语对照</h2><p>define 定义 预定义<br>access 存取、取用 存取、访问<br>access level 存取级别 访问级别<br>access function 存取函式 访问函数<br>activate 活化 激活<br>active 作用中的<br>adapter 配接器 适配器<br>address space 位址空间，定址空间<br>address-of operator 取址运算子 取地址操作符<br>aggregation 聚合<br>algorithm 演算法 算法<br>allocate 配置 分配<br>allocator （空间）配置器 分配器<br>application 应用程式 应用、应用程序<br>application framework 应用程式框架、应用框架 应用程序框架<br>architecture 架构、系统架构 体系结构<br>argument 引数（传给函式的值）。叁见 parameter 叁数、实质叁数、实叁、自变量<br>array 阵列 数组<br>arrow operator arrow（箭头）运算子 箭头操作符<br>assembly 装配件<br>assembly language 组合语言 汇编语言<br>assert(ion) 断言<br>assign 指派、指定、设值、赋值 赋值<br>assignment 指派、指定 赋值、分配<br>assignment operator 指派（赋值）运算子 = 赋值操作符<br>associated 相应的、相关的 相关的、关联、相应的<br>associative container 关联式容器（对应 sequential container） 关联式容器<br>atomic 不可分割的 原子的<br>attribute 属性 属性、特性<br>audio 音讯 音频<br>A.I. 人工智慧 人工智能<br>background 背景 背景（用於图形着色）<br>後台（用於行程）<br>backward compatible 回溯相容 向下兼容<br>bandwidth 频宽 带宽<br>base class 基础类别 基类<br>base type 基础型别 (等同於 base class)<br>batch 批次（意思是整批作业） 批处理<br>benefit 利益 收益<br>best viable function 最佳可行函式 最佳可行函式<br>（从 viable functions 中挑出的最佳吻合者）<br>binary search 二分搜寻法 二分查找<br>binary tree 二元树 二叉树<br>binary function 二元函式 双叁函数<br>binary operator 二元运算子 二元操作符<br>binding 系结 绑定<br>bit 位元 位<br>bit field 位元栏 ? 位域<br>bitmap 位元图 ? 位图<br>bitwise 以 bit 为单元逐一┅ ?<br>bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝<br>block 区块,区段 块、区块、语句块<br>boolean 布林值（真假值，true 或 false） 布尔值<br>border 边框、框线 边框<br>brace(curly brace) 大括弧、大括号 花括弧、花括号<br>bracket(square brakcet) 中括弧、中括号 方括弧、方括号<br>breakpoint 中断点 断点<br>build 建造、构筑、建置（MS 用语）<br>build-in 内建 内置<br>bus 汇流排 总线<br>business 商务,业务 业务<br>buttons 按钮 按钮<br>cache 快取 高速缓存<br>call 呼叫、叫用 调用<br>callback 回呼 回调<br>call operator call（函式呼叫）运算子 () 调用操作符<br>（同 function call operator）<br>candidate function 候选函式 候选函数<br>（在函式多载决议程序中出现的候选函式）<br>chain 串链（例 chain of function calls） 链<br>character 字元 字符<br>check box 核取方块 (i.e. check button) 复选框<br>checked exception 可控式异常(Java)<br>check button 方钮 (i.e. check box) 复选按钮<br>child class 子类别（或称为derived class, subtype） 子类<br>class 类别 类<br>class body 类别本体 类体 ?<br>class declaration 类别宣告、类别宣告式 类声明<br>class definition 类别定义、类别定义式 类定义<br>class derivation list 类别衍化列 类继承列表<br>class head 类别表头 类头 ?<br>class hierarchy 类别继承体系, 类别阶层 类层次体系<br>class library 类别程式库、类别库 类库<br>class template 类别模板、类别范本 类模板<br>class template partial specializations<br>类别模板偏特化 类模板部分特化<br>class template specializations<br>类别模板特化 类模板特化<br>cleanup 清理、善後 清理、清除<br>client 客端、客户端、客户 客户<br>client-server 主从架构 客户/服务器<br>clipboard 剪贴簿 剪贴板</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 英语 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java网络编程学习笔记]]></title>
      <url>/2015/11/coding/Java-%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>网络编程：用Java语言实现计算机间数据的信息传递和资源共享</p>
<h2 id="网络编程模型"><a href="#网络编程模型" class="headerlink" title="网络编程模型"></a>网络编程模型</h2><p>OSI七层模型：<br>    物理层<br>    数据链路层<br>    网络层<br>    传输层<br>    传话层<br>    表示层<br>    应用层<br><a id="more"></a></p>
<h2 id="网络编程的三要素"><a href="#网络编程的三要素" class="headerlink" title="网络编程的三要素"></a>网络编程的三要素</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>点分十进制（一个字节0~255）<br>IP地址的分类：分ABCD共5类</p>
<p>特殊的IP地址：<br>127.0.0.1 本机地址<br>x.x.x.255 广播地址<br>x.x.x.0 网络地址<br>InetAddress类（略）</p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>是应用程序的标识。范围：0-65535。其中0-1024不建议使用。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>UDP:数据打包,有限制,不连接,效率高,不可靠<br>TCP:建立数据通道,无限制,效率低,可靠</p>
<h2 id="Socket机制"><a href="#Socket机制" class="headerlink" title="Socket机制"></a>Socket机制</h2><p>网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。<br>通信两端都应该有Socket对象、<br>所有的通信都是通过Socket间的IO进行操作的</p>
<h2 id="UDP协议发送和接收数据"><a href="#UDP协议发送和接收数据" class="headerlink" title="UDP协议发送和接收数据("></a>UDP协议发送和接收数据(</h2><p>使用的是<code>DatagramSocket</code>类</p>
<h3 id="发送："><a href="#发送：" class="headerlink" title="发送："></a>发送：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Socket对象</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据并把数据打包</span></span><br><span class="line"><span class="comment">//DatagramPacket(byte[]. int length, InetAddress address, int port);</span></span><br><span class="line"><span class="keyword">byte</span>[] bys = <span class="string">"Wente Guo"</span>.getBytes();</span><br><span class="line"><span class="keyword">int</span> length = bys.length;</span><br><span class="line">InetAddress address = InetAddress.getByName(<span class="string">"192.168.31.1"</span>);</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">10010</span>;</span><br><span class="line">DatagramSocket dp = <span class="keyword">new</span> DatagramSocket (bys, length, address, port);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">da.send(dp)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure>
<h3 id="接收："><a href="#接收：" class="headerlink" title="接收："></a>接收：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建UDP接收端的Socket对象</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">10010</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据包（容器）用于接收数据</span></span><br><span class="line"><span class="comment">//DatagramPacket(byte[] buf, int length) 这个用来接收的</span></span><br><span class="line"><span class="keyword">byte</span>[] bys = <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> length =bys.length;</span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">ds.receive(dp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析数据包举例——获取对方的IP</span></span><br><span class="line">InetAddress address = dp.Address();</span><br><span class="line">String ip = address.getAddress();</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析数据包举例——获取数据缓冲区及数据的实际长度</span></span><br><span class="line"><span class="keyword">byte</span>[] bys2 = dp.getDada();</span><br><span class="line"><span class="keyword">int</span> len = dp.gatLength();</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure>
<h2 id="TCP协议发送和接收数据"><a href="#TCP协议发送和接收数据" class="headerlink" title="TCP协议发送和接收数据"></a>TCP协议发送和接收数据</h2><h3 id="接收：-1"><a href="#接收：-1" class="headerlink" title="接收："></a>接收：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建TCP服务器端的Socket对象</span></span><br><span class="line">ServerSocket ss = <span class="keyword">new</span> ServerSocket (<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听客户端连接,返回一个对应的Socket对象</span></span><br><span class="line">Socket socket = ss.accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取输入流，读取数据,显示在控制台</span></span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bys = <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> length =is.read(bys)；</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">socket.close();<span class="comment">//注意：关闭的是客户端，不是服务器</span></span><br></pre></td></tr></table></figure>
<h3 id="发送：-1"><a href="#发送：-1" class="headerlink" title="发送："></a>发送：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建TCP客户端的Socket对象</span></span><br><span class="line">Socket s = <span class="keyword">new</span> Socket (<span class="string">"192.168.12.92"</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取输出流，写数据</span></span><br><span class="line">OutputStream os = s.getOutputStream();</span><br><span class="line">os.write (<span class="string">"Hello, I'm Wente Guo"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">s.close();</span><br></pre></td></tr></table></figure>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaIO流学习笔记及总结]]></title>
      <url>/2015/11/coding/Java-%E7%AC%94%E8%AE%B0-IO%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>IO用于在设备间进行数据传输的操作。</p>
<h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><p>A:以流向分<br>输入流    读取数据<br>输出流    写出数据<br>B:以数据类型分<br>字节流<br>字节输入流<br>字节输出流<br>字符流<br>字符输入流<br>字符输出流<br><a id="more"></a><br><strong>注意</strong><br>a:如果我们没有明确说明按照什么分，默认按照数据类型分。<br>b:除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使 用字节流。</p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="FileOutputStream写出数据"><a href="#FileOutputStream写出数据" class="headerlink" title="FileOutputStream写出数据"></a>FileOutputStream写出数据</h3><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><p>1.创建字节输出流对象<br>2.调用write()方法<br>3.释放资源</p>
<h4 id="代码体现："><a href="#代码体现：" class="headerlink" title="代码体现："></a>代码体现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line">fos.write(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<h4 id="要注意的问题："><a href="#要注意的问题：" class="headerlink" title="要注意的问题："></a>要注意的问题：</h4><p>a:创建字节输出流对象做了几件事情?（略）<br>b:为什么要close()? 释放内存资源。<br>c:如何实现数据的换行?<br>注意，不同的系统的换行是不同的：<br><code>windows \r\n</code><br><code>Linux \n</code><br><code>OS X   \n</code><br>d:如何实现数据的追加写入?<br>使用<code>new FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;,ture);</code></p>
<h3 id="FileInputStream读取数据"><a href="#FileInputStream读取数据" class="headerlink" title="FileInputStream读取数据"></a>FileInputStream读取数据</h3><h4 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h4><p>1.创建字节输入流对象<br>2.调用read()方法<br>3.释放资源</p>
<h4 id="代码Demo："><a href="#代码Demo：" class="headerlink" title="代码Demo："></a>代码Demo：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">int</span> by = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((by=fis.read())!=-<span class="number">1</span>) &#123;     <span class="comment">//注意：容易掉括号！</span></span><br><span class="line">	System.out.print((<span class="keyword">char</span>)by);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(bys))!=-<span class="number">1</span>) &#123;</span><br><span class="line">	System.out.print(<span class="keyword">new</span> String(bys,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>
<p>读取字节数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"fis.txt"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] <span class="keyword">byte</span> = <span class="keyword">new</span> <span class="keyword">byte</span>[n];</span><br><span class="line"><span class="keyword">int</span> len = fis.read(<span class="keyword">byte</span>);<span class="comment">//读取n个byte的字符到byte中，并返回读取的长度n；</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(bys))；<span class="comment">//将数组转换成字符串后输出。</span></span><br></pre></td></tr></table></figure>
<p><em>易错:</em>文件中的换行符等也算字符的。也会被读取。</p>
<h3 id="字节缓冲区流"><a href="#字节缓冲区流" class="headerlink" title="字节缓冲区流"></a>字节缓冲区流</h3><p>A:BufferedOutputStream<br>B:BufferedOutputStream<br>其构造器可以指定缓冲区大小，但我们一般不用，因为默认的大小就足够了。<br>代码Demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStreamTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args)</span> </span>&#123;</span><br><span class="line">		BufferedInputStream bufferInput = <span class="keyword">new</span> BufferedInputStream (<span class="keyword">new</span> FileInputStream (<span class="string">"123.txt"</span>))；</span><br><span class="line"></span><br><span class="line">		<span class="keyword">byte</span>[] bys <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">while</span> ((len = bufferInput.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.print(<span class="keyword">new</span> String (bys, <span class="number">0</span>, len));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>字节流操作中文数据不是特别的方便，所以就出现了转换流。<br>转换流的作用就是把字节流转换字符流来使用。<br>转换流其实是一个字符流;<br>字符流 = 字节流 + 编码表</p>
<h3 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h3><p>编码表就是由字符和对应的数值组成的一张表<br>常见的编码表：<br>ASCII<br>ISO-8859-1<br>GB2312<br>GBK<br>GB18030<br>UTF-8</p>
<h3 id="字符串中的编码与解码"><a href="#字符串中的编码与解码" class="headerlink" title="字符串中的编码与解码"></a>字符串中的编码与解码</h3><p>编码<br>String – byte[]<br>解码<br>byte[] – String</p>
<h3 id="IO流中的编码格式问题"><a href="#IO流中的编码格式问题" class="headerlink" title="IO流中的编码格式问题"></a>IO流中的编码格式问题</h3><p>A:OutputStreamWriter<br><code>OutputStreamWriter(OutputStream os):</code>默认编码，GBK<br><code>OutputStreamWriter(OutputStream os,String charsetName):</code>指定编码。<br>B:InputStreamReader<br><code>InputStreamReader(InputStream is):</code>默认编码，GBK<br><code>InputStreamReader(InputStream is,String charsetName)</code>:指定编码</p>
<h3 id="编码Demo"><a href="#编码Demo" class="headerlink" title="编码Demo"></a>编码Demo</h3><p>编码问题其实很简单<br>编码只要一致即可<br>Demo:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//new</span></span><br><span class="line">	OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter  (<span class="keyword">new</span> FileInputStream(<span class="string">"123.txt"</span>));<span class="comment">//默认GBK</span></span><br><span class="line">	OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter  (<span class="keyword">new</span> FileInputStream(<span class="string">"123.txt"</span>).<span class="string">"UTF-8"</span>);<span class="comment">//指定UTF-8</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//write bate</span></span><br><span class="line">	osw.write（“中国”）；</span><br><span class="line"></span><br><span class="line">	<span class="comment">//close</span></span><br><span class="line">	osw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常见字符流"><a href="#常见字符流" class="headerlink" title="常见字符流"></a>常见字符流</h3><p>Reader<br>|–InputStreamReader<br>|–FileReader<br>    |–BufferedReader<br>Writer<br>|–OutputStreamWriter<br>|–FileWriter<br>|–BufferedWriter</p>
<h2 id="常见IO流"><a href="#常见IO流" class="headerlink" title="常见IO流"></a>常见IO流</h2><p>IO流<br>|–字节流<br>|–字节输入流<br>InputStream<br>int read():一次读取一个字节<br>int read(byte[] bys):一次读取一个字节数组<br>|–FileInputStream<br>|–BufferedInputStream<br>|–字节输出流<br>OutputStream<br>void write(int by):一次写一个字节<br>void write(byte[] bys,int index,int len):一次写一个字节数组的一部分<br>|–FileOutputStream<br>|–BufferedOutputStream<br>|–字符流<br>|–字符输入流<br>Reader<br>int read():一次读取一个字符<br>int read(char[] chs):一次读取一个字符数组<br>|–InputStreamReader<br>|–FileReader<br>|–BufferedReader<br>String readLine():一次读取一个字符串<br>|–字符输出流<br>Writer<br>void write(int ch):一次写一个字符<br>void write(char[] chs,int index,int len):一次写一个字符数组的一部分<br>|–OutputStreamWriter<br>|–FileWriter<br>|–BufferedWriter<br>void newLine():写一个换行符<br>void write(String line):一次写一个字符串</p>
<h2 id="数据操作流"><a href="#数据操作流" class="headerlink" title="数据操作流"></a>数据操作流</h2><p>其可以操作基本类型的数据<br><code>DataInputStream</code><br><code>DataOutputStream</code></p>
<h2 id="内存操作流"><a href="#内存操作流" class="headerlink" title="内存操作流"></a>内存操作流</h2><p>1)有些时候我们操作完毕后，未必需要产生一个文件，就可以使用内存操作流。<br>(2)三种<br>A:<code>ByteArrayInputStream,ByteArrayOutputStream</code><br>B:<code>CharArrayReader,CharArrayWriter</code><br>C:<code>StringReader,StringWriter</code></p>
<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>字节打印流，字符打印流</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>A:只操作目的地,不操作数据源<br>B:可以操作任意类型的数据<br>C:如果启用了自动刷新，在调用<code>println()</code>方法的时候，能够换行并刷新<br>D:可以直接操作文件<br>问题：哪些流可以直接操作文件呢?<br>看API，如果其构造方法能够同时接收<code>File</code>和<code>String</code>类型的参数，一般都是可以直接操作文件的</p>
<h3 id="复制文本文件"><a href="#复制文本文件" class="headerlink" title="复制文本文件"></a>复制文本文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>));</span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>),<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">	pw.println(line);<span class="comment">//可以自动刷新并换行；</span></span><br><span class="line">&#125;</span><br><span class="line">pw.close();</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure>
<h2 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h2><p>System类下面有这样的两个字段（实质是System类中的两个成员变量）<br>in 标准输入流（键盘）<br>out 标准输出流（控制台）</p>
<h3 id="键盘录入方式（三种）"><a href="#键盘录入方式（三种）" class="headerlink" title="键盘录入方式（三种）"></a>键盘录入方式（三种）</h3><p>A:main方法的args接收参数<br>B:System.in通过BufferedReader进行包装（太老了，不常用）<br><code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</code> 注意，BufferedReader接收的是字符流,所以要包装一下。<br>System.in 读入的是一个字符流。<br>要想一个int什么的，要强制转换：<br><code>int i = Interger.parseInt(br.readLine());</code></p>
<p>C:Scanner（注意是JDK5以后才有的，现在常用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = sc.nextLine();</span><br><span class="line"><span class="keyword">int</span> x = sc.nextInt();</span><br></pre></td></tr></table></figure>
<h3 id="输出语句的原理和如何使用字符流输出数据"><a href="#输出语句的原理和如何使用字符流输出数据" class="headerlink" title="输出语句的原理和如何使用字符流输出数据"></a>输出语句的原理和如何使用字符流输出数据</h3><p>A:原理<br><code>System.out.println(&quot;helloworld&quot;);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"helloworld"</span>);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">PrintStream ps = System.out;</span><br><span class="line">ps.println(<span class="string">"helloworld"</span>);</span><br></pre></td></tr></table></figure>
<p>B:把System.out用字符缓冲流包装一下使用<br><code>BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));</code></p>
<h2 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h2><p>(1)可以按照文件指针的位置写数据和读数据。(注意其指针位置是以<strong>字节</strong>为单位)<br>RandomAccessFile类不属于流，是Object类；<br>其构造器 <code>public RandomAccessFile(String namne, String mode)</code>第一个参数是文件路径，第二个是操作文件的模式，有四种，常用的是rw 。</p>
<h2 id="合并流SequenceInputStream"><a href="#合并流SequenceInputStream" class="headerlink" title="合并流SequenceInputStream"></a>合并流SequenceInputStream</h2><p>就是把多个<em>输入流</em>的数据写到一个输出流中。<br>构造方法：<br>A:<code>SequenceInputStream(InputStream s1, InputStream s2)</code>一次只能传两个，（多个我们就不用这个构造器了。）<br>B:<code>SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e)</code></p>
<h2 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h2><p>可以把对象写入文本文件或者在网络中传输，方便重构。<br>序列化流：把对象按照流一样的方式存入文本文件或者在网络中传输。对象————&gt;数据；<br>反序列化流：把文本文件或网络中的流对象数据还原成对象。</p>
<h3 id="如何使用："><a href="#如何使用：" class="headerlink" title="如何使用："></a>如何使用：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个系列化流：</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>));</span><br><span class="line"><span class="comment">//注意：其接收的是一个字节流，所以要包装一下。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化创建的对象：</span></span><br><span class="line">Person p = <span class="keyword">new</span> person (XXX);</span><br><span class="line">oos .writeObject(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源：</span></span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure>
<h3 id="如何实现序列化呢"><a href="#如何实现序列化呢" class="headerlink" title="如何实现序列化呢?"></a>如何实现序列化呢?</h3><p>让被序列化的对象所属类<strong>必须</strong>实现序列化接口（Serializable），如没有将抛出NotSerializableException异常。<br>该接口是一个标记接口。没有功能需要实现。（就是没有方法的接口，就是创建的时候extends一下就可以啦，么么哒）<br>使用<code>transient</code>关键字声明不需要序列化的成员变量；</p>
<h3 id="注意问题："><a href="#注意问题：" class="headerlink" title="注意问题："></a>注意问题：</h3><p>把数据写到文件后，修改被序列化的类去再次序列化到会产生一个错误。<br>如何解决该问题呢?<br>在类文件中，给出一个固定的序列化id值。<br>而且，这样也可以解决黄色警告线问题</p>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>是一个集合类，Hashtable的子类（是一个Map集合）。实现了Properties的对象可以保存在流中或从流中加载。<br>注意，其不是泛型类。</p>
<h3 id="特有功能"><a href="#特有功能" class="headerlink" title="特有功能"></a>特有功能</h3><p>A:public Object setProperty(String key,String value) 添加键-值；（注意: <em>键值都是字符串</em>）<br>B:public String getProperty(String key) 获取键对应的值。<br>C:public Set<string> stringPropertyNames() 返回键的集合。（<em>易错</em>：是ProperyName,不是ProperiesName）</string></p>
<h3 id="和IO流结合的方法"><a href="#和IO流结合的方法" class="headerlink" title="和IO流结合的方法"></a>和IO流结合的方法</h3><p>把<em>键值对形式</em>的文本文件内容加载到Properties集合中<br><code>public void load(Reader reader)</code><br><code>public void load(InputStream inStream)</code><br>文件的个格式要是<code>XXXX=YYYY</code><br>把Properies集合中的数据存储到文本文件中<br><code>public void store(Writer writer,String comments)</code><br><code>public void store(OutputStream out,String comments)</code></p>
<h3 id="例子代码："><a href="#例子代码：" class="headerlink" title="例子代码："></a>例子代码：</h3><p>根据给定的文件判断是否有键为”lisi”的，如果有就修改其值为100</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> classPropertiesTest &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//把文件中的数据加载到集合中</span></span><br><span class="line">		Properties prop = <span class="keyword">new</span> Properies();</span><br><span class="line">		Reader r = <span class="keyword">new</span> FileReader (<span class="string">"a.txt"</span>);</span><br><span class="line">		prop.load(r);</span><br><span class="line">		r.close();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历集合，获取到第一个键；</span></span><br><span class="line">		Set&lt;String&gt; set = prop.stringProperyNames();</span><br><span class="line">		<span class="keyword">for</span>(String key : set) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"lisi"</span>。equals(key)) &#123;</span><br><span class="line">				prop.setProperty(key,<span class="string">"100"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//把集合中的数据重新储存到文件中</span></span><br><span class="line">		Writer w = <span class="keyword">new</span> FileWriter (<span class="string">"a.txt"</span>);</span><br><span class="line">		prop.store(w, <span class="keyword">null</span>);</span><br><span class="line">		w.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>Path:路径<br>Paths:通过静态方法返回一个路径<br><code>public static Path get (URI uri);</code><br>Files:提供了常见的功能：s<br>复制文本文件: <code>public static long copy (Path source, OutputStream out);</code><br>把集合中的数据写到文本文件: <code>public static Path writer (Path path, Iterable&lt;? extends CharSquence&gt; lines， Charset cs)</code></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Java </tag>
            
            <tag> IO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初学递归（java表示）]]></title>
      <url>/2015/11/coding/%E5%9F%BA%E7%A1%80_%E7%AE%97%E6%B3%95/Algorithms-%E6%80%BB%E7%BB%93-%E5%88%9D%E5%AD%A6%E9%80%92%E5%BD%92/</url>
      <content type="html"><![CDATA[<h2 id="递归概念"><a href="#递归概念" class="headerlink" title="递归概念"></a>递归概念</h2><h3 id="数学的上的定义："><a href="#数学的上的定义：" class="headerlink" title="数学的上的定义："></a>数学的上的定义：</h3><p>递归有两部分组成：<br>1.anchor（定位点）;<br>2.除anchor外的新对象的构造规律；</p>
<h3 id="编程（java）定义："><a href="#编程（java）定义：" class="headerlink" title="编程（java）定义："></a>编程（java）定义：</h3><p>方法中调用方法本身的现象；</p>
<p>public 一个方法(int n) {<br>    if ( 满足定位点条件) return 定位点;<br>    else (不满足定位点条件） return 规律;<br>}</p>
<a id="more"></a>
<h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h3><p>使用堆栈实现递归 ——由E.W.Dijkatra 提出；<br>这个就不展开说了。<br>注意，方法递归和方法嵌套的区别；</p>
<h2 id="递归解决问题的思想："><a href="#递归解决问题的思想：" class="headerlink" title="递归解决问题的思想："></a>递归解决问题的思想：</h2><p>先分解；<br>后合并；</p>
<p>例如，求5！<br>分解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5！ = 5 * 4！</span><br><span class="line">4！ = 4 * 3！</span><br><span class="line">3！ = 3 * 2!</span><br><span class="line">2！ = 2 * 1！</span><br><span class="line">1！ = 1</span><br></pre></td></tr></table></figure>
<p>合并：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1*2 = 2 = 2！</span><br><span class="line">3 * 2！= 3 * 2 = 6 = 3！</span><br><span class="line">4 * 3！= 4 * 6 = 24 = 4！</span><br><span class="line">5 * 4！= 5 *24 = 120 = 5!</span><br></pre></td></tr></table></figure>
<p>代码表示：(看下一节：)</p>
<h2 id="做递归的步骤：（3步走）"><a href="#做递归的步骤：（3步走）" class="headerlink" title="做递归的步骤：（3步走）"></a>做递归的步骤：（3步走）</h2><p>1.做递归要写一个方法：<br> 返回值类型：int<br> 参数类型：int n</p>
<p>2.出口条件：<br> if (n == 1) {return = 1;}s</p>
<p>3.规律：(递归公式)<br> if(n != 1) {return n * 方法名（n - 1）;}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jieCheng</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> n =<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (n != <span class="number">1</span>) <span class="keyword">return</span> n * jieCheng(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归的注意事项"><a href="#递归的注意事项" class="headerlink" title="递归的注意事项"></a>递归的注意事项</h2><ul>
<li>要有出口，否则就是死递归</li>
<li>次数不能过多，否则内存溢出——就是传说中的<strong>过分递归</strong></li>
<li>构造方法不能递归使用</li>
</ul>
<h2 id="递归的案例："><a href="#递归的案例：" class="headerlink" title="递归的案例："></a>递归的案例：</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>不死特能生神兔问题<br>有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问第20个月的兔子对数为多少？</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>  月       兔子对数<br>第一个月：     1<br>第二个月：    1<br>第三个月：    2<br>第四个月：    3<br>第五个月：    5<br>第六个月：    8<br>…..<br>由此可见兔子对象的数据是：<br>1,1,2,3,5,8…</p>
<h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h3><ul>
<li>从第三项开始，每一项是前两项之和</li>
<li>而且说明前两项是已知的</li>
</ul>
<h3 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h3><p>A1 = 1;<br>A2 = 1;<br>An = A(n-1) + A(n-2)</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.方法：</span></span><br><span class="line"><span class="comment"> *   返回值类型： int</span></span><br><span class="line"><span class="comment"> *   参数列表： int n</span></span><br><span class="line"><span class="comment"> * 2.出口：</span></span><br><span class="line"><span class="comment"> * 	第一个月是1；A1 = 1;</span></span><br><span class="line"><span class="comment"> * 	第二个月还是1；A2 = 1;</span></span><br><span class="line"><span class="comment"> * 3.规律：</span></span><br><span class="line"><span class="comment"> * 	An = A(n-1) + A(n-2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Tuzi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> Tuzi(n - <span class="number">1</span>) + Tuzi(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归的高级讨论："><a href="#递归的高级讨论：" class="headerlink" title="递归的高级讨论："></a>递归的高级讨论：</h2><h3 id="递归的分类："><a href="#递归的分类：" class="headerlink" title="递归的分类："></a>递归的分类：</h3><p>1.直接递归（上面的举例）<br>2.间接递归;<br>就是递归的时候，f()–&gt; g() –&gt; h() –&gt; f();<br>3.嵌套递归：<br>比较复杂了：<br>比如说 由Wilhelm Ackermann提出的著名的：<br>A(n,m) = m   if n = 0;<br>A(n,m) = A(n- 1, 1)  if n &gt; 0 m = 0;<br>A(n,m) = A(n - 1, A(n, m - 1))  else；</p>
<h2 id="递归的运行理解"><a href="#递归的运行理解" class="headerlink" title="递归的运行理解"></a>递归的运行理解</h2><p>１　每一次函数调用都会有一次返回．当程序流执行到某一级递归的结尾处时，它会转移到前一级递归继续执行．</p>
<p>２　递归函数中，位于递归调用前的语句和各级被调函数具有相同的顺序．如打印语句 #1 位于递归调用语句前，它按照递归调用的顺序被执行了 4 次．</p>
<p>３　每一级的函数调用都有自己的局部变量．</p>
<p>４　递归函数中，位于递归调用语句后的语句的执行顺序和各个被调用函数的顺序相反．</p>
<p><strong>即位于递归函数入口前的语句，右外往里执行；位于递归函数入口后面的语句，由里往外执行。</strong></p>
<p>５　虽然每一级递归有自己的变量，但是函数代码并不会得到复制．</p>
<p>６　递归函数中必须包含可以终止递归调用的语句．</p>
<p>一旦你理解了递归(理解递归,关键是脑中有一幅代码的图片,函数执行到递归函数入口时,就扩充一段完全一样的代码,执行完扩充的代码并return后,继续执行前一次递归函数中递归函数入口后面的代码),阅读递归函数最容易的方法不是纠缠于它的执行过程，而是相信递归函数会顺利完成它的任务。如果你的每个步骤正确无误，你的限制条件设置正确，并且每次调用之后更接近限制条件，递归函数总是能正确的完成任务。</p>
<p>不算递归调用语句本身，到目前为止所执行的语句只是除法运算以及对quotient的值进行测试。由于递归调用这些语句重复执行，所以它的效果类似循环：当quotient的值非零时，把它的值作为初始值重新开始循环。但是，递归调用将会保存一些信息（这点与循环不同），也就好是保存在堆栈中的变量值。这些信息很快就会变得非常重要。</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>2016-03-17 递归的运行分析</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">《数据结构与算法（Java语言版）》</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java子类重写一个构造器 ——this and super]]></title>
      <url>/2015/11/coding/Java-%E9%97%AE%E9%A2%98-SuperAndThis/</url>
      <content type="html"><![CDATA[<h2 id="昨天发现的问题："><a href="#昨天发现的问题：" class="headerlink" title="昨天发现的问题："></a>昨天发现的问题：</h2><p>如果类中不写构造方法，编译器会默认添加构造方法，内部只有一句<code>super()</code>;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   Class A &#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">super</span>()</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">………………</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>为什么这么写 呢，他是用来干什么的呢？<br><code>super()</code>实际上是对超类构造器的一个调用。<a id="more"></a></p>
<h2 id="super的用法："><a href="#super的用法：" class="headerlink" title="super的用法："></a>super的用法：</h2><p>主要是构造器、成员变量（field）、方法(methed）上的使用：<br>第一、在子类构造方法中要调用父类的构造器，用“<code>super(参数列表)</code>”的方式调用，参数不是必须的。注意：“<code>super(参数列表)</code>”这条语句<strong>只能（必须）</strong>用在子类构造器体中的<strong>第一行</strong>。<br>第二、当子类方法中的局部变量或者子类的成员变量与父类成员变量同名时，也就是子类局部变量覆盖父类成员变量时，用<code>“super.成员变量名</code>”来引用父类成员变量（注意，子类不能直接调用超类的私有field<br>）。<br>第三、当子类的成员方法覆盖了父类的成员方法时，也就是子类和父类有完s全相同的方法定义（但方法体可以不同），此时，用“<code>super.方法名(参数列表)</code>”的方式访问父类的方法。<br><strong>易错注意：</strong><br>如果子类的构造器没有显式的调用超类的构造器，则将自动地调用超类默认的构造器（无参的）。如果超类没有无参构造器，子类又没有显式地调用其他的构造器，编译器将报错！</p>
<h2 id="this的用法："><a href="#this的用法：" class="headerlink" title="this的用法："></a>this的用法：</h2><p>java中还有一个关键字和super的用法、含义都很相似，那就是this.<br>总结一下this的用法;<br>首先要有这么一个概念：<strong>this是指向对象本身的一个指针!</strong> this的用法只是一个对上面的一个解释。<br>第一、通过this调用另一个构造方法，用的是<code>this(参数列表)</code>，这个仅仅在类的构造方法中，别的地方不能这么用。注意：和super一样，这条语句只能（必须）用在子类构造器体中的第一行。<br>第二、函数参数或者函数中的局部变量和成员变量同名的情况下，成员变量被屏蔽，此时要访问成员变量则需要用“<code>this.成员变量名</code>”的方式来引用成员变量。</p>
<h2 id="对super-this-进一步理解："><a href="#对super-this-进一步理解：" class="headerlink" title="对super/this 进一步理解："></a>对super/this 进一步理解：</h2><p>在一个构造函数中调用另外一个构造函数的时候应该用的是同一块内存空间，在默认的构造函数中先初始化变量，调用另一个的时候覆写已经初始化的变量的值；这时难理解的地方就是每次调用的时候，他的值是什么：<br>可以看一下下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNameAndHight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line"><span class="keyword">int</span> hight; <span class="comment">// 身体高度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyNameAndHight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">print();</span><br><span class="line"><span class="keyword">this</span>.age = <span class="number">2</span>; <span class="comment">// 这里初始化 age 的值 ，但递归返回的时候，这个值会被覆写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyNameAndHight</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(); <span class="comment">// 调用自己的第一个构造函数，下面的两个语句数不执行的</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyNameAndHight</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> hight)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(age); <span class="comment">// 调用自己第二个构造函数 ，下面的两个语句数不执行的</span></span><br><span class="line"><span class="keyword">this</span>.hight = hight;</span><br><span class="line">print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="comment">// 打印函数</span></span><br><span class="line">System.out.println(<span class="string">"I'am a "</span> + age + <span class="string">"岁 "</span> + hight + <span class="string">"尺高 tiger!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> MyNameAndHight(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//output</span></span><br><span class="line"><span class="number">30</span> <span class="comment">//I'am a 0岁 0尺高 tiger!</span></span><br><span class="line"><span class="number">31</span> <span class="comment">//I'am a 3岁 0尺高 tiger!</span></span><br><span class="line"><span class="number">32</span> <span class="comment">//I'am a 3岁 3尺高 tiger!</span></span><br></pre></td></tr></table></figure>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 问题 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 关键字 </tag>
            
            <tag> this </tag>
            
            <tag> super </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java 中for (int i = 0; i< n; i++) 与 int i ; for ( i = 0; i < n; i ++)的区别]]></title>
      <url>/2015/11/coding/Java-%E9%97%AE%E9%A2%98-for%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>对于JVM来说一个方法，最多能用到多少个局部变量是一定的，运行时会直接申请到这些空间，然后反复使用，只要没有逻辑上的冲突，多个变量会被映射到一个空间上。<br>所以对于下面这个例子来说，变量声明在外面也是一样的，只是作用域不同，可是作用域在编译期就检查好了，所以运行效率没有差别。<a id="more"></a><br>具体可以使用 javap -v 命令查看生成的字节码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/Leo/MyJavaCode/Main.class</span><br><span class="line">  Last modified Oct 24, 2015; size 378 bytes</span><br><span class="line">  MD5 checksum 43aad6bccf1d4be2035f8d9e9e09e72c</span><br><span class="line">  Compiled from &quot;Main.java&quot;</span><br><span class="line">public class Main</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #3.#13         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #14            // Main</span><br><span class="line">   #3 = Class              #15            // java/lang/Object</span><br><span class="line">   #4 = Utf8               &lt;init&gt;</span><br><span class="line">   #5 = Utf8               ()V</span><br><span class="line">   #6 = Utf8               Code</span><br><span class="line">   #7 = Utf8               LineNumberTable</span><br><span class="line">   #8 = Utf8               test</span><br><span class="line">   #9 = Utf8               StackMapTable</span><br><span class="line">  #10 = Utf8               test2</span><br><span class="line">  #11 = Utf8               SourceFile</span><br><span class="line">  #12 = Utf8               Main.java</span><br><span class="line">  #13 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #14 = Utf8               Main</span><br><span class="line">  #15 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=0</span><br><span class="line">         0: iconst_0</span><br><span class="line">         1: istore_0</span><br><span class="line">         2: iload_0</span><br><span class="line">         3: bipush        10</span><br><span class="line">         5: if_icmpge     16</span><br><span class="line">         8: iload_0</span><br><span class="line">         9: istore_1</span><br><span class="line">        10: iinc          0, 1</span><br><span class="line">        13: goto          2</span><br><span class="line">        16: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 8</span><br><span class="line">        line 3: 10</span><br><span class="line">        line 6: 16</span><br><span class="line">      StackMapTable: number_of_entries = 2</span><br><span class="line">        frame_type = 252 /* append */</span><br><span class="line">          offset_delta = 2</span><br><span class="line">          locals = [ int ]</span><br><span class="line">        frame_type = 250 /* chop */</span><br><span class="line">          offset_delta = 13</span><br><span class="line"></span><br><span class="line">  public static void test2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=0</span><br><span class="line">         0: iconst_0</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: iload_1</span><br><span class="line">         3: bipush        10</span><br><span class="line">         5: if_icmpge     16</span><br><span class="line">         8: iload_1</span><br><span class="line">         9: istore_0</span><br><span class="line">        10: iinc          1, 1</span><br><span class="line">        13: goto          2</span><br><span class="line">        16: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 10: 8</span><br><span class="line">        line 9: 10</span><br><span class="line">        line 12: 16</span><br><span class="line">      StackMapTable: number_of_entries = 2</span><br><span class="line">        frame_type = 253 /* append */</span><br><span class="line">          offset_delta = 2</span><br><span class="line">          locals = [ top, int ]</span><br><span class="line">        frame_type = 249 /* chop */</span><br><span class="line">          offset_delta = 13</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Main.java&quot;</span><br></pre></td></tr></table></figure>
<p>发现除了因为定义时间所造成映射顺序不一致，其他几乎是一摸一样的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>作者：Intopass<br>链接：<a href="http://www.zhihu.com/question/30293967/answer/47500727" target="_blank" rel="noopener">http://www.zhihu.com/question/30293967/answer/47500727</a><br>来源：知乎</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 辨析 </tag>
            
            <tag> 变量 </tag>
            
            <tag> 问题 </tag>
            
            <tag> for </tag>
            
            <tag> 反编译 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Eclipse五分钟快速入门，你值得拥有！]]></title>
      <url>/2015/10/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-Eclipse%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><img src="http://7xiuu0.com1.z0.glb.clouddn.com/工具_Eclipse_入门.png" alt=""></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>自动补全的设置（2015-11-16 新增）<br>导包（2015-11-17新增）<br>eclipse控制台输出(输入）重定向到文件（2015-11-28新增）</p>
<h2 id="Eclipse的安装（略）"><a href="#Eclipse的安装（略）" class="headerlink" title="Eclipse的安装（略）"></a>Eclipse的安装（略）</h2><h2 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h2><p>用Eclipse写一个HelloWorld案例，最终在控制台输出你的名字<br>A:创建项目<br>B:在src目录下创建包。cn.itcast<br>C:在cn.itcast包下创建类。HelloWorld<br>D:在HelloWorld下有一个方法。public static void main(String[] args) {}<br>E:在main方法中有一个输出语句。System.out.println(“你的名字”);<a id="more"></a></p>
<h2 id="Eclipse空间的基本配置"><a href="#Eclipse空间的基本配置" class="headerlink" title="Eclipse空间的基本配置"></a>Eclipse空间的基本配置</h2><h3 id="程序的编译和运行的环境配置-一般不改"><a href="#程序的编译和运行的环境配置-一般不改" class="headerlink" title="程序的编译和运行的环境配置(一般不改)"></a>程序的编译和运行的环境配置(一般不改)</h3><p><code>Eclipse-- Preferences -- Java</code><br>编译环境：Compiler    默认选中的就是最高版本。<br>运行环境：Installed JREs    默认会找你安装的那个JDK。建议配置了Java的环境变量。</p>
<p>低编译，高运行。可以。<br>高编译，低运行。不可以。<br><strong>建议</strong>，<strong>编译和运行的版本一致。</strong></p>
<h3 id="如何去掉默认注释"><a href="#如何去掉默认注释" class="headerlink" title="如何去掉默认注释?"></a>如何去掉默认注释?</h3><p>window – Preferences – Java – Code Style – Code Templates<br>选择你不想要的内容，通过右边Edit编辑。<br>注意：请只删除注释部分，不是注释部分的不要删除。</p>
<h3 id="行号的显示和隐藏"><a href="#行号的显示和隐藏" class="headerlink" title="行号的显示和隐藏"></a>行号的显示和隐藏</h3><p>显示：在代码区域的最左边的空白区域，右键 – Show Line Numbers即可。<br>隐藏：把上面的动作再做一次。</p>
<h3 id="字体大小及颜色"><a href="#字体大小及颜色" class="headerlink" title="字体大小及颜色"></a>字体大小及颜色</h3><p>a:Java代码区域的字体大小和颜色：<br>Eclipse – Preferences – General – Appearance – Colors And Fonts – Java修改 – Java Edit Text Font<br>b:控制台<br>Eclipse – Preferences – General – Appearance – Colors And Fonts – Debug – Console font<br>c:其他文件<br>Eclipse – Preferences – General – Appearance – Colors And Fonts – Basic – Text Font</p>
<h3 id="窗体给弄乱了，怎么办"><a href="#窗体给弄乱了，怎么办" class="headerlink" title="窗体给弄乱了，怎么办?"></a>窗体给弄乱了，怎么办?</h3><p>window – Reset Perspective</p>
<h3 id="控制台找不到了，怎么办"><a href="#控制台找不到了，怎么办" class="headerlink" title="控制台找不到了，怎么办?"></a>控制台找不到了，怎么办?</h3><p>Window–Show View—Console</p>
<h2 id="常用快捷键（重点）"><a href="#常用快捷键（重点）" class="headerlink" title="常用快捷键（重点）"></a>常用快捷键（重点）</h2><p>Command + O：显示大纲<br>Command + 1：快速修复<br>Command + D：删除当前行<br>Command + Option + ↓：复制当前行到下一行<br>Command + Option + ↑：复制当前行到上一行<br>Option + ↓：当前行和下面一行交互位置<br>Option + ↑：当前行和上面一行交互位置<br>Option + ←：前一个编辑的页面<br>Option + →：下一个编辑的页面<br>Option + Return：显示当前选择资源的属性<br>Shift + Return：在当前行的下一行插入空行<br>Shift + Control + Return：在当前行插入空行<br>Control + Q：定位到最后编辑的地方<br>Control + M：最大化当前的Edit或View（再按则最小化）<br>Control + /：注释当前行，再按则取消注释<br>Command + T：快速显示当前类的继承结构<br>Command + W：关闭当前Editer<br>Command + K：参照当前选中的Word快速定位到下一个<br>Command + E：快速显示当前Editer的下拉列表（如果当前页面没有显示的用黑体表示）<br>Option + /：代码助手完成一些代码的插入（俗称“智能提示”）<br>Command + Shift + E：显示管理当前打开的所有的View的管理器<br>Command + J：正向增量查找（按下Command + J后，你所输入的每个字母编辑器都提供快速匹配定位到某个单词，如果没有，则在Stutes Line中显示没有找到了）<br>Command + Shift + J：反向增量查找<br>Command + Shift + W：关闭所有打开的Editer<br>Command + Shift + X：把当前选中的文本全部变为大写<br>Command + Shift + Y：把当前选中的文本全部变为小写<br><strong>Command + Shift + F：格式化当前代码</strong><br>Command + Shift + P：定位到对于的匹配符（譬如{}）（从前面定位后面时，光标要在匹配符里面，后面到前面，则反之）</p>
<p>Option + Command + R：重命名（尤其是变量和类的Rename效果比较明显）<br>Option + Shift + M：抽取方法（这是重构里面最常用的方法之一了，尤其是对一大堆泥团代码有用）<br>Option + Command + C：修改函数结构（有N个函数调用了这个方法，修改一次就搞定）<br>Option + Command + L：抽取本地变量（可以直接把一些魔法数字和字符串抽取成一个变量，尤其是多处调用的时候）<br>Option + Shift + F：把Class中的Local变量变为Field变量（比较实用的功能）</p>
<p>Option + Command + Z：重构的后悔药（Undo）</p>
<h2 id="如何提高开发效率"><a href="#如何提高开发效率" class="headerlink" title="如何提高开发效率"></a>如何提高开发效率</h2><h3 id="自动生成构造方法"><a href="#自动生成构造方法" class="headerlink" title="自动生成构造方法"></a>自动生成构造方法</h3><p>a:无参构造方法 在代码区域<code>右键--source--Generate Constructors from Superclass</code><br>b:带参构造方法 在代码区域<code>右键--source--Generate Constructors using fields.. -- finish</code></p>
<h3 id="自动生成getXxx-setXxx-方法"><a href="#自动生成getXxx-setXxx-方法" class="headerlink" title="自动生成getXxx()/setXxx()方法"></a>自动生成getXxx()/setXxx()方法</h3><p>在代码区域<code>右键--source--Generate Getters and Setters...</code></p>
<p>提供了对应的快捷键操作。<br><code>alt+shift+s</code><br>按下带有下划线的那个字母即可。</p>
<h3 id="如何继承抽象类和实现接口。"><a href="#如何继承抽象类和实现接口。" class="headerlink" title="如何继承抽象类和实现接口。"></a>如何继承抽象类和实现接口。</h3><h3 id="Override的作用"><a href="#Override的作用" class="headerlink" title="Override的作用"></a>Override的作用</h3><p>表示该方法是重写父类的。如果方法声明和父类不匹配，就会报错。</p>
<h3 id="自动补全的设置（2015-11-16-新增）"><a href="#自动补全的设置（2015-11-16-新增）" class="headerlink" title="自动补全的设置（2015-11-16 新增）"></a>自动补全的设置（2015-11-16 新增）</h3><p>最简单的修改方式是：<code>Windows——&gt;Preferences——&gt;Java--&gt;Editor--&gt;Content Asist，在Auto activation triggers for Java</code>后面的文本框里只有一个“<code>.</code>”。现在你将其改为“.<code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</code>”即可。然后你再试试，会发现，现在的补全功能跟VS差不多了。你还可以在Advanced和Favorite里进行高级的设置。</p>
<h2 id="删除项目和导入项目"><a href="#删除项目和导入项目" class="headerlink" title="删除项目和导入项目"></a>删除项目和导入项目</h2><p>删除项目<br>选中项目 <code>– 右键 – 删除</code><br>            从项目区域中删除<br>            从硬盘上删除</p>
<p>导入项目<br>在项目区域右键找到<code>import</code><br>找到<code>General</code>，展开，并找到<br><code>Existing Projects into Workspace</code><br>点击<code>next</code>,然后选择你要导入的项目<br><strong>注意：</strong> 这里选择的是项目名称</p>
<h2 id="要注意的几个小问题"><a href="#要注意的几个小问题" class="headerlink" title="要注意的几个小问题"></a>要注意的几个小问题</h2><p>如何查看项目所在路径<br><code>选中 -- 右键 -- Properties -- Resource -- Location</code></p>
<h3 id="导入项目要注意的问题"><a href="#导入项目要注意的问题" class="headerlink" title="导入项目要注意的问题"></a>导入项目要注意的问题</h3><ul>
<li>项目区域中不可能出现同名的项目(新建或者导入)</li>
<li>自己随意建立的文件夹是不能作为项目导入的</li>
</ul>
<h3 id="修改项目问题"><a href="#修改项目问题" class="headerlink" title="修改项目问题"></a>修改项目问题</h3><ul>
<li>不要随意修改项目名称</li>
<li>如果真要修改，不要忘记了配置文件<code>.project</code>中的<code>&lt;name&gt;</code>把这里改为你改后的名称<code>&lt;/name&gt;</code></li>
</ul>
<h3 id="接收文件的注意事项"><a href="#接收文件的注意事项" class="headerlink" title="接收文件的注意事项"></a>接收文件的注意事项</h3><p>A:专门建立一个文件夹用于接收项目，不要随意放置。<br>B:同一个项目再次接收的时候，先去存放目录把原始项目删除，然后重新存储，最后刷新项目即可。<br>C:每天对照我写的项目，自己也创建一个练习项目<br>举例：我的项目名称 <code>day11_eclipse</code><br>你就创建一个项目名称 <code>day11_eclipse_test</code></p>
<h2 id="Eclipse中代码的高级-Debug-调试"><a href="#Eclipse中代码的高级-Debug-调试" class="headerlink" title="Eclipse中代码的高级(Debug)调试"></a>Eclipse中代码的高级(Debug)调试</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ul>
<li>调试程序</li>
<li>查看程序执行流程</li>
</ul>
<h3 id="如何查看程序执行流程？"><a href="#如何查看程序执行流程？" class="headerlink" title="如何查看程序执行流程？"></a>如何查看程序执行流程？</h3><p>想看程序流程，就必须设置断点。</p>
<h3 id="什么是断点？"><a href="#什么是断点？" class="headerlink" title="什么是断点？"></a>什么是断点？</h3><p>就是一个标记，从哪里开始。</p>
<h3 id="如何设置断点："><a href="#如何设置断点：" class="headerlink" title="如何设置断点："></a>如何设置断点：</h3><p>你想看哪里的程序，你就在那个有效程序的左边双击即可。</p>
<h3 id="在哪里设置断点："><a href="#在哪里设置断点：" class="headerlink" title="在哪里设置断点："></a>在哪里设置断点：</h3><p>哪里不会点哪里。<br>目前：我们就在每个方法的第一条有效语句上都加。</p>
<h3 id="如何运行设置断点后的程序："><a href="#如何运行设置断点后的程序：" class="headerlink" title="如何运行设置断点后的程序："></a>如何运行设置断点后的程序：</h3><p><code>右键 -- Debug as -- Java Application</code></p>
<h3 id="看哪些地方？"><a href="#看哪些地方？" class="headerlink" title="看哪些地方？"></a>看哪些地方？</h3><p><code>Debug：</code>断点测试的地方<br>                在这个地方，记住F6，或者点击也可以。一次看一行的执行过程。<br><code>Variables：</code>查看程序的变量变化<br><code>ForDemo：</code>被查看的源文件<br><code>Console：</code>控制台</p>
<h3 id="如何去断点："><a href="#如何去断点：" class="headerlink" title="如何去断点："></a>如何去断点：</h3><p>a:再次双击即可<br>b:找到Debug视图，Variables界面，找到Breakpoints，并点击，然后看到所有的断点，最后点击那个双叉。</p>
<h2 id="常用高级特性："><a href="#常用高级特性：" class="headerlink" title="常用高级特性："></a>常用高级特性：</h2><h3 id="导包（2015-11-17新增）："><a href="#导包（2015-11-17新增）：" class="headerlink" title="导包（2015-11-17新增）："></a>导包（2015-11-17新增）：</h3><p>有两种常用的方法：</p>
<ol>
<li>以外部包（External Archives）的形式导入。<br>在默认位于 Eclipse 窗口左侧的 <code>Package Explorer</code>中，右键项目名，点击<code>Build Path</code> 项下的 <code>Add External Archives</code>。 然后在弹出的文件选择窗口中选中<code>acm.jar</code> 即可。这种方法适用于导入单个的 jar 包。</li>
<li>以 User Library 的形式导入。<br>User Library 即用户类库，用来组织多个 jar 包。在默认位于 Eclipse 窗口左侧的 <code>Package Explorer</code>中，右键项目名，点击<code>Build Path</code>项下的<code>Add Libraries</code>。 在弹出的窗口中选中 <code>User Library</code>并点击下一步。在新出现的窗口（窗口一）中，点击位于右侧的<code>User Libraries...</code>按钮进入 U<code>ser Library Preferences</code>窗口。接着，点击<code>New</code> 按钮，输入用户类库名称，例如 <code>『ACM』</code>，点击 <code>OK</code>。然后单击选中新创建的用户类库，点击右侧的<code>Add JARs</code>按钮，选中一个或多个 jar 文件，点 <code>OK。</code>接下来，返回窗口一中选中刚刚新创建的用户类库，点击<code>OK</code>即可。这种方法适用于多个 jar 包的导入。</li>
</ol>
<h3 id="eclipse控制台输出-输入）重定向到文件（2015-11-28新增）"><a href="#eclipse控制台输出-输入）重定向到文件（2015-11-28新增）" class="headerlink" title="eclipse控制台输出(输入）重定向到文件（2015-11-28新增）"></a>eclipse控制台输出(输入）重定向到文件（2015-11-28新增）</h3><p><code>Run-&gt;Run Configurations-&gt;Common-&gt;Standard Input and Output</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.zhihu.com/question/20311561/answer/14713365" target="_blank" rel="noopener">导包（2015-11-17新增）来自 知乎：彭晟杰 链接：</a></p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Eclipse </tag>
            
            <tag> 配置 </tag>
            
            <tag> 快捷键 </tag>
            
            <tag> 使用 </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中抽象类和接口的异同]]></title>
      <url>/2015/10/coding/Java-%E6%80%BB%E7%BB%93-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>有时候，我们可能想要构造一个很抽象的父类对象，它可能仅仅代表一个分类或抽象概念，它的实例没有任何意义，因此不希望它能被实例化。<br>例如：有一个父类<code>“ 水果（Fruit）”</code>，它有几个子类<code>苹果（Apple）</code>、“<code>橘子（Orange）</code>”、“<code>香蕉（Banana）</code>”等。水果在这里仅仅只是作为一个分类， 显然水果的实例没有什么意义（就好像一个人如果告诉你他买了一些水果但是却不告诉你是苹果还是橘子，你很难想象他到底买的是什么。）。而水果类又要能被子类化，这就要求我们使用<strong><em>抽象类（abstract class）</em></strong>来解决这个问题。<br>在java中，通过<strong><em>在class关键字</em></strong>前增加<strong><em>abstract修饰符</em></strong>，就可以将一个类定义成抽象类。抽象类不能被实例化。<a id="more"></a></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>下面谈谈<strong><em>接口（interface）</em></strong>。java语言使用<strong><em>关键字interface</em></strong>定义一个接口。接口也是抽象对象，它甚至比抽象类更抽象。接口中的方法都是抽象方法。<br>一个接口可以继承其他接口；一个类通过关键字<strong><em>implements</em></strong>声明要实现一个接口，并具体实现接口的方法。</p>
<h2 id="二者区别及联系"><a href="#二者区别及联系" class="headerlink" title="二者区别及联系"></a>二者区别及联系</h2><p>1.接口和抽象类显著的共同点:<br>接口和抽象类都可以有抽象方法。</p>
<p>2.接口和抽象类的不同点有：<br>(1)抽象类可以有实例变量，而接口不能拥有实例变量（一般不定义数据成员），接口中的变量都是静态（static）的常量（final）。<br>(2)抽象类可以有非抽象方法（很多的程序员认为不应该），而接口只能有抽象方法。</p>
<p>3.abstract class和interface所反映出的设计理念不同。其实abstract class表示的是”is-a”关系，interface表示的是”like-a”关系。</p>
<p>4.实现接口的类必须实现其中的所有方法，继承自抽象类的子类实现所有的抽象方法。抽象类中可以有非抽象方法。接口中则不能有实现方法。</p>
<p>5.接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。</p>
<p>6.抽象类中的变量默认具有 friendly权限，其值可以在子类中重新定义，也可以重新赋值。</p>
<p>7.接口中的方法默认都是 public abstract 类型的。</p>
<h2 id="有了抽象类为什么还要引入接口的概念呢？"><a href="#有了抽象类为什么还要引入接口的概念呢？" class="headerlink" title="有了抽象类为什么还要引入接口的概念呢？"></a>有了抽象类为什么还要引入接口的概念呢？</h2><p>关键字：多继承<br>Java中每个类只能扩展一个类，但每个类可以实现多个接口；这样我们可以通过接口实现多继承的大数好处，同时还能避免多重继承的复杂性和低效性。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 接口 </tag>
            
            <tag> 抽象类 </tag>
            
            <tag> 对比 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的成员变量、局部变量、静态变量]]></title>
      <url>/2015/10/coding/Java-%E6%80%BB%E7%BB%93-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>类体由3部分构成:<br>一部分是变量的定义;<br>一部分是构造器<br>一部分是方法的定义(一个类中可以有多个方法)</p>
<p>在变量定义部分定义的变量叫做类的<strong>成员变量</strong>,成员变量在整个类中都有效.(全局变量是成员变量的俗称)<br>在方法体中定义的变量叫做<strong>局部变量</strong>,局部变量只在定义它的方法中有效.<br>而成员变量又分为<strong>实例变量</strong>和类变量(static<strong>静态变量</strong>).<a id="more"></a></p>
<h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><h3 id="成员变量："><a href="#成员变量：" class="headerlink" title="成员变量："></a>成员变量：</h3><ol>
<li>成员变量定义在类中，在整个类中都可以被访问。</li>
<li>成员变量随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。</li>
<li>成员变量有默认初始化值。</li>
</ol>
<h3 id="局部变量："><a href="#局部变量：" class="headerlink" title="局部变量："></a>局部变量：</h3><ol>
<li>局部变量只定义在局部范围内，如：函数内，语句内等，只在所属的区域有效。</li>
<li>局部变量存在于栈内存中，作用的范围结束，变量空间会自动释放。</li>
<li>局部变量没有默认初始化值</li>
</ol>
<h2 id="成员变量和静态变量的区别"><a href="#成员变量和静态变量的区别" class="headerlink" title="成员变量和静态变量的区别"></a>成员变量和静态变量的区别</h2><h3 id="两个变量的生命周期不同"><a href="#两个变量的生命周期不同" class="headerlink" title="两个变量的生命周期不同"></a>两个变量的生命周期不同</h3><ul>
<li>成员变量随着对象的创建而存在，随着对象被回收而释放。</li>
<li>静态变量随着类的加载而存在，随着类的消失而消失。</li>
</ul>
<h3 id="调用方式不同"><a href="#调用方式不同" class="headerlink" title="调用方式不同"></a>调用方式不同</h3><ul>
<li>成员变量只能被对象调用。</li>
<li>静态变量可以被对象调用，还可以被类名调用。（建议：只用类名调用！）</li>
</ul>
<h3 id="别名不同（完全可以顾名思义啦……）"><a href="#别名不同（完全可以顾名思义啦……）" class="headerlink" title="别名不同（完全可以顾名思义啦……）"></a>别名不同（完全可以顾名思义啦……）</h3><ul>
<li>成员变量也称为实例变量。</li>
<li>静态变量也称为类变量。</li>
</ul>
<h3 id="数据存储位置不同"><a href="#数据存储位置不同" class="headerlink" title="数据存储位置不同"></a>数据存储位置不同</h3><ul>
<li>成员变量存储在堆内存的对象中，所以也叫对象的特有数据。</li>
<li>静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。</li>
</ul>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>在使用变量时需要遵循的原则为：<strong>就近原则</strong><br>首先在局部范围找，有就使用；接着在成员位置找。</p>
<p>局部变量位于栈区，静态变量位于方法区，实例变量位于堆区，方法的字节码位于方法区，对象本身位于堆区，对象的引用位于栈区。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 辨析 </tag>
            
            <tag> 变量 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[里氏替换原则 Liskov Substitution Principle， LSP]]></title>
      <url>/2015/10/coding/Java-%E6%80%BB%E7%BB%93-LiskovSubstitutionPrinciple/</url>
      <content type="html"><![CDATA[<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。<br>也就说<strong>继承是有风险的</strong>。<a id="more"></a></p>
<p>里氏替换原则由芭芭拉·利斯科夫（Barbara Liskov）在1987年在一次会议上名为“数据的抽象与层次”的演说中首先提出。<br>里氏替换原则的内容可以描述为： “派生类（子类）对象能够替换其基类（超类）对象被使用。” 以上内容并非利斯科夫的原文，而是译自罗伯特·马丁（Robert Martin）对原文的解读。其原文为：</p>
<blockquote>
<p>Let  be a property provable about objects  of type . Then  should be true for objects  of type where  is a subtype of。</p>
</blockquote>
<p><strong><em>也就是说，当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系。 林先生在上课时风趣地称之为“老鼠的儿子会打洞”</em></strong></p>
<p>里氏替换原则通俗的来讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。它包含以下4层含义：</p>
<ul>
<li><p>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</p>
</li>
<li><p>子类中可以增加自己特有的方法。</p>
</li>
<li><p>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</p>
</li>
<li><p>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p>
</li>
</ul>
<p>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？</p>
<p>后果就是：<strong>你写的代码出问题的几率将会大大增加。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 编程 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[equals ,”==” , hashcode的关系及区别]]></title>
      <url>/2015/10/coding/Java-%E6%80%BB%E7%BB%93-equals,==,ashcode%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>##更新记录<br>NULL</p>
<h2 id="“-”"><a href="#“-”" class="headerlink" title="“==”"></a>“==”</h2><p>是比较地址是否相等 。<br>Java中的变量声明都是call,所以说不同的对象可能指向同一个地址；<br>同样的，字符串比较也不能用“==”。<br>基本变量的比较方式就只有==。但是wrapper后的的就不能用了，因为虽说有自动折箱，但其结果是不确定的，所以不要用。<a id="more"></a></p>
<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>是比较值是否相等。<br>一般比较对象是否相等都用equals ,注意，java中只有基本类型（数值，字符，boolean）不是对象。<br>equals方法主要是用来判断从表面上看或者从内容上看，2个对象是不是相等。<br>比较两个枚举类型的值的时候不要调用equals，直接使用“==”就可以。</p>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><p>实际上就是一个对象的MD5 。对比起来比equals快得多。<br>他是一个整数值，但是没有规律的。java中默认的散列码就是对象的存储地址。<br>1) 对象相等则hashCode一定相等；<br>2) hashCode相等对象未必相等。<br><strong>注意：</strong><br>1.重载equals的时候，一定要(must)（正确）重载hashCode 。使得equals成立的时候，hashCode相等。使两个逻辑相等。<br>2.我们在定义hashCode方法时，要乘以一些奇数（最好是素数），这是是为了在理论上增大哈希值得离散程度。这是数学上证明的问题。你需要知道的是，hashcode就是为了哈希索引用的，哈希值分布的越均匀，map数据结构的查询效率越高。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 编程 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 辨析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python学习笔记009-错误、调试和测试]]></title>
      <url>/2015/09/%E5%BE%85%E6%95%B4%E7%90%86/Python3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0009-%E9%94%99%E8%AF%AF%E3%80%81%E8%B0%83%E8%AF%95%E5%92%8C%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>##摘要（Abstract）<br>本文摘要。<a id="more"></a></p>
<p>##更新记录<br>NULL</p>
<p>##错误处理<br>在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。但很不方便。<br>Python内置了一套<code>try...except...finally...</code>的错误处理机制，大多数高级语言都有。</p>
<p>###try<br>当我们认为某些代码可能会出错时，就可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。<br><strong>注意</strong>：<br>1.如果没有错误发生，<code>except</code>语句块不会被执行，但是<code>finally</code>如果有，则一定会被执行（可以没有<code>finally</code>语句）。<br>2.可以有多个<code>except</code>来捕获不同类型的错误。<br>3.如果没有错误发生，可以在<code>except</code>语句块后面加一个<code>else</code>，当没有错误发生时，会自动执行<code>else</code>语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'try...'</span>)</span><br><span class="line">    r = <span class="number">10</span> / int(<span class="string">'2'</span>)</span><br><span class="line">    print(<span class="string">'result:'</span>, r)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'ValueError:'</span>, e)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'ZeroDivisionError:'</span>, e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'no error!'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'finally...'</span>)</span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure>
<p>####注意错误的继承关系<br>Python的错误其实是<code>class</code>，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    foo()</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'ValueError'</span>)</span><br><span class="line"><span class="keyword">except</span> UnicodeError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'UnicodeError'</span>)</span><br></pre></td></tr></table></figure>
<p>第二个<code>except</code>永远也捕获不到<code>UnicodeError</code>，因为<code>UnicodeError</code>是<code>ValueError</code>的子类，如果有，也被第一个<code>except</code>给捕获了。</p>
<p>Python所有的错误都是从<code>BaseException</code>类派生的，常见的错误类型和继承关系:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- ArithmeticError</span><br><span class="line">      |    +-- FloatingPointError</span><br><span class="line">      |    +-- OverflowError</span><br><span class="line">      |    +-- ZeroDivisionError</span><br><span class="line">      +-- AssertionError</span><br><span class="line">      +-- AttributeError</span><br><span class="line">      +-- BufferError</span><br><span class="line">      +-- EOFError</span><br><span class="line">      +-- ImportError</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      |    +-- UnboundLocalError</span><br><span class="line">      +-- OSError</span><br><span class="line">      |    +-- BlockingIOError</span><br><span class="line">      |    +-- ChildProcessError</span><br><span class="line">      |    +-- ConnectionError</span><br><span class="line">      |    |    +-- BrokenPipeError</span><br><span class="line">      |    |    +-- ConnectionAbortedError</span><br><span class="line">      |    |    +-- ConnectionRefusedError</span><br><span class="line">      |    |    +-- ConnectionResetError</span><br><span class="line">      |    +-- FileExistsError</span><br><span class="line">      |    +-- FileNotFoundError</span><br><span class="line">      |    +-- InterruptedError</span><br><span class="line">      |    +-- IsADirectoryError</span><br><span class="line">      |    +-- NotADirectoryError</span><br><span class="line">      |    +-- PermissionError</span><br><span class="line">      |    +-- ProcessLookupError</span><br><span class="line">      |    +-- TimeoutError</span><br><span class="line">      +-- ReferenceError</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      |    +-- NotImplementedError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      |    +-- IndentationError</span><br><span class="line">      |         +-- TabError</span><br><span class="line">      +-- SystemError</span><br><span class="line">      +-- TypeError</span><br><span class="line">      +-- ValueError</span><br><span class="line">      |    +-- UnicodeError</span><br><span class="line">      |         +-- UnicodeDecodeError</span><br><span class="line">      |         +-- UnicodeEncodeError</span><br><span class="line">      |         +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">           +-- ImportWarning</span><br><span class="line">           +-- UnicodeWarning</span><br><span class="line">           +-- BytesWarning</span><br><span class="line">           +-- ResourceWarning</span><br></pre></td></tr></table></figure>
<p>####跨层调用<br>使用<code>try...except</code>捕获错误可以跨越多层调用，比如函数<code>main()</code>调用<code>foo()</code>，<code>foo()</code>调用<code>bar()</code>，结果<code>bar()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理.</p>
<p>###调用堆栈</p>
<p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。<br>举例：err.py：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># err.py:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / int(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    bar(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>执行，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python3 err.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;err.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;err.py&quot;, line 9, in main</span><br><span class="line">    bar(&apos;0&apos;)</span><br><span class="line">  File &quot;err.py&quot;, line 6, in bar</span><br><span class="line">    return foo(s) * 2</span><br><span class="line">  File &quot;err.py&quot;, line 3, in foo</span><br><span class="line">    return 10 / int(s)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<p>错误信息第1行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br></pre></td></tr></table></figure>
<p>告诉我们这是错误的跟踪信息。</p>
<p>第2~3行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File &quot;err.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">          main()</span><br></pre></td></tr></table></figure>
<p>调用main()出错了，在代码文件err.py的第11行代码，但原因是第9行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File &quot;err.py&quot;, line 9, in main</span><br><span class="line">    bar(&apos;0&apos;)</span><br></pre></td></tr></table></figure>
<p>调用bar(‘0’)出错了，在代码文件err.py的第9行代码，但原因是第6行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File &quot;err.py&quot;, line 6, in bar</span><br><span class="line">        return foo(s) * 2</span><br></pre></td></tr></table></figure>
<p>原因是return foo(s) * 2这个语句出错了，但这还不是最终原因，继续往下看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File &quot;err.py&quot;, line 3, in foo</span><br><span class="line">  return 10 / int(s)</span><br></pre></td></tr></table></figure>
<p>原因是return 10 / int(s)这个语句出错了，这是错误产生的源头，因为下面打印了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZeroDivisionError: integer division or modulo by zero</span><br></pre></td></tr></table></figure>
<p>根据错误类型<code>ZeroDivisionError</code>，我们判断，<code>int(s)</code>本身并没有出错，但是<code>int(s)</code>返回<code>0</code>，在计算<code>10 / 0</code>时出错，至此，找到错误源头。</p>
<p>###抛出错误<br>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，自己编写的函数也可以抛出错误。<br>程序也可以主动抛出错误，让调用者来处理相应的错误。但是，应该在文档中写清楚可能会抛出哪些错误，以及错误产生的原因。<br><code>raise</code>语句如果不带参数，就会把当前错误原样抛出。此外，在<code>except</code>中<code>raise</code>一个<code>Error</code>，还可以把一种类型的错误转化成另一种类型：</p>
<p>如果要抛出错误，首先根据需要，可以定义一个错误的<code>class</code>，选择好继承关系，然后，用raise语句抛出一个错误的实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># err_raise.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooError</span><span class="params">(ValueError)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></span><br><span class="line">    n = int(s)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> FooError(<span class="string">'invalid value: %s'</span> % s)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'0'</span>)</span><br></pre></td></tr></table></figure>
<p>执行，可以最后跟踪到我们自己定义的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python3 err_raise.py </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;err_throw.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    foo(&apos;0&apos;)</span><br><span class="line">  File &quot;err_throw.py&quot;, line 8, in foo</span><br><span class="line">    raise FooError(&apos;invalid value: %s&apos; % s)</span><br><span class="line">__main__.FooError: invalid value: 0</span><br></pre></td></tr></table></figure>
<p>另一种错误处理的方式：捕获了错误后，，又把错误通过raise语句抛出去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># err_reraise.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></span><br><span class="line">    n = int(s)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'invalid value: %s'</span> % s)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        foo(<span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'ValueError!'</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>
<p>##调试</p>
<p>###使用print()<br>用<code>print()</code>把可能有问题的变量打印出来,用<code>print()</code>最大的坏处是将来还得删掉它，想想程序里到处都是<code>print(</code>)，运行结果也会包含很多垃圾信息。</p>
<p>###assert</p>
<p>凡是用<code>print()</code>来辅助查看的地方，都可以用<strong>断言（assert）</strong>来替代.<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert n != 0, &apos;n is zero!&apos;</span><br></pre></td></tr></table></figure>
<p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。<br>如果断言失败，assert语句本身就会抛出<code>AssertionError</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python3 err.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">AssertionError: n <span class="keyword">is</span> zero!</span><br></pre></td></tr></table></figure>
<p>程序中如果到处充斥着assert，和print()相比也好不到哪去。，启动Python解释器时可以用<code>-O</code>参数来关闭assert：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -O err.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<p>关闭后，你可以把所有的<code>assert</code>语句当成<code>pass</code>来看。</p>
<p>###loggin<br>和<code>assert</code>比，<code>logging</code>不会抛出错误，而且<strong>可以输出到文件</strong>：</p>
<p>####loggin特点：<br>1.允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，l<code>ogging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。<br>2.通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</p>
<p>####使用方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> logging</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'0'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = int(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>logging.info(<span class="string">'n = %d'</span> % n)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">10</span> / n)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure></p>
<p>运行，发现除了ZeroDivisionError，没有任何信息。怎在<code>import logging</code>之后添加一行配置再试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python3 err.py</span><br><span class="line">INFO:root:n = <span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"err.py"</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">print</span> <span class="number">10</span> / n</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<p>###pdb<br>调试器pdb，可以让程序以单步方式运行，可以随时查看运行状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pdb err.py</span><br><span class="line">&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()</span><br><span class="line">-&gt; s = &apos;0&apos;</span><br></pre></td></tr></table></figure>
<p>以参数<code>-m pdb</code>启动后，pdb定位到下一步要执行的代码<code>-&gt; s = &#39;0&#39;。</code></p>
<p>####常用命令这<br>输入命令<code>l</code>来查看代码：<br>输入命令<code>n</code>可以单步执行代码：<br>任何时候都可以输入命令<code>p 变量名</code>来查看变量：<br>输入命令q结束调试，退出程序：</p>
<p>###pdb.set_trace()<br>这个方法也是用pdb，但是不需要单步执行，我们只需要<code>import pdb</code>，然后，在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点.<br>运行代码：<br>程序会自动在<code>pdb.set_trace()</code>暂停并进入<code>pdb</code>调试环境，可以用命令<code>p</code>查看变量，或者用命令<code>c</code>继续运行.</p>
<p>###IDE<br>目前比较好的Python IDE有<code>PyCharm</code>：</p>
<p>##单元测试</p>
<p>####什么是单元测试<br>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p>
<p><strong>意义：</strong><br>如果我们对<code>abs()</code>函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。<br><strong>好处：</strong><br>确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。<br><strong>注意：</strong><br>1.单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。<br>2.单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。<br>3.单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。<br>4.单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。</p>
<p>##参考<br>1.我的电脑是MAC，以下文字如无特别说明皆是针对OSX的设置及操作，请勿生搬硬套。<br>2.下面的程序一定要自己手打一遍，不要偷懒，不然要后悔的。<br>3.我是按照廖雪峰老师的教程学的，所以有的地方是一样一样的，大家可以当成是一个学习笔记，想学习的可以移步<a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰大大的博客</a>，那里真的好赞。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 编程 </tag>
            
            <tag> Python3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python笔记-面向对象高级编程]]></title>
      <url>/2015/09/%E5%BE%85%E6%95%B4%E7%90%86/Python3-%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文摘要。<a id="more"></a></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>2016-03-30 全面更新</p>
<h2 id="使用-slots"><a href="#使用-slots" class="headerlink" title="使用__slots__"></a>使用<code>__slots__</code></h2><p>创建了一个class的实例后，可以给实例绑定一个属性；还可以给实例绑定一个方法；但是，给一个实例绑定的方法，对另一个实例是不起作用的；给class绑定方法后，<strong>所有</strong> 实例均可调用；<br>例子：<br>给实例绑定一个方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_age</span><span class="params">(self, age)</span>:</span> <span class="comment"># 定义一个函数作为实例方法</span></span><br><span class="line"><span class="meta">... </span>    self.age = age</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>) <span class="comment"># 调用实例方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age <span class="comment"># 测试结果</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>
<p><code>__slots__</code>变量，可以用来限制该class实例能添加的属性：<br>（优化内存使用。限制实例属性的自由添加只是副作用而已。）<br><code>__slots__</code>存在的价值在于删除<code>__dict__</code>属性，从而来优化类实例对内存的需求。而这带来的副作用就是：由于缺少了<strong>dict</strong>，类实例木有办法再自由添加属性了！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'name'</span>, <span class="string">'age'</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></span><br></pre></td></tr></table></figure>
<p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：<br>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<h2 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h2><p><code>@property</code>是在2.6、3.0新增的，2.5没有该功能。<br>Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure>
<p>把一个getter方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个<code>setter</code>方法变成属性赋值，于是，我们就拥有一个可控的属性操作。<br>定义<strong>只读属性</strong>，只定义<code>getter</code>方法，不定义<code>setter</code>方法就是一个只读属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2015</span> - self._birth</span><br></pre></td></tr></table></figure>
<p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个只读属性。</p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>通过多重继承，一个子类就可以同时获得<strong>多个</strong>父类的所有功能。<br>例如：<br>对于需要<code>Runnable</code>功能的<code>Mammal</code>动物，就多继承一个<code>Runnable</code>，例如<code>Dog</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Mammal, Runnable)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="Mixln"><a href="#Mixln" class="headerlink" title="Mixln"></a>Mixln</h3><p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为<code>MixIn</code>。<br><code>MixIn</code>的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个<code>MixIn</code>的功能，而不是设计多层次的复杂的继承关系。</p>
<p>Python自带的很多库也使用了<code>MixIn</code>。举个例子，Python自带了<code>TCPServer</code>和<code>UDPServer</code>这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由<code>ForkingMixIn</code>和<code>ThreadingMixIn</code>提供。通过组合，我们就可以创造出合适的服务来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#比如，编写一个多进程模式的TCP服务，定义如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTCPServer</span><span class="params">(TCPServer, ForkingMixIn)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#编写一个多线程模式的UDP服务，定义如下：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUDPServer</span><span class="params">(UDPServer, ThreadingMixIn)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTCPServer</span><span class="params">(TCPServer, CoroutineMixIn)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h3><p>由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。</p>
<p>只允许单一继承的语言（如Java）不能使用MixIn的设计。</p>
<h2 id="定制类："><a href="#定制类：" class="headerlink" title="定制类："></a>定制类：</h2><p>看到类似<code>__slots__</code>这种形如<code>__xxx__</code>的变量或者函数名就要注意，这些在Python中是有特殊用途的。<br>，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p>
<h3 id="str-and-repr"><a href="#str-and-repr" class="headerlink" title="__str__ and__repr__"></a><code>__str__</code> and<code>__repr__</code></h3><p><code>__repr__</code>的目标是准确性<br><code>__str__</code>的目标是可读性<br>几乎你实现的所有对象都应该有一个用于理解对象的<code>__repr__</code>函数。实现<code>__str__</code>是可选的：如果你需要一个看起来较好的打印功能（比如用于产生报表）.<br>我们先定义一个Student类，打印一个实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">'Michael'</span>))</span><br><span class="line">&lt;__main__.Student object at <span class="number">0x109afb190</span>&gt;</span><br></pre></td></tr></table></figure>
<p>打印出一堆，不好看，也不是我们要的<br>定义好<code>__str__()</code>方法，返回一个好看的字符串就可以了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Student object (name: %s)'</span> % self.name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">'Michael'</span>))</span><br><span class="line">Student object (name: Michael)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接敲变量不用print，打印出来的实例还是不好看：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Michael'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&lt;__main__.Student object at <span class="number">0x109afb310</span></span><br></pre></td></tr></table></figure>
<p>直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说<code>，__repr__()</code>是为调试服务的。<br>因为通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的，所以就可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Student object (name=%s)'</span> % self.name</span><br><span class="line">    __repr__ = __str__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'wentao'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">Student object (name=wentao)</span><br></pre></td></tr></table></figure>
<h3 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a><code>__iter__</code></h3><p><code>__iter__()</code>方法，该方法返回一个迭代对象:<br>斐波那契数列为例，写一个Fib类，可以作用于for循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器a，b</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self <span class="comment"># 实例本身就是迭代对象，故返回自己</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = self.b, self.a + self.b <span class="comment"># 计算下一个值</span></span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>: <span class="comment"># 退出循环的条件</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration();</span><br><span class="line">        <span class="keyword">return</span> self.a <span class="comment"># 返回下一个值</span></span><br></pre></td></tr></table></figure>
<p>在，试试把Fib实例作用于for循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> Fib():</span><br><span class="line"><span class="meta">... </span>    print(n)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="number">46368</span></span><br><span class="line"><span class="number">75025</span></span><br></pre></td></tr></table></figure>
<h3 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a><code>__getitem__</code></h3><p>Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fib()[<span class="number">5</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'Fib'</span> object does <span class="keyword">not</span> support indexing</span><br></pre></td></tr></table></figure>
<p>要表现得像list那样按照下标取出元素，需要实现<code>__getitem__()</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<p>现在，就可以按下标访问数列的任意一项了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Fib()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">2</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">10</span>]</span><br><span class="line"><span class="number">89</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">100</span>]</span><br><span class="line"><span class="number">573147844013817084101</span></span><br></pre></td></tr></table></figure>
<p>但是list的切片方法：<br>对于Fib却报错。原因是<code>__getitem__()</code>传入的参数可能是一个<code>int</code>，也可能是一个切片对象<code>slice</code>，所以要做判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(n, int): <span class="comment"># n是索引</span></span><br><span class="line">            a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(n):</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">if</span> isinstance(n, slice): <span class="comment"># n是切片</span></span><br><span class="line">            start = n.start</span><br><span class="line">            stop = n.stop</span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                start = <span class="number">0</span></span><br><span class="line">            a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">            L = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(stop):</span><br><span class="line">                <span class="keyword">if</span> x &gt;= start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>
<p>此外，如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如str。</p>
<p>与之对应的是<code>__setitem__()</code>方法，把对象视作list或dict来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。<br>总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<h3 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a><code>__getattr__</code></h3><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。<br>要避免这个错误，除了可以加上一个我们要找的属性外，Python还有另一个机制，那就是写一个<code>__getattr__()</code>方法，<strong>动态返回一个属性</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'Michael'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">'score'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">99</span></span><br></pre></td></tr></table></figure>
<p>当调用不存在的属性时，比如<code>score</code>，Python解释器会试图调用<code>__getattr__(self, &#39;score&#39;)</code>来尝试获得属性，这样，我们就有机会返回<code>score</code>的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name</span><br><span class="line"><span class="string">'Michael'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score</span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.abc</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong><br>只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如name，不会在<code>__getattr__</code>中查找。<br>任意调用如<code>s.abc</code>都会返回<code>None</code>(就是什么都不显示)，这是因为我们定义的<code>__getattr__</code>默认返回就是<code>None</code>。<br>要让<code>class</code>只响应特定的几个属性，我们就要按照约定，抛出<code>AttributeError</code>的错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">'age'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">'\'Student\' object has no attribute \'%s\''</span> % attr)</span><br></pre></td></tr></table></figure>
<h3 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h3><p>当我们调用实例方法时，我们用<code>instance.method()</code>来调用。<br>任何类，只需要定义一个<strong>call</strong>()方法，就可以直接对实例进行调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lass Student(object):</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'My name is %s.'</span> % self.name)</span><br><span class="line"><span class="comment">#调用方式如下：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Michael'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s() <span class="comment"># self参数不要传入</span></span><br><span class="line">My name <span class="keyword">is</span> Michael.</span><br></pre></td></tr></table></figure>
<h3 id="小知识点-1"><a href="#小知识点-1" class="headerlink" title="小知识点"></a>小知识点</h3><p>通过<code>callable()</code>函数，我们就可以判断一个对象是否是“可调用”对象。</p>
<h2 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h2><p>Python提供了<code>Enum</code>类来实现这个功能：为枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。</p>
<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(<span class="string">'Month'</span>, (<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span>))</span><br></pre></td></tr></table></figure>
<p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    print(name, <span class="string">'=&gt;'</span>, member, <span class="string">','</span>, member.value)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从<code>1</code>开始计数。</p>
<p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>注意：<br><code>@unique</code>装饰器可以帮助我们检查保证没有重复值。</p>
<h2 id="访问的方法："><a href="#访问的方法：" class="headerlink" title="访问的方法："></a>访问的方法：</h2><p>既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>day1 = Weekday.Mon</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(day1)</span><br><span class="line">Weekday.Mon</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Weekday.Tue)</span><br><span class="line">Weekday.Tue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Weekday[<span class="string">'Tue'</span>])</span><br><span class="line">Weekday.Tue</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Weekday.Tue.value)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(day1 == Weekday.Mon)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(day1 == Weekday.Tue)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Weekday(<span class="number">1</span>))</span><br><span class="line">Weekday.Mon</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(day1 == Weekday(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Weekday(<span class="number">7</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/enum.py"</span>, line <span class="number">222</span>, <span class="keyword">in</span> __call__</span><br><span class="line">    <span class="keyword">return</span> cls.__new__(cls, value)</span><br><span class="line">  File <span class="string">"/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/enum.py"</span>, line <span class="number">457</span>, <span class="keyword">in</span> __new__</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"%r is not a valid %s"</span> % (value, cls.__name__))</span><br><span class="line">ValueError: <span class="number">7</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid Weekday</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Weekday(<span class="number">0</span>)</span><br><span class="line">&lt;Weekday.Sun: <span class="number">0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, member <span class="keyword">in</span> Weekday.__members__.items():</span><br><span class="line"><span class="meta">... </span>    print(name, <span class="string">'=&gt;'</span>, member)</span><br><span class="line">...</span><br><span class="line">Sun =&gt; Weekday.Sun</span><br><span class="line">Mon =&gt; Weekday.Mon</span><br><span class="line">Tue =&gt; Weekday.Tue</span><br><span class="line">Wed =&gt; Weekday.Wed</span><br><span class="line">Thu =&gt; Weekday.Thu</span><br><span class="line">Fri =&gt; Weekday.Fri</span><br><span class="line">Sat =&gt; Weekday.Sat</span><br></pre></td></tr></table></figure>
<h2 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h2><h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过<code>type()</code>函数创建出<code>Hello</code>类，而无需通过<code>class Hello(object)...</code>的定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(self, name=<span class="string">'world'</span>)</span>:</span> <span class="comment"># 先定义函数</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello, %s.'</span> % name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello = type(<span class="string">'Hello'</span>, (object,), dict(hello=fn)) <span class="comment"># 创建Hello class</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = Hello()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.hello()</span><br><span class="line">Hello, world.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(Hello))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(h)</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">Hello</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>要创建一个<code>class</code>对象，<code>type()</code>函数依次传入3个参数：</p>
<p>1.<code>class</code>的名称；<br>2.继承的父类集合，注意Python支持多重继承，<strong>如果只有一个父类，别忘了tuple的单元素写法</strong>   ；<br>3.<code>class</code>的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。</p>
<p>通过<code>type()</code>函数创建的类和直接写<code>class</code>是完全一样的，因为Python解释器遇到<code>class</code>定义时，仅仅是扫描一下<code>class</code>定义的语法，然后调用<code>type()</code>函数创建出<code>class</code>。</p>
<h3 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h3><p>metaclass，直译为元类.<br>metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。</p>
<h2 id="小知识点-2"><a href="#小知识点-2" class="headerlink" title="小知识点"></a>小知识点</h2><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。<br>正常情况下，我们都用class Xxx…来定义类，但是，type()函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.我的电脑是MAC，以下文字如无特别说明皆是针对OSX的设置及操作，请勿生搬硬套。<br>2.下面的程序一定要自己手打一遍，不要偷懒，不然要后悔的。<br>3.我是按照廖雪峰老师的教程学的，所以有的地方是一样一样的，大家可以当成是一个学习笔记，想学习的可以移步<a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰大大的博客</a>，那里真的好赞。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Python3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[打开Mac OSX的原生的NTFS功能]]></title>
      <url>/2015/09/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-OSX-%E6%89%93%E5%BC%80MacOSX%E7%9A%84%E5%8E%9F%E7%94%9F%E7%9A%84NTFS%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>对于新用户到了 Mac上, 或许多多少少都会遇到PC的移动硬盘无法写入的问题. 那是因为在 Mac 上并没有开放是支持Windows NTFS 格式硬盘的写入操作。<a id="more"></a>一种十分简单的方法是用第三方工具。虽说是简单，可是麻烦也不少，其本身并不稳定，容易丢数据不说，每次OSX更新，还必须得等软件更新后才能用。最主要的收费啊！！<br>实际在 OS X 10.9 后, 其实 OS X 自身就有兼容与支持 NTFS 文件的特性, 但不知何种原因, 被苹果隐藏了起来。下面就是打开MacOSX的原生的NTFS功能的方法</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="获取磁盘信息"><a href="#获取磁盘信息" class="headerlink" title="获取磁盘信息"></a>获取磁盘信息</h2><p>使用<code>diskutil list</code>命令查看到磁盘的Volume Name:<br>比如我的电脑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">************** &gt; diskutil list</span><br><span class="line">/dev/disk0 (internal, physical):</span><br><span class="line">   #:                       TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:      GUID_partition_scheme                        *240.1 GB   disk0</span><br><span class="line">   1:                        EFI EFI                     209.7 MB   disk0s1</span><br><span class="line">   2:                  Apple_HFS Macintosh SSD           239.2 GB   disk0s2</span><br><span class="line">   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3</span><br><span class="line">/dev/disk1 (internal, physical):</span><br><span class="line">   #:                       TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:      GUID_partition_scheme                        *500.1 GB   disk1</span><br><span class="line">   1:                        EFI EFI                     209.7 MB   disk1s1</span><br><span class="line">   2:                  Apple_HFS Macintosh HD            499.8 GB   disk1s2</span><br><span class="line">/dev/disk2 (external, physical):</span><br><span class="line">LABEL=move none ntfs rw,auto,nobrowse</span><br><span class="line">   #:                       TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:     FDisk_partition_scheme                        *500.1 GB   disk2</span><br><span class="line">   1:                  Apple_HFS backup                  350.1 GB   disk2s1</span><br><span class="line">   2:               Windows_NTFS move</span><br></pre></td></tr></table></figure>
<p>可以看到，我的 Volume Name 是<code>move</code></p>
<h2 id="更新-etc-fstab文件"><a href="#更新-etc-fstab文件" class="headerlink" title="更新 /etc/fstab文件"></a>更新 /etc/fstab文件</h2><p>输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br></pre></td></tr></table></figure>
<p>把以下内容写入进去:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL=move none ntfs rw,auto,nobrowse</span><br></pre></td></tr></table></figure>
<p>解释：<br>1.<code>nfts rw</code>表示:把分区挂载为可读写的ntfs格式，<br>2.<code>nobrowse</code>表示在finder里不显示这个分区，这个<strong>非常重要</strong>，如果不打开的话挂载是不会成功的。</p>
<p>编辑好以后重新插入磁盘，就可识别到了。但因为这个分区在finder里不显示。因为这个分区是挂<code>/Volumes</code>下的.所以将<code>/Volumes</code><br>我们把这个目录在桌面做一个快捷方式就行了。<br>输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /Volumes ~/Desktop/Volumes</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 方法 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> 应用 </tag>
            
            <tag> NTFS </tag>
            
            <tag> OSX </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python学习笔记-面向对象编程基础]]></title>
      <url>/2015/09/%E5%BE%85%E6%95%B4%E7%90%86/Python3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0007-OOP/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>面向对象编程——Object Oriented Programming，简称OOP。数据封装、继承和多态是面向对象的三大特点。<br>面向对象最重要的概念就是类（Class）和实例（Instance)。<br>本节的重点是：类和实例的关系及区别；继承和多态的定义及关系；获取对象的几种方法；实例属性和类属性的修改。<br><a id="more"></a></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>2015-09-04 笔记结构调整</p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。<br>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的 <strong>类（Class</strong> 的概念<br>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的 <strong>方法（Method)</strong></p>
<h2 id="Class-and-Instance"><a href="#Class-and-Instance" class="headerlink" title="Class and Instance"></a>Class and Instance</h2><p>1.类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>
<ol>
<li>类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；<br>3.方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；<br>4.通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。<br>5.和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：</li>
</ol>
<h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>是通过<code>class</code>关键字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><code>class</code>后面紧接着是类名，类名通常是<code>大写开头</code>的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p>
<p>定义好了<code>Student</code>类，就可以根据<code>Student</code>类创建出<code>Student</code>的实例，</p>
<h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>是通过<code>类名+()</code>实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart</span><br><span class="line">&lt;__main__.Student object at <span class="number">0x101c162e8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Student</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>，变量<code>bart</code>指向的就是一个<code>Student</code>的实例，后面的<code>0x10a67a590</code>是内存地址，每个<code>object</code>的地址都不一样，而Student本身则是一个类。</p>
<h3 id="绑定属性（赋值）"><a href="#绑定属性（赋值）" class="headerlink" title="绑定属性（赋值）"></a>绑定属性（赋值）</h3><p>可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.name = <span class="string">'Bart Simpson'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.name</span><br><span class="line"><span class="string">'Bart Simpson'</span></span><br></pre></td></tr></table></figure>
<p>类可以起到模板的作用。</p>
<h3 id="初始化-init"><a href="#初始化-init" class="headerlink" title="初始化__init__"></a>初始化<code>__init__</code></h3><p>在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure></p>
<p>注意<br>1.<code>__init__</code>方法的第一个参数永远是self，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。<br>2.在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">'Bart Simpson'</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.name</span><br><span class="line"><span class="string">'Bart Simpson'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.score</span><br><span class="line"><span class="number">59</span></span><br></pre></td></tr></table></figure></p>
<h3 id="类中定义的函数"><a href="#类中定义的函数" class="headerlink" title="类中定义的函数"></a>类中定义的函数</h3><p>与普通的函数相比，在类中定义的函数只有一点 <strong>不同</strong>，就是第一个参数永远是实例变量<code>self</code>。so仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>每个实体都有各自的数据。直接在Student类的内部定义访问数据的函数，这样，就把“数据”给<code>封装</code>起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为<code>类的方法</code>。（类的方法是一种函数）<br>封装的另一个好处是可以给<code>Student类</code>增加新的方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.score &gt;= <span class="number">90</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'A'</span></span><br><span class="line">        <span class="keyword">elif</span> self.score &gt;= <span class="number">60</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'B'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'C'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__开头</code>，就变成了一个私有变量<code>（private）</code>，只有内部可以访问，外部不能访问：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s: %s'</span> % (self.__name, self.__score))</span><br></pre></td></tr></table></figure></p>
<p>2.如果外部代码要获取name和score：可以给Student类增加<code>get_name</code>和<code>get_score</code>这样的方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br></pre></td></tr></table></figure></p>
<p>3.允许外部代码修改score：可以再给Student类增加<code>set_score</code>方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        self.__score = score</span><br></pre></td></tr></table></figure></p>
<p>注意：<br>1.变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是 <strong>特殊变量</strong>，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p>
<p>2.一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p>
<p>3.双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量。（但不要这么干！）</p>
<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>
<p>比如，我们已经编写了一个名为<code>Animal``的class，有一个run()</code>方法可以直接打印，当我们需要编写<code>Dog</code>和<code>Cat</code>类时，就可以直接从Animal类继承：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Animal is running...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承:"></a>继承:</h3><p>1.最大的好处是子类获得了父类的<strong>全部功能</strong>。<br>2.另一个好处：<strong>多态</strong>。当子类和父类都存在相同的方法(比如<code>run()</code>）时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。<br>3.在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，<strong>反过来就不行</strong></p>
<p>我们定义一个<code>class</code>的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如<code>str、list、dict</code>没什么两样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = list() <span class="comment"># a是list类型</span></span><br><span class="line">b = Animal() <span class="comment"># b是Animal类型</span></span><br><span class="line">c = Dog() <span class="comment"># c是Dog类型</span></span><br><span class="line"><span class="comment">#判断一个变量是否是某个类型可以用isinstance()判断：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(a, list)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(b, Animal)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(c, Dog)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#子类的数据类型也可以被看做是父类。但是，反过来就不行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(c, Animal)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(b, Dog)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态:"></a>多态:</h3><p>调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：<br>对扩展开放：允许新增<code>Animal</code>子类；<br>对修改封闭：不需要修改依赖Animal类型的<code>run_twice()</code>等函数。</p>
<h3 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h3><p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。<br>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：<br>动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><h3 id="使用type"><a href="#使用type" class="headerlink" title="使用type()"></a>使用type()</h3><p>基本类型都可以用type()判断：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本类型都可以用type()判断：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">123</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(<span class="string">'str'</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(None)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">type</span><span class="params">(None)</span> '<span class="title">NoneType</span>'&gt;</span></span><br><span class="line"><span class="class">#如果一个变量指向函数或者类，也可以用<span class="title">type</span><span class="params">()</span>判断：</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(abs)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">builtin_function_or_method</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(a)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">Animal</span>'&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>type()</code>函数返回的类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#判断基本数据类型：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">123</span>)==type(<span class="number">456</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">123</span>)==int</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">'abc'</span>)==type(<span class="string">'123'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">'abc'</span>)==str</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">'abc'</span>)==type(<span class="number">123</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#要判断一个对象是否是函数可以使用types模块中定义的常量：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(fn)==types.FunctionType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(abs)==types.BuiltinFunctionType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="keyword">lambda</span> x: x)==types.LambdaType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)))==types.GeneratorType</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用isinstance()</h3><p><code>isinstance()</code>判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。<br>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断。<br>并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是<code>list</code>或者<code>tuple</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (list, tuple))</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (list, tuple))</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="属性的继承"><a href="#属性的继承" class="headerlink" title="属性的继承"></a>属性的继承</h3><p>如果继承关系是：<br><code>object -&gt; Animal -&gt; Dog -&gt; Husky</code><br>创建3种类型的对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Animal()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = Husky()</span><br></pre></td></tr></table></figure>
<p>可知：<br><code>h</code>虽然自身是<code>Husky</code>类型，但由于<code>Husky</code>是从<code>Dog</code>继承下来的，所以，<code>h</code>也还是D<code>og</code>类<br><code>Dog</code>的<code>d</code>也是<code>Animal</code>类型：但是<code>d</code>不是<code>Husky</code>类型。</p>
<h3 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用dir()</h3><p>用来获得一个对象的<strong>所有</strong>属性和方法。</p>
<p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.__len__()</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个函数：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.x = <span class="number">9</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.x * self.x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = MyObject()</span><br><span class="line"></span><br><span class="line"><span class="comment">#紧接着，可以测试该对象的属性：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'x'</span>) <span class="comment"># 有属性'x'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.x</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(obj, <span class="string">'y'</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性'y'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'y'</span>) <span class="comment"># 获取属性'y'</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.y <span class="comment"># 获取属性'y'</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以传入一个default参数，如果属性不存在，就返回默认值：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'z'</span>, <span class="number">404</span>) <span class="comment"># 获取属性'z'，如果不存在，返回默认值404</span></span><br><span class="line"><span class="number">404</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以获得对象的方法：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'power'</span>) <span class="comment"># 有属性'power'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn = getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'并赋值到变量fn</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn <span class="comment"># fn指向obj.power</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn() <span class="comment"># 调用fn()与调用obj.power()是一样的</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure></p>
<p>通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。</p>
<h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>Python是动态语言，根据类创建的实例可以 <strong>任意</strong> 绑定属性。<br>注意：<br>1.给实例绑定属性的方法是通过实例变量，或者通过self变量。<br>2.定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。<br>3.在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。<br>看例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    name = <span class="string">'Student'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建实例s</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name) <span class="comment"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student.name) <span class="comment"># 打印类的name属性</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">'Michael'</span> <span class="comment"># 给实例绑定name属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name) <span class="comment"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span></span><br><span class="line">Michael</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student.name) <span class="comment"># 但是类属性并未消失，用Student.name仍然可以访问</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s.name <span class="comment"># 如果删除实例的name属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name) <span class="comment"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span></span><br><span class="line">Student</span><br></pre></td></tr></table></figure>
<h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><p><code>lower()</code>返回小写的字符串。<br><code>len()</code>函数获取一个对象的长度。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.我的电脑是MAC，以下文字如无特别说明皆是针对OSX的设置及操作，请勿生搬硬套。<br>2.下面的程序一定要自己手打一遍，不要偷懒，不然要后悔的。<br>3.我是按照廖雪峰老师的教程学的，所以有的地方是一样一样的，大家可以当成是一个学习笔记，想学习的可以移步<a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰大大的博客</a>，那里真的好赞。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Python3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python的学习笔记006-模块]]></title>
      <url>/2015/08/%E5%BE%85%E6%95%B4%E7%90%86/Python3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0006-%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。<a id="more"></a></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="模块（java中的类）"><a href="#模块（java中的类）" class="headerlink" title="模块（java中的类）"></a>模块（java中的类）</h2><p>相同名字的函数和变量完全可以分别存在不同的模块中，使用模块还可以避免函数名和变量名冲突。我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。<br>为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。<br>每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是<code>mycompany</code>。<br>可以有多级目录，组成多级层次的包结构。</p>
<h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">' a test module '</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'wente guo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	args = sys.argv</span><br><span class="line">	<span class="keyword">if</span> len(args) == <span class="number">1</span>:</span><br><span class="line">		print(<span class="string">'hello, world'</span>)</span><br><span class="line">	<span class="keyword">elif</span> len(args) == <span class="number">2</span>:</span><br><span class="line">		print(<span class="string">'hell, %s!'</span> % args[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		print(<span class="string">'too many argument!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	test()</span><br></pre></td></tr></table></figure>
<p>第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在<code>Unix/Linux/Mac</code>上运行，第2行注释表示.py文件本身使用标准UTF-8编码；<br>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；<br>第6行使用<strong>author</strong>变量把作者写进去；<br>第8行：导入sys模块;</p>
<p>主函数：<br> <code>sys</code> 模块有一个<code>argv</code>变量，用list存储了命令行的所有参数。<code>argv</code>至少有一个元素，因为第一个参数永远是该<code>.py</code>文件的名称，例如：<br>运行<code>python3 hello.py</code>获得的<code>sys.argv</code>就是<code>[&#39;hello.py&#39;]</code>；<br>运行<code>python3 hello.py Michael</code>获得的sys.argv就是<code>[&#39;hello.py&#39;, &#39;Michael]。</code></p>
<p>最后两行：<br>当我们在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，<strong>最常见的就是运行测试。</strong></p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>1.常的函数和变量名是 <strong>公开的（public）</strong>，可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等；</p>
<p>2.类似 <code>__xxx__</code> 这样的变量是 <strong>特殊变量</strong>，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，hello模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</p>
<p>3.类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是 <strong>非公开的（private）</strong>，<strong>不应该</strong> 被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p>
<p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。（java也是这个样子的，）</p>
<h2 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h2><p>装第三方模块，是通过包管理工具<code>pip</code>完成的。<br>Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是pip3。<br>第8行：导入sys模块三方库都会在Python官方的<a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">pypi.python.org</a>网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者<a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">pypi</a>上搜索，比如<code>Pillow</code>的名称叫<code>Pillow</code>，因此，安装Pillow的命令就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Pillow</span><br></pre></td></tr></table></figure>
<p>其他常用的第三方库还有MySQL的驱动：<code>mysql-connector-python</code>，用于科学计算的NumPy库：<code>numpy</code>，用于生成文本的模板工具<code>Jinja2</code>，等等。</p>
<h2 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h2><p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的<code>.py</code>文件，如果找不到，就会报错：<br>情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">''</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.4/lib/python34.zip'</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4'</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/plat-darwin'</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/lib-dynload'</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages'</span>]</span><br></pre></td></tr></table></figure>
<p>如果我们要添加自己的搜索目录，有两种方法：</p>
<p>1.直接修改sys.path，添加要搜索的目录.这种方法是在运行时修改，运行结束后失效。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.append(<span class="string">'/Users/michael/my_py_scripts'</span>)</span><br></pre></td></tr></table></figure>
<p>2.是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.我的电脑是MAC，以下文字如无特别说明皆是针对OSX的设置及操作，请勿生搬硬套。<br>2.下面的程序一定要自己手打一遍，不要偷懒，不然要后悔的。<br>3.我是按照廖雪峰老师的教程学的，所以有的地方是一样一样的，大家可以当成是一个学习笔记，想学习的可以移步<a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰大大的博客</a>，那里真的好赞。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Python3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python的学习笔记005-Functional Programming]]></title>
      <url>/2015/08/%E5%BE%85%E6%95%B4%E7%90%86/Python3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0005-FunctionalProgramming/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本节的笔记主要是：<br>我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之 为 <strong>面向过程的程序设计</strong> 。函数就是面向过程的程序设计的基本单元。<br>纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用<br>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！<a id="more"></a></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="Higher-order-function"><a href="#Higher-order-function" class="headerlink" title="Higher-order function"></a>Higher-order function</h2><h3 id="变量可以指向函数"><a href="#变量可以指向函数" class="headerlink" title="变量可以指向函数"></a>变量可以指向函数</h3><p>函数本身也可以赋值给变量，即：变量可以指向函数。</p>
<h3 id="函数名也是变量"><a href="#函数名也是变量" class="headerlink" title="函数名也是变量"></a>函数名也是变量</h3><p>函数名其实就是指向函数的变量。对于<code>abs()</code>这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数。so，他也可以指向一个数。（不要这么用啊，易错！）</p>
<h3 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h3><p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。<br>一个最简单的高阶函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y, f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y)</span><br></pre></td></tr></table></figure>
<p>用代码验证一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">-5</span>, <span class="number">6</span>, abs)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(r)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>
<p><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是:<br><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code><br>如：要把序列<code>[1, 3, 5, 7, 9]</code>变换成整数<code>13579</code>，<code>reduce</code>就可以派上用场：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="number">13479</span></span><br></pre></td></tr></table></figure>
<p>实例：<code>str2int</code>的函数就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2int</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>&#125;[s]</span><br><span class="line">    <span class="keyword">return</span> reduce(fn, map(char2num, s))</span><br></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>Python内建的<code>filter()</code>函数用于过滤序列。</p>
<p>和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的时，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p>
<p><strong>注意</strong> 到<code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回list。</p>
<p>在一个list中，删掉偶数，只保留奇数，可以这么写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">list(filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>]))</span><br><span class="line"><span class="comment"># 结果: [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>通常规定，对于两个元素x和y，如果认为<code>x &lt; y</code>，则返回<code>-1</code>，如果认为<code>x == y</code>，则返回<code>0</code>，如果认为<code>x &gt; y</code>，则返回<code>1</code>，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。</p>
<p>Python内置的<code>sorted()</code>函数就可以对list进行排序,<br>1.对数字，默认按大小的；<br>2.对字符串排序，默认情况下，是按照<code>ASCII</code>的大小比较的，由于<code>&#39;Z&#39; &lt; &#39;a&#39;</code>，结果，大写字母Z会排在小写字母a的前面。<strong><em>易错</em></strong><br>3.<code>sorted()</code>函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序。<br>几个例子：<br>1.按绝对值大小排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=abs)</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">-12</span>, <span class="number">-21</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure>
<p>然后<code>sorted()</code>函数按照keys进行排序，并按照对应关系返回list相应的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keys排序结果 =&gt; [5, 9,  12,  21, 36]</span><br><span class="line">                |  |    |    |   |</span><br><span class="line">最终结果     =&gt; [5, 9, -12, -21, 36]</span><br></pre></td></tr></table></figure></p>
<p>2.字符串排序的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>])</span><br><span class="line">[<span class="string">'Credit'</span>, <span class="string">'Zoo'</span>, <span class="string">'about'</span>, <span class="string">'bob'</span>]</span><br><span class="line"><span class="comment">#忽略大小写的排序：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower)</span><br><span class="line">[<span class="string">'about'</span>, <span class="string">'bob'</span>, <span class="string">'Credit'</span>, <span class="string">'Zoo'</span>]</span><br><span class="line"><span class="comment">#进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower, reverse=<span class="keyword">True</span>)</span><br><span class="line">[<span class="string">'Zoo'</span>, <span class="string">'Credit'</span>, <span class="string">'bob'</span>, <span class="string">'about'</span>]</span><br></pre></td></tr></table></figure></p>
<p>可以看到：行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True：</code></p>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">        ax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数.调用函数f时，才真正计算求和的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at <span class="number">0x101c6ed90</span>&gt;</span><br><span class="line"><span class="comment">#调用函数f时，才真正计算求和的结果：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>我们调用<code>lazy_sum()</code>时，每次调用都会返回一个新的函数，即使传入相同的参数。刚两个结果是独立的。</p>
<p>在这个例子中，我们在函数<code>lazy_sum</code>中又定义了函数sum，并且，内部函数sum可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>这是 Theoritical computer science 里出的术语：不引用外部变量的 lambda 表达式是「封闭的」（Closed），那么把「开放的」表达式「封闭住」的东西，就是 Closure 了。</p>
<p>上节返回的函数并没有立刻执行，而是直到调用了f()才执行。<br>1.<strong><em>返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。</em></strong>。比如：不要引用任何循环变量，或者后续会发生变化的变量。</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br></pre></td></tr></table></figure>
<p>你可能认为调用<code>f1()，f2()和f3()</code>结果应该是<code>1，4，9，</code>但实际结果是：<code>9,9,9</code>。</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>1.匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。<br>2.用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。<br>3.匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。<br>4.也可以把匿名函数作为返回值返回。<br>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>
<p>匿名函数<code>lambda x: x * x</code>: 关键字<code>lambda</code>表示匿名函数，<code>冒号</code>前面的<code>x</code>表示函数参数。</p>
<h2 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h2><p>函数对象有一个<code>__name__</code>属性，可以拿到函数的名字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</span><br><span class="line"><span class="string">'now'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__name__</span><br><span class="line"><span class="string">'now'</span></span><br></pre></td></tr></table></figure>
<p>假设我们要增强<code>now()</code>函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。<br>我们要定义一个能打印日志的decorator，可以定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>将<code>decorator</code>置于函数的定义处：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'2015-3-25'</span>)</span><br></pre></td></tr></table></figure>
<p>调用<code>now()</code>函数，不仅会运行<code>now()</code>函数本身，还会在运行<code>now()</code>函数前打印一行日志：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">call now():</span><br><span class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></span><br></pre></td></tr></table></figure>
<p>说明：<br>1.把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句：<code>now = log(now)</code><br>由于<code>log()</code>是一个<code>decorator</code>，返回一个函数，所以，原来的<code>now()</code>函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用<code>now()</code>将执行新函数，即在<code>log()</code>函数中返回的<code>wrapper()</code>函数。<br>2.<code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数<strong>可以接受任意参数的调用</strong>。在<code>wrapper()</code>函数内，首先打印日志，再紧接着调用原始函数。<br>3.函数也是对象，它有<code>__name__</code>等属性，但你去看经过decorator装饰之后的函数，它们的<code>__name__</code>已经从原来的<code>&#39;now&#39;</code>变成了<code>&#39;wrapper&#39;</code>。返回的那个<code>wrapper()</code>函数名字就是<code>&#39;wrapper&#39;</code>，所以，需要Python内置的<code>functools.wraps</code>把原始函数的<code>__name__</code>等属性复制到<code>wrapper()</code>函数中，否则，有些依赖函数签名的代码执行就会出错。方法:<br>在定义<code>wrapper()</code>的前面加上<code>@functools.wraps(func)</code>即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<h2 id="Partial-function"><a href="#Partial-function" class="headerlink" title="Partial function"></a>Partial function</h2><p>当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以<strong>固定住原函数的部分参数</strong>，从而在调用时更简单。</p>
<p><code>int()</code>函数可以把字符串转换为整数，当仅传入字符串时，<code>int()</code>函数默认按十进制转换：<br>但<code>int()</code>函数还提供额外的<code>base</code>参数，默认值为10。如果传入<code>base</code>参数，就可以做N进制的转换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'12345'</span>)</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'12345'</span>, base=<span class="number">8</span>)</span><br><span class="line"><span class="number">5349</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'12345'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">74565</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'1000000'</span>, base=<span class="number">8</span>)</span><br><span class="line"><span class="number">64</span></span><br></pre></td></tr></table></figure>
<p>每次都传入int(x, base=2)非常麻烦。<code>functools.partial</code>就是帮助我们创建一个 <strong><em>偏函数</em></strong> 的，可以直接使用下面的代码创建一个新的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1010101'</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.我的电脑是MAC，以下文字如无特别说明皆是针对OSX的设置及操作，请勿生搬硬套。<br>2.下面的程序一定要自己手打一遍，不要偷懒，不然要后悔的。<br>3.我是按照廖雪峰老师的教程学的，所以有的地方是一样一样的，大家可以当成是一个学习笔记，想学习的可以移步<a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰大大的博客</a>，那里真的好赞。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 编程 </tag>
            
            <tag> Python3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python的学习笔记003-Function]]></title>
      <url>/2015/08/%E5%BE%85%E6%95%B4%E7%90%86/Python3-%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本节的笔记主要是：<br>1.我的电脑是MAC，以下文字如无特别说明皆是针对OSX的设置及操作，请勿生搬硬套。<br>2.下面的程序一定要自己手打一遍，不要偷懒，不然要后悔的。<br>3.我是按照廖雪峰老师的教程学的，所以有的地方是一样一样的，大家可以当成是一个学习笔记，想学习的可以移步<a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰大大的博客</a>，那里真的好赞。<a id="more"></a></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><h3 id="如何调用"><a href="#如何调用" class="headerlink" title="如何调用"></a>如何调用</h3><p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误。<br>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型。<br>比如函:<br>绝对值函数：<code>abs()</code> 其只有一个参数，参数类型是数字。<br>而max函数<code>max()</code>可以接收任意多个参数，并返回最大的那个.</p>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>Python内置的常用函数还包括数据类型转换函数，比如<code>int()</code>函数可以把其他数据类型转换为整数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'123'</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">12.34</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(<span class="string">'12.34'</span>)</span><br><span class="line"><span class="number">12.34</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">1.23</span>)</span><br><span class="line"><span class="string">'1.23'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">100</span>)</span><br><span class="line"><span class="string">'100'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = abs <span class="comment"># 变量a指向abs函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">-1</span>) <span class="comment"># 所以也可以通过a调用abs函数</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><h3 id="如何定义"><a href="#如何定义" class="headerlink" title="如何定义"></a>如何定义</h3><p>定义一个函数要使用<code>def</code>语句，依次写出<code>函数名、括号、括号中的参数和冒号:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。</p>
<p>注意：<br>函数体内部的语句在执行时，一旦执行到<code>return</code>时，函数就执行完毕，并将结果返回。<br>如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为None。<br><code>return None</code>可以简写为<code>return</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>
<h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><p>如果想定义一个什么事也不做的空函数(一般用来先占个位子)，可以用<code>pass</code>语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><code>pass</code>还可以用在其他语句里，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>缺少了<code>pass</code>，代码运行就会有语法错误。</p>
<h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>调用函数时，<br>如果<code>参数个数不对</code>，Python解释器会自动检查出来，并抛出<code>TypeError</code>;<br>如果<code>参数类型不对</code>，Python解释器就无法帮我们检查。<strong>所以函数定义中要加入数据类型检查</strong><br>其可以用内置函数<code>isinstance()</code>实现：<br>如我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (int, float)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'bad operand type'</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>
<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>Python可以同时返返回多个值。<br>Python的函数返回多值其实就是返回一个<code>tuple</code>。</p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p><code>power(x, n)</code>函数有两个参数：<code>x</code>和<code>n</code>，这两个参数都是位置参数，调用函数时，传入的两个值<strong><em>按照位置顺序</em></strong>依次赋给参数x和n。</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ef enroll(name, gender, age=<span class="number">6</span>, city=<span class="string">'Beijing'</span>):</span><br><span class="line">    print(<span class="string">'name:'</span>, name)</span><br><span class="line">    print(<span class="string">'gender:'</span>, gender)</span><br><span class="line">    print(<span class="string">'age:'</span>, age)</span><br><span class="line">    print(<span class="string">'city:'</span>, city)</span><br></pre></td></tr></table></figure>
<p>默认参数可以简化函数的调用。设置默认参数时，有几点要注意：<br>1.是必选参数在前，默认参数在后，否则Python的解释器会报错;<br>2.是如何设置默认参数。<br>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p>
<p>有多个默认参数时，调用的时候，：<br>1.可以按顺序提供默认参数。<br>2.可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll(&#39;Adam&#39;, &#39;M&#39;, city=&#39;Tianjin&#39;)</code>，意思是，city参数用传进去的值，其他默认参数继续使用默认值。</p>
<p><strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></p>
<p>常见的有<code>NONE</code> <code>STR</code></p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p><code>*args</code>是可变参数，args接收的是一个tuple。</p>
<p>可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。<br>以前用的笨的方法：list/tuple函数可以定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure></p>
<p>但是调用的时候，需要先组装出一个list或tuple：<strong>（易错点）</strong>（也比较麻烦）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc([1, 2, 3])</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc((1, 3, 5, 7))</span><br><span class="line">84</span><br></pre></td></tr></table></figure>
<p>定义可变参数和定义一个<code>list</code>或<code>tuple</code>参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure></p>
<p>调用：<br>1.可变参数既可以直接传入：<code>func(1, 2, 3)</code>；<br>2.又可以先组装list或tuple，再通过<code>*args传入：func(*(1, 2, 3))；</code>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*nums)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p><code>**kw</code>是关键字参数，kw接收的是一个dict。<br>关键字参数可以扩展函数的功能。<br>使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br></pre></td></tr></table></figure>
<p>调用：<br>1.可以只传入必选参数：<br>2.也可以传入任意个数的关键字参数：<code>func(a=1, b=2)</code>，<br>3.和可变参数类似，也可以又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code>。</p>
<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>如果要限制关键字参数的名字，就可以用命名关键字参数;<br>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。<br>定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure></p>
<p>调用：<br>命名关键字参数<strong>必须传入参数名</strong>，这和位置参数不同。如果没有传入参数名，调用将报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">Jack <span class="number">24</span> Beijing Engineer</span><br></pre></td></tr></table></figure>
<p>命名关键字参数同时可以提供默认值。,这样调用时就可以不传入。</p>
<p><strong>要特别注意</strong>，<code>*</code>不是参数，而是特殊分隔符。如果缺少<code>*</code>，Python解释器将无法识别位置参数和命名关键字参数；</p>
<h3 id="参数组合："><a href="#参数组合：" class="headerlink" title="参数组合："></a>参数组合：</h3><p>5种参数都可以组合使用，除了可变参数无法和命名关键字参数混合。 但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数/命名关键字参数和关键字参数。</p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p>
<p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p>
<p>Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 编程 </tag>
            
            <tag> Python3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python3-数据结构及常用操作]]></title>
      <url>/2015/08/%E5%BE%85%E6%95%B4%E7%90%86/Python3-%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本节的笔记主要是：list tupler 的对比；dict和set的区别；<br>1.我的电脑是MAC，以下文字如无特别说明皆是针对OSX的设置及操作，请勿生搬硬套。<br>2.下面的程序一定要自己手打一遍，不要偷懒，不然要后悔的。<br>3.我是按照廖雪峰老师的教程学的，所以有的地方是一样一样的，大家可以当成是一个学习笔记，想学习的可以移步<a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰大大的博客</a>，那里真的好赞。<br><a id="more"></a></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>2016-04-07 重新排班 合并<br>2015-08-29 新增 迭代器 wiki<br>2015-08-29 新增 惰性计算概念</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>list是一种有序的集合，可以随时添加和删除其中的元素。</p>
<p>列出班里所有同学的名字，就可以用一个list表示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：定义用的是方括号！！！</strong></p>
<p>1.可以用<code>len()</code>函数可以获得list元素的个数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(classmates)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>2.用索引来访问list中每一个位置的元素，记得<strong>索引是从0开始</strong>的：，要确保索引不要越界，记得最后一个元素的索引是<code>len(classmates) - 1</code>。</p>
<p>3.如果要取最后一个元素，除了计算索引位置外，还可以用<code>-1</code>做索引，直接获取最后一个元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">0</span>]</span><br><span class="line"><span class="string">'Michael'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-1</span>]</span><br><span class="line"><span class="string">'Tracy'</span></span><br></pre></td></tr></table></figure>
<p>4.list是一个可变的有序表，所以，可以往list中追加元素到末尾：使用<code>listname.append(&#39;要加入的&#39;)</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">'Adam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</span><br></pre></td></tr></table></figure></p>
<p>5.也可以把元素插入到指定的位置，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.insert(<span class="number">1</span>, <span class="string">'Jack'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</span><br></pre></td></tr></table></figure></p>
<p>6.要删除指定位置的元素，用<code>pop(i)</code>方法，其中i是索引位置;要删除list末尾的元素，用<code>pop()</code>方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">1</span>)</span><br><span class="line"><span class="string">'Jack'</span></span><br></pre></td></tr></table></figure></p>
<p>7.要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>] = <span class="string">'Sarah'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></p>
<p>8.list里面的元素的数据类型也可以不同; list也可以是空的，那他的长度为0；list元素也可以是另一个list（可以看成是一个二维数组）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = [<span class="string">'asp'</span>, <span class="string">'php'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, p, <span class="string">'scheme'</span>]</span><br></pre></td></tr></table></figure></p>
<p>1) <strong>要注意，S的长度是4个单位</strong>，不是5个。<strong><em>(易错点）</em></strong><br>2)要拿到<code>&#39;php&#39;</code>可以写<code>p[1]</code>或者<code>s[2][1]</code>;<br>3)我们也可以通过<code>s[2][1]</code>拿到<code>‘java’</code>中的<code>a</code>;（python果然很随便啊）<br>4)这样写一个二维数组也是合法的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, [<span class="string">'asp'</span>, <span class="string">'php'</span>], <span class="string">'scheme'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>tuple和list非常类似，但是tuple <strong>一旦初始化就不能修改</strong> 。也就是说不可变的！<br><strong>技巧：因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple</strong></p>
<p>1.定义 tuple 与定义 list 的方式相同，但整个元素集是用 <strong>小括号</strong> 包围的，而不是方括号。</p>
<p>2.当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来;  如果要定义一个空的tuple，可以写成<code>()</code>; 1个元素的tuple定义时 <strong>必须加一个逗号</strong>,，来消除歧义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure></p>
<p>3.可以在tuple里面定义一个list,做成一个二维的数组，那tuple就可变了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'X'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'Y'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'X'</span>, <span class="string">'Y'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储。<br><strong>注意</strong></p>
<ol>
<li>dict内部存放的顺序和key放入的顺序是没有关系的。</li>
<li>正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。</li>
</ol>
<p>在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key。。</p>
<p>和list比较，dict有以下几个特点：</p>
<ol>
<li>查找和插入的速度极快，不会随着key的增加而增加；</li>
<li>需要占用大量的内存，内存浪费多。</li>
</ol>
<p>而list相反：</p>
<ol>
<li>查找和插入的时间随着元素的增加而增加；</li>
<li>占用空间小，浪费内存很少。</li>
</ol>
<p>所以，dict是用空间来换取时间的一种方法。<br>使用方法：</p>
<ol>
<li>初始化：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>]</span><br><span class="line"><span class="number">95</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>易错</strong>： 注意<code>：</code>和<code>,</code>后的空格！</p>
<ol>
<li>通过key放入值:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Adam'</span>] = <span class="number">67</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Adam'</span>]</span><br><span class="line"><span class="number">67</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意：</strong> 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<p>赋值时如果key不存在，dict就会报错；要避免key不存在的错误，有两种办法：</p>
<ol>
<li><p>是:通过<code>in</code>判断key是否存在：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Thomas'</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>:通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="number">-10</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意</strong>：返回None的时候Python的交互式命令行不显示结果。</p>
<p>3.要删除一个key，用pop(key)方法，对应的value也会从dict中删除：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ol>
<li><p>在set中，没有重复的key.</p>
</li>
<li><p>传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，<strong>显示的顺序也不表示set是有序的</strong>。重复元素在set中自动被过滤：</p>
</li>
</ol>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>命令：<br>1.要创建一个set，需要提供一个list作为输入集合，其中重复元素在set中自动被过滤：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.通过<code>remove(key)</code>方法可以删除元素:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h2><p>不可变对象：<code>int</code>，<code>string</code>，<code>float</code>，<code>tuple</code><br>可变对象   ：<code>list</code>，<code>dictionary</code></p>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>而对于不可变对象，比如str，对str进行操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.replace(<span class="string">'a'</span>, <span class="string">'A'</span>)</span><br><span class="line"><span class="string">'Abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'abc'</span></span><br></pre></td></tr></table></figure>
<p>可见：对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片就是取一个list或tuple的部分元素用的操作符。<br>有了切片操作，很多地方循环就不再需要了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:<span class="number">-1</span>]</span><br><span class="line">[<span class="string">'Bob'</span>]</span><br></pre></td></tr></table></figure>
<p>1.<code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引3为止，但不包括索引<code>3</code>。即索引<code>0</code>，<code>1</code>，<code>2</code>，正好是3个元素.\<br>2.如果第一个索引是0，还可以省略;<br>3.也可以从索引1开始，取出2个元素出来;<br>4.那么它同样支持倒数切片，<strong>记住倒数第一个元素的索引是-1。</strong><br>5.么都不写，只写<code>[:]</code>就可以原样复制一个list.<br>6.可以通过切片轻松取出<strong>某一段数列</strong>。<br>后10个数：<code>L[-10:]</code>;前11-20个数：<code>L[10:20]</code><br>7.还可以跳着取：<br>前10个数，每两个取一个：<code>L[:10:2]</code><br>所有数，每5个取一个：<code>L[::5]</code><br>8.字符串也可以用切片操作，只是操作结果仍是字符串：</p>
<h2 id="Iterration"><a href="#Iterration" class="headerlink" title="Iterration"></a>Iterration</h2><p>在Python中，迭代是通过<code>for ... in</code>来完成的。</p>
<p>默认情况下，dict迭代的是<code>key</code>。如果要迭代<code>value</code>，可以用<code>for value in d.values()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.items()</code>。<br>由于字符串也是可迭代对象，因此，也可以作用于for循环：</p>
<p>判断一个对象是可迭代对象：<br>通过<code>collections模块</code>的<code>Iterable</code>类型判断：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterable) <span class="comment"># str是否可迭代</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, Iterable) <span class="comment"># 整数是否可迭代</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>Python内置的<code>enumerate</code>函数可以把一个list变成<code>索引-元素对</code>，这样就可以在for循环中同时迭代索引和元素本身：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  &gt;&gt;&gt; <span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, value)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> A</span><br><span class="line"><span class="number">1</span> B</span><br><span class="line"><span class="number">2</span> c</span><br></pre></td></tr></table></figure></p>
<h2 id="List-Comprehensions"><a href="#List-Comprehensions" class="headerlink" title="List Comprehensions"></a>List Comprehensions</h2><p>要生成<code>[1x1, 2x2, 3x3, ..., 10x10]</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure></p>
<p>写列表生成式时，把要生成的元素<code>x * x</code>放到前面，后面跟<code>for</code>循环，就可以把list创建出来.</p>
<p>1.<code>for</code>循环后面还可以 <strong>加上<code>if</code>判断</strong>，这样我们就可以筛选出仅偶数的平方：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure></p>
<p>2.还可以使用 <strong>两层循环</strong>，可以生成全排列：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</span><br></pre></td></tr></table></figure></p>
<p>3.列表生成式也可以使用 <strong>两个变量</strong> 来生成list：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br><span class="line">[<span class="string">'y=B'</span>, <span class="string">'x=A'</span>, <span class="string">'z=C'</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>1.创建一个<code>generator</code>:<br>有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个<code>generator</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>打印出generator的每一个元素：<br>1.一个一个打印出来，可以通过<code>next()</code>函数获得generator的下一个返回值：gnerator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。必须给我<br>2.正确的方法是使用<code>for</code>循环，<strong>并且不需要关心StopIteration的错误。</strong><br>因为<code>generator</code>也是可迭代对象。</p>
<p>函数定义generator<br>如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。<br>如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator，例如定义FIBONNACCI:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br></pre></td></tr></table></figure>
<p><em>generator和函数的执行流程不一样</em>：<br>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。<br>把函数改成generator后，我们基本上从来不会用<code>next()</code>来获取下一个返回值，而是直接使用<code>for循环</code>来迭代：</p>
<p>但是用<code>for循环</code>调用generator时，发现拿不到generator的<code>return语句</code>的返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的value中。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>可以直接作用于for循环的数据类型有以下几种：<br>一类是集合数据类型，如<code>list、tuple、dict、set、str</code>等；<br>一类是generator，包括生成器和带<code>yield</code>的<code>generator</code> <code>function</code>。<br>这些可以直接作用于for循环的对象统称为 <strong>可迭代对象</strong>：<code>Iterable</code>。<br>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：<strong><em>注意与Iterator对象的区别！！</em></strong></p>
<p>生成器不但可以作用于<code>for</code>循环，还可以被<code>next()</code>函数不断调用并返回下一个值，直到最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值了。</p>
<p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为 <strong>迭代器</strong>：<code>Iterator。</code><br>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict、str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p>
<p>把<code>list、dict、str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter([]), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(<span class="string">'abc'</span>), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的。</p>
<h3 id="新增-迭代器-wiki"><a href="#新增-迭代器-wiki" class="headerlink" title="新增 迭代器 wiki"></a>新增 迭代器 wiki</h3><p><a href="https://zh.wikipedia.org/wiki/迭代器" target="_blank" rel="noopener">迭代器 wiki</a>:<br>在Python中，迭代器是遵循迭代协议的对象。使用<code>iter()</code>从任何序列对象中得到迭代器（如<code>list, tuple, dictionary, set</code>等）。另一种形式的输入迭代器是<code>generator。</code><br>要使得迭代器指向下一个元素，则使用成员函数<code>next()（Python 2）</code>或函数<code>next()（Python 3）</code>。当没有元素时，则引发<code>StopIteration</code>异常。若要实现迭代器，则需要在类中定义<code>next()（Python 2）</code>或<code>__next__()（Python 3）</code>。</p>
<h3 id="新增-惰性计算"><a href="#新增-惰性计算" class="headerlink" title="新增 惰性计算"></a>新增 惰性计算</h3><p>惰性计算是函数式编程语言的一个特性。在使用惰性计算时，表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。惰性计算有如下优点：</p>
<ol>
<li>你可以用它们来创建无限序列这样一种数据类型。因为直到需要时才会计算值，这样就可以使用惰性集合模拟无限序列。</li>
<li>减少了存储空间。因为在真正需要时才会发生计算。所以，节约了不必要的存储空间。</li>
<li>减少计算量，产生更高效的代码。因为在真正需要时才会发生计算。例如，寻找数组中第一个符合某个条件的值。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Python3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python3基础知识（二)-控制流]]></title>
      <url>/2015/08/%E5%BE%85%E6%95%B4%E7%90%86/Python3-%E7%AC%94%E8%AE%B0-%E5%88%A4%E6%96%AD%E5%BE%AA%E7%8E%AF%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84list,dict,tuple/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本节的笔记主要是：条件判断；循环<br>1.我的电脑是MAC，以下文字如无特别说明皆是针对OSX的设置及操作，请勿生搬硬套。<br>2.下面的程序一定要自己手打一遍，不要偷懒，不然要后悔的。<br>3.我是按照廖雪峰老师的教程学的，所以有的地方是一样一样的，大家可以当成是一个学习笔记，想学习的可以移步<a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰大大的博客</a>，那里真的好赞。<br><a id="more"></a></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>2015-08-27 新增：for 补充笔记</p>
<p>##条件判断</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    print(<span class="string">'teenager'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'kid'</span>)</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li><p>缩进规则；</p>
</li>
<li><p><code>else:</code>不要少写了冒号<code>:</code>。</p>
</li>
<li><p><code>elif</code>是else if的缩写，完全可以有多个<code>elif</code>,</p>
</li>
<li><p>if判断条件还可以简写，比如写：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">    print(<span class="string">'True'</span>)</span><br></pre></td></tr></table></figure>
<p>只要x是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p>
<h3 id="input的易错"><a href="#input的易错" class="headerlink" title="input的易错"></a>input的易错</h3><p><strong>注意</strong>：input()返回的数据类型是<code>str</code>，<code>str</code>不能直接和整数比较，必须先把str转换成整数。Python提供了<code>int()</code> 函数来完成这件事情：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = input(<span class="string">'birth: '</span>)</span><br><span class="line">birth = int(s)</span><br><span class="line"><span class="keyword">if</span> birth &lt; <span class="number">2000</span>:</span><br><span class="line">    print(<span class="string">'00前'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'00后'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for……in"><a href="#for……in" class="headerlink" title="for……in"></a>for……in</h3><p>所以<code>for x in ...</code>循环就是把每个元素代入变量<code>x</code>(也可以是其他的名字，请随意)，然后执行缩进块的语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]:</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
<p>如果数太多的话：可以用<code>range()</code>可以生成一个整数序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">101</span>):</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
<p>也可以再通过<code>list()</code>函数可以转换为list。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">5</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h3 id="新增：for-补充笔记"><a href="#新增：for-补充笔记" class="headerlink" title="新增：for 补充笔记"></a>新增：for 补充笔记</h3><p>可以直接作用于<code>for</code>循环的数据类型有以下几种：<br>一类是集合数据类型，如list、tuple、dict、set、str等；<br>一类是generator，包括生成器和带yield的generator function。<br>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。</p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>使用方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">n = <span class="number">99</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - <span class="number">2</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Python3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python3的学习笔记001——入门及基础知识(一)]]></title>
      <url>/2015/08/%E5%BE%85%E6%95%B4%E7%90%86/Python3-%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>主要是关于python的入门、安装、输入、输出、数据类型、变量、字符串、编码问题，还有几个简单函数。<br>1.我的电脑是MAC，以下文字如无特别说明皆是针对OSX的设置及操作，请勿生搬硬套。<br>2.下面的程序一定要自己手打一遍，不要偷懒，不然要后悔的。<br>3.我是按照廖雪峰老师的教程学的，所以有的地方是一样一样的，大家可以当成是一个学习笔记，想学习的可以移步<a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰大大的博客</a>，那里真的好赞。<br>本文摘要。<a id="more"></a></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>2015-8-22 修正格式</p>
<h2 id="python安装"><a href="#python安装" class="headerlink" title="python安装"></a>python安装</h2><p>安装：如系统是OS X 10.8~10.11，自带的Python版本是2.7。要安装最新的Python 3.4，有两个方法：<br>1.从<a href="https://www.python.org/ftp/python/3.4.3/python-3.4.3-macosx10.6.pkg" target="_blank" rel="noopener">Python官网下载Python 3.4的安装程序</a>，双击运行并安装；<br>2.如果安装了Homebrew，直接通过命令<code>brew install python3</code>安装即可。</p>
<h2 id="Python的简单操作"><a href="#Python的简单操作" class="headerlink" title="Python的简单操作"></a>Python的简单操作</h2><p>进行程序：<br>1.打开<code>终端</code>；键入<code>python3</code>;当看到提示符<code>&gt;&gt;&gt;</code> 就表示已经在Python中啦！<br>注意<strong>是键入Python3，不是Python 不然后进入的是系统自带的2.7版本</strong></p>
<p>退出：键入<code>exit()</code></p>
<p>输出：<code>print()</code><br>用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出’hello, world’，：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'hello, world'</span>)</span><br></pre></td></tr></table></figure>
<p>print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'The quick brown fox'</span>, <span class="string">'jumps over'</span>, <span class="string">'the lazy dog'</span>)</span><br></pre></td></tr></table></figure>
<p>print()会依次打印每个字符串，遇到逗号“,”会输出一个空格,大家可以自己在电脑上试一下。<br>print()也可以打印整数，或者计算结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">500</span>)</span><br><span class="line">print(<span class="number">250</span>+<span class="number">250</span>)</span><br></pre></td></tr></table></figure>
<p>上面这两个结果一样一样的。</p>
<p>输入：<br><code>input()</code> 可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = input()</span><br></pre></td></tr></table></figure>
<h2 id="Python基础语法"><a href="#Python基础语法" class="headerlink" title="Python基础语法"></a>Python基础语法</h2><p>Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。<br>Python程序是<strong><em>大小写敏感</em></strong>的，如果写错了大小写，程序会报错。<br>以#开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号<code>:</code>结尾时，缩进的语句视为代码块。</p>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>Python可以处理任意大小的整数，当然包括负整数，<code>1,-250, 38</code>;<br>十六进制用0x前缀和0-9，a-f表示，例如：<code>0xff00，0xa5b4c3d2</code>，等等。<br><strong>注意</strong>：Python的整数没有大小限制，</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数可以用数学写法，如<code>1.23，3.14，-9.01</code>;<br>也可以科学计数法表示，把10用e替代，如<code>1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5</code>，等等。<br><strong>注意</strong> Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。<br>如果字符串内部既包含’又包含”怎么办？可以用转义字符<code>\</code>来标识，比如：</p>
<pre><code>~&apos;I\&apos;m \&quot;OK\&quot;!&apos;~
</code></pre><p>表示的字符串内容是：</p>
<pre><code>~I&apos;m &quot;OK&quot;!~
</code></pre><p>转义字符<code>\</code>可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符\本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code>。<br>如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r’’表示’’内部的字符串默认不转义。<br>如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r’’表示’’内部的字符串默认不转义，：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'''line1</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line2</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line3'''</span>)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>True、False</code>两种值，要么是<code>True</code>，要么是F<code>alse</code>，在Python中，可以直接用True、False表示布尔值（<strong>请注意大小写</strong>），也可以通过布尔运算计算出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">False</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">250</span> &gt; <span class="number">38</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">38</span> &gt; <span class="number">250</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算</p>
<h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><p>空值是Python里一个特殊的值，用<code>None</code>表示。None不能理解为0，因为0是有意义的，而<code>None</code>是一个特殊的空值.</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量名必须是大小写英文、数字和_的组合，且不能用数字开头<br>python是动态语言 ，变量本身类型不固定的，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</p>
<p>在Python中，等号<code>=</code>是赋值语句，(大多灵敏语言都是用这个，一法通万法通)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span> <span class="comment"># a是整数</span></span><br><span class="line">print(a)</span><br><span class="line">a = <span class="string">'ABC'</span> <span class="comment"># a变为字符串</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>通常用<strong>全部大写</strong>的变量名表示常量:<br>在Python中，有两种<strong>除法</strong>：<br>一种除法是<code>/</code> 计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数.<br>还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数.<strong>注意永远是整数，即使除不尽</strong>。<br>因为//除法只取结果的整数部分，所以Python还提供一个余数运算<code>%</code>，可以得到两个整数相除的余数：例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> / <span class="number">3</span></span><br><span class="line"><span class="number">3.3333333333333335</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> // <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> % <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>技巧</strong>：无论整数做//除法还是取余数，结果永远是整数，所以，<strong>整数运算结果永远是精确的。</strong></p>
<h3 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h3><p>在最新的Python 3版本中，字符串是以<strong>Unicode</strong>编码的。</p>
<h4 id="ord-and-chr"><a href="#ord-and-chr" class="headerlink" title="ord() and chr()"></a>ord() and chr()</h4><p>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'A'</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'中'</span>)</span><br><span class="line"><span class="number">20013</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">66</span>)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">25991</span>)</span><br><span class="line"><span class="string">'文'</span></span><br></pre></td></tr></table></figure>
<p>如果知道字符的整数编码，还可以用十六进制这么写str：<br>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。<br>Python对bytes类型的数据用带b前缀的单引号或双引号表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">b'ABC'</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 区分<code>&#39;ABC&#39;</code>和<code>b&#39;ABC&#39;</code>，前者是<code>str</code>，后者虽然内容显示得和前者一样，但<code>bytes</code>的每个字符都只占用一个字节。</p>
<h4 id="encode-and-decode"><a href="#encode-and-decode" class="headerlink" title=".encode() and .decode()"></a>.encode() and .decode()</h4><p>以Unicode表示的str通过<code>encode()</code>方法可以编码为指定的bytes，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">b'ABC'</span></span><br></pre></td></tr></table></figure>
<p>从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用<code>decode()</code>方法,格式同上。</p>
<h4 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h4><p>要计算str包含多少个字符，可以用<code>len()</code>函数。当然了，也可以用计算bytes的；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">b'ABC'</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>做个实验：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。<br>在操作字符串时，我们经常遇到str和bytes的互相转换。<strong>为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。</strong></p>
<p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就<strong>需要务必指定保存为UTF-8编码</strong>。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>
<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；<br>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p>
<h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><p>| —-—– | —— |<br>| %d | 整数 |<br>| %f | 浮点数 |<br>| %s | 字符数 |<br>| %x | 16进制数 |</p>
<p>格式化方式和C语言是一致的，用<code>%</code>实现 使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello, %s'</span> % <span class="string">'world'</span></span><br><span class="line"><span class="string">'Hello, world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hi, %s, you have $%d.'</span> % (<span class="string">'Michael'</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="string">'Hi, Michael, you have $1000000.</span></span><br></pre></td></tr></table></figure>
<p>技巧：<br>1.格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%2d-%02d'</span> % (<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="string">' 3-01'</span></span><br></pre></td></tr></table></figure>
<p>2.字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code>。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 教程 </tag>
            
            <tag> python3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Apple新闻——苹果公司CEO Tim Cook 开通了新浪微博]]></title>
      <url>/2015/05/%E9%9A%8F%E7%AC%94/%E7%94%9F%E6%B4%BB-Apple%E6%96%B0%E9%97%BB%E4%B9%8B%E8%8B%B9%E6%9E%9C%E5%85%AC%E5%8F%B8CEOTimCook%E5%BC%80%E9%80%9A%E4%BA%86%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A/</url>
      <content type="html"><![CDATA[<p><img src="http://7xiuu0.com1.z0.glb.clouddn.com/生活_Apple新闻之苹果公司CEOTimCook开通了新浪微博.jpg" alt=""><br>苹果公司 CEO Tim Cook 开通了新浪微博 - <a href="http://weibo.com/u/5524254784" target="_blank" rel="noopener">http://weibo.com/u/5524254784</a><br>别忘了：<br><a href="https://twitter.com/tim_cook" target="_blank" rel="noopener">Tim Cook 的 Twitter </a></p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> apple </tag>
            
            <tag> cook </tag>
            
            <tag> 新闻 </tag>
            
            <tag> 微博 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的考研经验及给后人的建议(04)——单词番外篇]]></title>
      <url>/2015/05/%E9%9A%8F%E7%AC%94/%E7%94%9F%E6%B4%BB-%E6%88%91%E7%9A%84%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C%E5%8F%8A%E7%BB%99%E5%90%8E%E4%BA%BA%E7%9A%84%E5%BB%BA%E8%AE%AE(04)%E2%80%94%E2%80%94%E5%8D%95%E8%AF%8D%E7%95%AA%E5%A4%96%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>照着单词书背单词是个很枯燥的事儿，还给人一种怎么背也不背不下来的感觉。昨天就有个学弟给我发邮件说：<code>……背了两遍了，还是好多记不住。很是焦急，求学长指点……</code><br>对这种问题，我除了多鼓励，让他不要放弃。还有一点要大家注意的就是不能只背单词书。对于我们<strong>做过的真题上的不认识的单词</strong>要专门找个本子记下来，这些单词的是<strong>必背</strong>的。<br>不过<a id="more"></a> 对于还是想偷懒的同学……下面图片中的这几篇真题文章涵盖了大部分的必考词，你是一定要背的的很熟，不然谁也帮忙不了你的：<br><img src="http://7xiuu0.com1.z0.glb.clouddn.com/生活_考研必备的单词.jpg.png" alt="考研必备的单词 年份+第几篇"></p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 经验 </tag>
            
            <tag> 英语 </tag>
            
            <tag> 考试 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Google Guide To Techical Development]]></title>
      <url>/2015/05/%E5%BE%85%E6%95%B4%E7%90%86/%E7%94%9F%E6%B4%BB-GoogleGuideToTechicalDevelopment/</url>
      <content type="html"><![CDATA[<p>Having a solid foundation in Computer Science is important to become a successful Software Engineer. This guide is a suggested path for University students to develop their technical skills academically and non-academically through self paced hands-on learning. You may use this guide to determine courses to take, but please make sure you are taking courses required for your major in order to graduate. The online resources provided in this guide are not meant to replace courses available at your University. However, they may help supplement your learnings or provide an introduction to a topic.<br><a id="more"></a><br>Using this guide:</p>
<ul>
<li>Please use this guide at your discretion</li>
<li>There may be other things you want to learn or do outside of this guide - go for it!</li>
<li>Checking off all items in this guide does not guarantee a job at Google<br>T- his guide will evolve or change - check back for updates</li>
</ul>
<p>Follow our Google for Students +Page to get additional tips, resources, and other students interested in development.</p>
<h3 id="Recommendations-for-Academic-Learnings"><a href="#Recommendations-for-Academic-Learnings" class="headerlink" title="Recommendations for Academic Learnings"></a>Recommendations for Academic Learnings</h3><h4 id="Introduction-to-CS-Course"><a href="#Introduction-to-CS-Course" class="headerlink" title="Introduction to CS Course"></a>Introduction to CS Course</h4><p>Take Introduction to Computer Science courses that provide basic instructions on coding.</p>
<p>Online resources: <a href="https://www.google.com/url?q=https%3A%2F%2Fwww.udacity.com%2Fcourse%2Fcs101&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGdmrWTUY5b_qe3xle9-ddkB1YXqA" target="_blank" rel="noopener">Udacity - intro to CS course</a>, <a href="https://www.coursera.org/course/cs101" target="_blank" rel="noopener">Coursera - Computer Science 101</a></p>
<h4 id="Code-in-at-least-one-object-oriented-programming-language-C-Java-or-Python"><a href="#Code-in-at-least-one-object-oriented-programming-language-C-Java-or-Python" class="headerlink" title="Code in at least one object oriented programming language: C++, Java, or Python"></a><strong>Code in</strong> at least one object oriented programming language: C++, Java, or Python</h4><p>Beginner Online Resources:<br><a href="https://www.coursera.org/course/programming1" target="_blank" rel="noopener">Coursera - Learn to Program: The Fundamentals, </a><br><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-092-introduction-to-programming-in-java-january-iap-2010/index.htm" target="_blank" rel="noopener">MIT Intro to Programming in Java, </a><br><a href="https://developers.google.com/edu/python/" target="_blank" rel="noopener">Google’s Python Class, </a><br><a href="https://www.coursera.org/course/interactivepython1" target="_blank" rel="noopener">Coursera - Introduction to Python, </a><br><a href="https://www.coursera.org/course/interactivepython1" target="_blank" rel="noopener">Python Open Source E-Book</a></p>
<p>Intermediate Online Resources:<br><a href="https://www.udacity.com/course/cs212" target="_blank" rel="noopener">Udacity’s Design of Computer Programs, </a><br><a href="https://www.coursera.org/course/programming2" target="_blank" rel="noopener">Coursera - Learn to Program: Crafting Quality Code,</a><br><a href="https://www.coursera.org/course/proglang" target="_blank" rel="noopener">oursera - Programming Languages, </a><br><a href="https://cs.brown.edu/courses/cs173/2012/OnLine/" target="_blank" rel="noopener">Brown University - Introduction to Programming Languages</a></p>
<h4 id="Learn-other-Programming-Languages"><a href="#Learn-other-Programming-Languages" class="headerlink" title="Learn other Programming Languages"></a>Learn other Programming Languages</h4><p>Notes: Add to your repertoire - Java Script, CSS, HTML, Ruby, PHP, C, Perl, Shell, Lisp and Scheme.</p>
<p>Online Resources:<br>w3school.com - HTML Tutorial,<br>CodeAcademy.com,<br>Udacity - Mobile Web Development,<br>Udacity - HTML5 Game Development</p>
<h4 id="Test-Your-Code"><a href="#Test-Your-Code" class="headerlink" title="Test Your Code"></a>Test Your Code</h4><p>Notes: Learn how to catch bugs, create tests, and break your software</p>
<p>Online Resources:<br>Udacity - Software Testing Methods,<br>Udacity - Software Debugging</p>
<h4 id="Develop-logical-reasoning-and-knowledge-of-discrete-math"><a href="#Develop-logical-reasoning-and-knowledge-of-discrete-math" class="headerlink" title="Develop logical reasoning and knowledge of discrete math"></a>Develop logical reasoning and knowledge of discrete math</h4><p>Online Resources:<br>MIT Mathematics for Computer Science,<br>Coursera - Introduction to Logic,<br>Coursera - Linear and Discrete Optimization,<br>Coursera - Probabilistic Graphical Models,<br>Coursera - Game Theory</p>
<h4 id="Develop-strong-understanding-of-Algorithms-and-Data-Structures"><a href="#Develop-strong-understanding-of-Algorithms-and-Data-Structures" class="headerlink" title="Develop strong understanding of Algorithms and Data Structures"></a>Develop <strong>strong</strong> understanding of Algorithms and Data Structures</h4><p>Notes: Learn about fundamental data types (stack, queues, and bags), sorting algorithms (quicksort, mergesort, heapsort), data structures (binary search trees, red-black trees, hash tables), and Big O.</p>
<p>Online Resources:<br>MIT Introduction to Algorithms,<br>Coursera Introduction to Algorithms Part 1 &amp; Part 2,<br>List of Algorithms,<br>List of Data Structures,<br>Book:<br>The Algorithm Design Manual</p>
<h4 id="Develop-a-strong-knowledge-of-operating-systems"><a href="#Develop-a-strong-knowledge-of-operating-systems" class="headerlink" title="Develop a strong knowledge of operating systems"></a>Develop a <strong>strong</strong> knowledge of operating systems</h4><p>Online Resources: UC Berkeley Computer Science 162</p>
<h4 id="Learn"><a href="#Learn" class="headerlink" title="Learn"></a>Learn</h4><p>Online Resources: Udacity - UX Design for Mobile Developers</p>
<h4 id="Learn-Artificial-Intelligence-Online-Resources"><a href="#Learn-Artificial-Intelligence-Online-Resources" class="headerlink" title="Learn Artificial Intelligence Online Resources:"></a>Learn Artificial Intelligence Online Resources:</h4><p>Stanford University - Introduction to Robotics, Natural Language Processing, Machine Learning</p>
<h4 id="Learn-how-to-build-compilers"><a href="#Learn-how-to-build-compilers" class="headerlink" title="Learn how to build compilers"></a>Learn how to build compilers</h4><p>Online Resources: </p>
<ul>
<li>Coursera - Compilers</li>
</ul>
<h4 id="Learn-cryptography"><a href="#Learn-cryptography" class="headerlink" title="Learn cryptography"></a>Learn cryptography</h4><p>Online Resources: </p>
<ul>
<li>Coursera - Cryptography, </li>
<li>Udacity - Applied Cryptography</li>
</ul>
<h4 id="Learn-Parallel-Programming"><a href="#Learn-Parallel-Programming" class="headerlink" title="Learn Parallel Programming"></a>Learn Parallel Programming</h4><p>Online Resources: </p>
<ul>
<li>Coursera - Heterogeneous Parallel Programming</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="Work-on-project-outside-of-the-classroom"><a href="#Work-on-project-outside-of-the-classroom" class="headerlink" title="Work on project outside of the classroom."></a>Work on project outside of the classroom.</h4><p>Notes: Create and maintain a website, build your own server, or build a robot.</p>
<p>Online Resources: Apache List of Projects, Google Summer of Code, Google Developer Group</p>
<h4 id="Work-on-a-small-piece-of-a-large-system-codebase-read-and-understand-existing-code-track-down-documentation-and-debug-things"><a href="#Work-on-a-small-piece-of-a-large-system-codebase-read-and-understand-existing-code-track-down-documentation-and-debug-things" class="headerlink" title="Work on a small piece of a large system (codebase), read and understand existing code, track down documentation, and debug things."></a>Work on a small piece of a large system (codebase), read and understand existing code, track down documentation, and debug things.</h4><p>Notes: Github is a great way to read other people’s code or contribute to a project.</p>
<p>Online Resources: Github, Kiln</p>
<h4 id="Work-on-project-with-other-programmers"><a href="#Work-on-project-with-other-programmers" class="headerlink" title="Work on project with other programmers."></a>Work on project with other programmers.</h4><p>Notes: This will help you improve your ability to work well in a team and enable you to learn from others.</p>
<h4 id="Practice-your-algorithmic-knowledge-and-coding-skills"><a href="#Practice-your-algorithmic-knowledge-and-coding-skills" class="headerlink" title="Practice your algorithmic knowledge and coding skills"></a>Practice your algorithmic knowledge and coding skills</h4><p>Notes: Practice your algorithmic knowledge through coding competitions like CodeJam or ACM’s International Collegiate Programming Contest.</p>
<p>Online Resources: CodeJam, ACM ICPC</p>
<h4 id="Become-a-Teaching-Assistant"><a href="#Become-a-Teaching-Assistant" class="headerlink" title="Become a Teaching Assistant"></a>Become a Teaching Assistant</h4><p>Helping to teach other students will help enhance your knowledge in the subject matter.</p>
<h4 id="Internship-experience-in-software-engineering"><a href="#Internship-experience-in-software-engineering" class="headerlink" title="Internship experience in software engineering"></a>Internship experience in software engineering</h4><p>Notes: Make sure you apply for internships well in advance of the period internships take place. In the US, internships take place during the summer, May-September. Applications are usually accepted several months in advance.</p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 职业规划 </tag>
            
            <tag> google </tag>
            
            <tag> 指导 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git及GitHub——入门、初始化、及配置]]></title>
      <url>/2015/05/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-Git:GitHub-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git%EF%BC%8801%EF%BC%89%E2%80%94%E5%85%A5%E9%97%A8%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h3><p>这是一篇很详尽git使用教程，本文以github为示例，把关于git的知识整理一下,希望能给后来者一个明确的指引。<a id="more"></a></p>
<h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><p>NULL</p>
<h3 id="配置自己的代码托管网站"><a href="#配置自己的代码托管网站" class="headerlink" title="配置自己的代码托管网站"></a>配置自己的代码托管网站</h3><p>1.首先找一个代码托管网址，首选<a href="https://github.com/" target="_blank" rel="noopener">github</a>，国内<a href="123">gitcafe</a>，注册一个用户名yourname。<br>2.在<a href="https://github.com/" target="_blank" rel="noopener">github</a>上新建一个空的项目，写好名称，比如<code>Test</code>。</p>
<h3 id="在本地安装好git"><a href="#在本地安装好git" class="headerlink" title="在本地安装好git"></a>在本地安装好git</h3><p>点<a href="http://pan.baidu.com/s/1sj8y7gD" target="_blank" rel="noopener">这里</a>下载并安装 ，一键就OK。</p>
<h3 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h3><h4 id="检查SSH-keys的设置"><a href="#检查SSH-keys的设置" class="headerlink" title="检查SSH keys的设置"></a>检查SSH keys的设置</h4><pre><code>cd ~/. ssh //检查本机的ssh密钥
</code></pre><p>如果提示：No such file or directory 说明你是第一次使用git。<br>如果不是第一次使用，跳到第三步，否则请执行下面的操作,清理原有ssh密钥。</p>
<h4 id="备份和移除原来的ssh-key设置："><a href="#备份和移除原来的ssh-key设置：" class="headerlink" title="备份和移除原来的ssh key设置："></a>备份和移除原来的ssh key设置：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir key_backup</span><br><span class="line">cp id_rsa* key_backup</span><br><span class="line">rm id_rsa*</span><br></pre></td></tr></table></figure>
<h4 id="生成新的密钥："><a href="#生成新的密钥：" class="headerlink" title="生成新的密钥："></a>生成新的密钥：</h4><p>输入下面的代码，就可以生成新的key文件，我们只需要默认设置就好，所以当需要输入文件名的时候，回车就好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	ssh-keygen –t rsa –C “yourmaill@yourmail.com”</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):   ///回车就好</span><br></pre></td></tr></table></figure>
<p>注意: 此处的邮箱地址，你可以输入自己的邮箱地址。在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。<br>然后系统会要你输入加密串（Passphrase）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;</span><br><span class="line">Enter same passphrase again:&lt;再次输入加密串&gt;</span><br></pre></td></tr></table></figure>
<h4 id="添加SSH-Key到GitHub："><a href="#添加SSH-Key到GitHub：" class="headerlink" title="添加SSH Key到GitHub："></a>添加SSH Key到GitHub：</h4><p>在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。</p>
<p>用文本编辑工具打开id_rsa.pub文件，如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。</p>
<p>在GitHub的主页上点击设置按钮：</p>
<p>选择SSH Keys项，把复制的内容粘贴进去，然后点击Add Key按钮即可：</p>
<h4 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h4><p>可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：</p>
<pre><code>`ssh -T git@github.com`
</code></pre><p>如果是下面的反应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>
<p>不要紧张，输入<code>yes</code>就好，然后会看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi &lt;em&gt;username&lt;/em&gt;! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>现在你已经可以通过SSH链接到GitHub了!!!</p>
<h3 id="本地git配置及操作"><a href="#本地git配置及操作" class="headerlink" title="本地git配置及操作"></a>本地git配置及操作</h3><p>1.第一次在本地设置git时须：<br><code>git config --global user.name &quot;yourname&quot;//gitcafe上的用户名</code><br><code>git config --global user.email &quot;yourmaill@yourmaili.com&quot;//填写自己的邮箱</code><br>2.选一个本地的项目存放位置，比如/github文件夹<br>3.在github下新建你的项目Test文件夹，进入Test文件夹，新建一个<code>readme.md</code>文件，然后使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git init //初始化——创建一个新Git仓库</span><br><span class="line">git status   //查看当前项目下所有文的状态，如果第一次，你会发现都红颜色的，因为它还没有交给git/gitcafe管理。</span><br><span class="line">git add .   //（.）点表示当前目录下的所有内容，交给git管理，也就是提交到了git的本地仓库。Ps:git的强大之处就是有一个本地仓库的概念，在没有网络的情况下可以先将更新的内容提交到本地仓库。</span><br><span class="line">git commit –m &quot;first commit &quot;  //对你更新或修改了哪些内容做一个描述。</span><br><span class="line">git remote add origin git@github.com：yourname/Test.git</span><br><span class="line">//如果你是第一次提交项目，这一句非常重要，这是你本地的当前的项目与远程的哪个仓库建立连接。Ps: origin可以改为别人的名字，但是在你下一次push（提交）时，也要用你修改之后的名字。</span><br><span class="line">git remote -v  //查看你当前项目远程连接的是哪个仓库地址。</span><br><span class="line">git push -u origin master  //将本地的项目提交到远程仓库中。</span><br></pre></td></tr></table></figure>
<p>以上步骤完成后，你新建的Text项目就推送到gitcafe上了！</p>
<h3 id="一些初级的常用操作："><a href="#一些初级的常用操作：" class="headerlink" title="一些初级的常用操作："></a>一些初级的常用操作：</h3><p>1.当你在别的主机上想要下载这个项目时，首先还是先设置好ssh公钥并在网站上添加，然后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git clone git@github.com:yourname/Test  //项目编会克隆到你的当前主机上</span><br></pre></td></tr></table></figure>
<p>2.如果想删除项目中的一个文件，比如Clang文件夹下的<code>readme.md</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd Text/</span><br><span class="line">git rm a.c</span><br><span class="line">git commit -m &quot;delete a.c&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>3.如果你想使本地的Clang项目与网站上最新的项目同步：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd Clang/</span><br><span class="line">git fetch origin    //取得远程更新，这里可以看做是准备要取了</span><br><span class="line">git merge origin/master  //把更新的内容合并到本地分支/master</span><br></pre></td></tr></table></figure>
<p>以上就是git代码托管的初学者教程，欢迎补充指正。</p>
<h3 id="本站相关文章"><a href="#本站相关文章" class="headerlink" title="本站相关文章"></a>本站相关文章</h3><p>NULL</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://blog.chinaunix.net/uid-24060800-id-3480026.html" target="_blank" rel="noopener">如何使用git，初学者教程 </a></p>
<p><a href="http://blog.csdn.net/jinzhuojun/article/details/7747876" target="_blank" rel="noopener">Git常见使用</a></p>
<p><a href="http://beiyuu.com/github-pages/" target="_blank" rel="noopener">使用Github Pages建独立博客</a></p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> 入门 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客的优化与定制（01）]]></title>
      <url>/2015/05/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-hexo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%BC%98%E5%8C%96%E4%B8%8E%E5%AE%9A%E5%88%B6%EF%BC%8801%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h3><p>本文修改都是基于<a href="http://chnwentao.com">我的博客</a>的默认主题icarus, 其他主题可对照修改, 方法类似, 对应效果请参考 <a href="http://chnwentao.com">我的博客</a>, 本站主题为icarus。<br><a id="more"></a></p>
<h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><p>2016-6-10 插入gist 方法</p>
<h3 id="给-Hexo-添加文章目录"><a href="#给-Hexo-添加文章目录" class="headerlink" title="给 Hexo 添加文章目录"></a>给 Hexo 添加文章目录</h3><p><a href="http://lukang.me/2014/optimization-of-hexo.html" target="_blank" rel="noopener">参考文章</a> 不过这个文章的方法有问题，不可用。我已改良:<br>将这段代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span>(<span class="attr">post.toc</span> !== <span class="string">false)&#123;</span> %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"toc"</span> <span class="attr">class</span>=<span class="string">"toc-article"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span> <span class="attr">class</span>=<span class="string">"toc-title"</span>&gt;</span>文章目录<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">toc</span>(<span class="attr">post.content</span>) %&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加到 <code>你的主题\layout\_partial\article.ejs</code>中如下位置添加<br>示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">theme.excerpt_link</span>)&#123; %&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"article-more-link"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(post.path) %&gt;#more"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">theme.excerpt_link</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> &#125; <span class="attr">else</span> &#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span>(<span class="attr">post.toc</span> !== <span class="string">false)&#123;</span> %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"toc"</span> <span class="attr">class</span>=<span class="string">"toc-article"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span> <span class="attr">class</span>=<span class="string">"toc-title"</span>&gt;</span>文章目录<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">toc</span>(<span class="attr">post.content</span>) %&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">post.content</span> %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样, 在文章不需要使用文章目录的时候可以在 文章的—前加上 toc: false 即可（<a href="http://lukang.me/2014/optimization-of-hexo.html" target="_blank" rel="noopener">参考文章</a>中这个方法失败）。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">title: &quot;hexo博客的优化与定制（01）&quot;</span><br><span class="line">date: 2015-05-02 13:33:29</span><br><span class="line">tags:</span><br><span class="line">- 博客</span><br><span class="line">- 配置</span><br><span class="line">- 优化</span><br><span class="line">- 教程</span><br><span class="line">categories:</span><br><span class="line">- hexo</span><br><span class="line">toc: true</span><br><span class="line">---</span><br><span class="line">###摘要（Abstract）</span><br></pre></td></tr></table></figure>
<p>最后，还要在<code>你的主题/source/css/_partial/article.styl</code>中添加CSS 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> /*toc*/</span><br><span class="line">.toc-article</span><br><span class="line">  background #ffffff</span><br><span class="line">  margin 2em 0 0 0.2em</span><br><span class="line">  padding 1em</span><br><span class="line">  border-radius 5px</span><br><span class="line">  .toc-title</span><br><span class="line">    font-size 120%</span><br><span class="line">  strong</span><br><span class="line">    padding 0.3em 1</span><br><span class="line">ol.toc</span><br><span class="line">  width 100%</span><br><span class="line">  margin 1em 2em 0 0</span><br><span class="line">#toc</span><br><span class="line">  line-height 1em</span><br><span class="line">  font-size 0.8em</span><br><span class="line">  float right</span><br><span class="line">  .toc</span><br><span class="line">    padding 0</span><br><span class="line">    li</span><br><span class="line">      list-style-type none</span><br><span class="line">  .toc-child</span><br><span class="line">    padding-left 0em</span><br><span class="line">#toc.toc-aside</span><br><span class="line">  display none</span><br><span class="line">  width 13%</span><br><span class="line">  position fixed</span><br><span class="line">  right 2%</span><br><span class="line">  top 320px</span><br><span class="line">  overflow hidden</span><br><span class="line">  line-height 1.5em</span><br><span class="line">  font-size 1em</span><br><span class="line">  color color-heading</span><br><span class="line">  opacity .6</span><br><span class="line">  transition opacity 1s ease-out</span><br><span class="line">  strong</span><br><span class="line">    padding 0.3em 0</span><br><span class="line">    color color-font</span><br><span class="line">  &amp;:hover</span><br><span class="line">    transition opacity .3s ease-out</span><br><span class="line">    opacity 1</span><br><span class="line">  a</span><br><span class="line">    transition color 1s ease-out</span><br><span class="line">    &amp;:hover</span><br><span class="line">      color color-theme</span><br><span class="line">      transition color .3s ease-out</span><br></pre></td></tr></table></figure>
<h3 id="添加百度统计"><a href="#添加百度统计" class="headerlink" title="添加百度统计"></a>添加百度统计</h3><p>由于源码中google analytics因众所周知的原因失效，所以用百度统计代替。<br>以我自己用的主题icarus的为例(本博客采用icarus主题)</p>
<p>1.新建 <code>themes/icarus/layout/_partial/baidu_analytics.ejs</code>添加如下代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">var _hmt = _hmt || [];</span></span><br><span class="line"><span class="undefined">(function() &#123;</span></span><br><span class="line"><span class="undefined">  var hm = document.createElement("script");</span></span><br><span class="line"><span class="undefined">  hm.src = "//hm.baidu.com/hm.js?c4c99183a6a02c53d4760ae1995c3b38"; //百度统计 ID，此 ID 是百度统计提供脚本中 hm.js? 后面那串字符，非百度统计帐号</span></span><br><span class="line"><span class="undefined">  var s = document.getElementsByTagName("script")[0];</span></span><br><span class="line"><span class="undefined">  s.parentNode.insertBefore(hm, s);</span></span><br><span class="line"><span class="undefined">&#125;)();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.编辑<code>themes/icarus/layout/_partial/head.ejs</code>在 <code>&lt;/head&gt;</code>前添加</p>
<pre><code>&lt;%- partial(&apos;baidu-analytics&apos;) %&gt;
</code></pre><h3 id="向搜索引擎提交网址"><a href="#向搜索引擎提交网址" class="headerlink" title="向搜索引擎提交网址"></a>向搜索引擎提交网址</h3><p>不提交搜索引擎找不到你的，不过<strong>天朝的百度</strong>你提交了不交钱还是找不到你的！！所以我就不想写了……<br><a href="http://www.sousuoyinqingtijiao.com/baidu/" target="_blank" rel="noopener">这是提交的入口</a></p>
<h3 id="添加网页访问计数器"><a href="#添加网页访问计数器" class="headerlink" title="添加网页访问计数器"></a>添加网页访问计数器</h3><p>推荐使用<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子</a></p>
<p>1.安装jQuery</p>
<p>首先，不蒜子是依赖jQuery的。目前几乎所有网站页面中都引入了jQuery.js。如果你的站点已经引入jQuery，那么跳过这部分内容；如果你的站点确实没引入，那么你需要在 head 中将其引入，以下是几个比较靠谱的cdn。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;//dn-lbstatics.qbox.me/jquery/1.11.2/jquery.min.js&quot;&gt;&lt;/script&gt; //不如</span><br><span class="line">&lt;script src=&quot;//http://lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js&quot;&gt;&lt;/script&gt; //新浪</span><br><span class="line">&lt;script src=&quot;//cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; //七牛</span><br><span class="line">&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt; //微软</span><br><span class="line">&lt;script src=&quot;//code.jquery.com/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt; //jQuery</span><br><span class="line">&lt;script src=&quot;//libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; //百度</span><br><span class="line">&lt;script src=&quot;//libs.useso.com/js/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt; //360</span><br></pre></td></tr></table></figure>
<p>2.安装脚本</p>
<p>打开<code>themes/你的主题/layout/_partial/footer.ejs</code>添加即可。文档的<code>&lt;/footer&gt;</code>前引入。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//dn-lbstatics.qbox.me/lbservice/busuanzi/2.0/busuanzi.mini.js"</span>/&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.安装标签（可选）</p>
<p>只需要复制到<code>themes/你的主题/layout/_partial/footer.ejs</code>即可，这分几种情况。</p>
<ul>
<li>显示站点总访问量</li>
</ul>
<p>要显示站点总访问量，复制以下代码添加到你需要显示的位置。有两种算法可选：</p>
<p>算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">    本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。</span><br><span class="line"></span><br><span class="line">&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line">  本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>显示单页面访问量</li>
</ul>
<p>要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;</span><br><span class="line">  本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>代码中文字是可以修改的，只要保留id正确即可。</p>
<ul>
<li>显示站点总访问量和单页面访问量</li>
</ul>
<p>你懂的吧，上面两种标签代码都安装。</p>
<ul>
<li>只计数不显示</li>
</ul>
<p>只安装脚本代码，不安装标签代码。</p>
<h3 id="嵌入gist"><a href="#嵌入gist" class="headerlink" title="嵌入gist"></a>嵌入gist</h3><p>引入 gist 时，插入 fileName 似乎会失败，所以，引入 gist 时只需要使用 <code>gist hash-id</code> 即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gist 5b3ee7efd535ab63cd56 %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>NULL</p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Recommended C Style and Coding Standards(C语言编程规范)-中文版]]></title>
      <url>/2015/05/%E5%BE%85%E6%95%B4%E7%90%86/%E5%85%B6%E4%BB%96-C-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<p>声明：<br>本文《C语言编程规范-中文版》来源于<a href="https://code.google.com/p/recommended-c-style-and-coding-standards-cn/" target="_blank" rel="noopener">google cod：recommended-c-style-and-coding-standards-cn</a>，英文原版<a href="http://www.doc.ic.ac.uk/lab/cplus/cstyle.html" target="_blank" rel="noopener">Recommended C Style and Coding Standards</a>。本版本由本人整理（仍在修订中），如有疑问或建议欢迎留言。<br>为了方便大家学习、修改，我已将其相关的所有资料发布到<a href="123">GitHub</a>。<br>欢迎大家FORK!<br><a id="more"></a><br>更新记录：<br>NLLL</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>本文档修改于AT&amp;T Indian Hill实验室内部成立的一个委员会的一份文档，旨在于建立一套通用的编码标准并推荐给Indian Hill社区。</p>
<p>本文主要讲述编码风格。良好的风格能够鼓励大家形成一致的代码布局，提高代码可移植性并且减少错误数量。<br><!--- more --><br>本文不关注功能组织，或是一些诸如如何使用goto的一般话题。我们尝试将之前的有关C代码风格的文档整合到一套统一的标准中，这套标准将适合于任何使用C语言的工程，当然还是会有部分内容是针对一些特定系统的。另外不可避免地是这些标准仍然无法覆盖到所有情况。经验以及广泛的评价十分重要，遇到特殊情况时，大家应该咨询有经验的C程序员，或者查看那些经验丰富的C程序员们的代码(最好遵循这些规则)。</p>
<p>本文中的标准本身并不是必需的，但个别机构或团体可能部分或全部采用该标准作为程序验收的一部分。因此，在你的机构中其他人很可能以一种相似的风格编码。最终，这些标准的目的是提高可移植性，减少维护工作，尤其是提高代码的清晰度。</p>
<p>这里很多风格的选择都有些许武断。混合的编码风格比糟糕的编码风格更难于维护，所以当变更现有代码时，最好是保持与现有代码风格一致，而不是盲目地遵循本文档中的规则。</p>
<blockquote>
<p>“清晰的是专业的；不清晰的则是外行的” – Sir Ernest Gower</p>
</blockquote>
<h2 id="2-文件组织"><a href="#2-文件组织" class="headerlink" title="2. 文件组织"></a>2. 文件组织</h2><p>一个文件包含的各个部分应该用若干个空行分隔。虽然对源文件没有最大长度限制，但超过1000行的文件处理起来非常不方便。编辑器很可能没有足够的临时空间来编辑这个文件，编译过程也会因此变得十分缓慢。与回滚到前面所花费的时间相比，那些仅仅呈现了极少量信息的多行星号是不值得的，我们不鼓励使用。超过79列的行无法被所有的终端都很好地处理，应该尽可能的避免使用。过长的行会导致过深的缩进，这常常是一种代码组织不善的症状。</p>
<h3 id="2-1-文件命名惯例"><a href="#2-1-文件命名惯例" class="headerlink" title="2.1 文件命名惯例"></a>2.1 文件命名惯例</h3><p>文件名由一个基础名、一个可选的句号以及后缀组成。名字的第一个字符应该是一个字母，并且所有字符(除了句号)都应该是小写的字母和数字。基础名应该由八个或更少的字符组成，后缀应该由三个或更少的字符组成(四个，如果你包含句号的话)。这些规则对程序文件以及程序使用和产生的默认文件都适用(例如，”rogue.sav”)。</p>
<p>一些编译器和工具要求文件名符合特定的后缀命名约定。下面是后缀命名要求：</p>
<ul>
<li>C源文件的名字必须以.c结尾</li>
<li>汇编源文件的名字必须以.s结尾</li>
</ul>
<p>我们普遍遵循以下命名约定：</p>
<ul>
<li>可重定位目标文件名以.o结尾</li>
<li>头文件名以.h结尾</li>
<li>-在多语言环境中一个可供选择的更好的约定是用语言类型和.h共同作为后缀(例如，”foo.c.h” 或 “foo.ch”)。</li>
<li>Yacc源文件名以.y结尾</li>
<li>Lex源文件名以.l结尾</li>
</ul>
<p>C++使用编译器相关的后缀约定，包括.c，..c，.cc，.c.c以及.C。由于大多C代码也是C++代码，因此这里并没有一个明确的方案。</p>
<p>此外，我们一般约定使用”Makefile”(而不是”makefile”)作为make(对于那些支持make的系统)工具的控制文件，并且使用”README”作为简要描述目录内容或目录树的文件。</p>
<h3 id="2-2-程序文件"><a href="#2-2-程序文件" class="headerlink" title="2.2 程序文件"></a>2.2 程序文件</h3><p>下面是一个程序文件各个组成部分的推荐排列顺序：</p>
<p>1.文件的第一部分是一个序，用于说明该文件中的内容是什么。对文件中的对象(无论它们是函数，外部数据声明或定义，或是其他一些东西)用途的描述比一个对象名字列表更加有用。这个序可选择地包含作者信息、修订控制信息以及参考资料等。<br>2.接下来是所有被包含的头文件。如果某个头文件被包含的理由不是那么显而易见，我们需要通过增加注释说明原因。大多数情况下，类似stdio.h这样的系统头文件应该被放在用户自定义头文件的前面。</p>
<p>3.接下来是那些用于该文件的defines和typedefs。一个常规的顺序是先写常量宏、再写函数宏，最后是typedefs和枚举(enums)定义。</p>
<p>4.接下来是全局(外部)数据声明，通常的顺序如下：外部变量，非静态(non-static)全局变量，静态全局变量。如果一组定义被用于部分特定全局数据（如一个标志字），那么这些定义应该被放在对应数据声明后或嵌入到结构体声明中，并将这些定义缩进到其应用的声明的第一个关键字的下一个层次(译注：实在没有搞懂后面这句的含义)。</p>
<p>5.最后是函数，函数应该以一种有意义的顺序排列。相似的函数应该放在一起。与深度优先(函数定义尽可能在他们的调用者前后)相比，我们应该首选广度优先方法(抽象层次相似的函数放在一起)。这里需要相当多的判断。如果定义大量本质上无关的工具函数，可考虑按字母表顺序排列。</p>
<h3 id="2-3-头文件"><a href="#2-3-头文件" class="headerlink" title="2.3 头文件"></a>2.3 头文件</h3><p>头文件是那些在编译之前由C预处理器包含在其他文件中的文件。诸如stdio.h的一些头文件被定义在系统级别，所有使用标准I/O库的程序必须包含它们。头文件还用来包含数据声明和定义，这些数据不止一个程序需要。头文件应该按照功能组织，例如，独立子系统的声明应该放到独立的头文件中。如果一组声明在代码从一种机器移植到另外一种机器时变动的可能性很大，那么这些声明也应该被放在独立的头文件中。</p>
<p>避免私有头文件的名字与标准库头文件的名字一样。下面语句：</p>
<pre><code>#include &quot;math.h&quot;
</code></pre><p>当预期的头文件在当前目录下没有找到时，它将会包含标准库中的math头文件。如果这的确是你所期望发生的，那么请加上注释。包含头文件时不要使用绝对路径。当从标准位置获取头文件时，请使用<name>包含头文件；或相对于当前路径定义它们。C编译器的”include-path”选项(在许多系统中为-l)是处理扩展私有库头文件的最好方法，它允许在不改变源码文件的情况下重新组织目录结构。</name></p>
<p>声明了函数或外部变量的头文件应该被那些定义了这些函数和变量的文件所包含。这样一来，编译器就可以做类型检查了，并且外部声明将总是与定义保持一致。</p>
<p>在头文件中定义变量往往是个糟糕的想法，它经常是一个在文件间对代码进行低劣划分的症状。此外，在一次编译中，像typedef和经过初始化的数据定义无法被编译器看到两次。在一些系统中，重复的没有使用extern关键字修饰的未初始化定义也会导致问题。当头文件嵌套时，会出现重复的声明，这将导致编译失败。</p>
<p>头文件不应该嵌套。一个头文件的序应该描述其使用的其他被包含的头文件的实用特性。在极特殊情况下，当大量头文件需要被包含在多个不同的源文件中时，可以被接受的做法是将公共的头文件包含在一个单独的头文件中。</p>
<p>一个通用的做法是将下面这段代码加入到每个头文件中以防止头文件被意外多次包含。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXAMPLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXAMPLE_H</span></span><br><span class="line">...    <span class="comment">/* body of example.h file */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* EXAMPLE_H */</span></span></span><br></pre></td></tr></table></figure>
<p>我们不应该对这种避免多次包含的机制产生依赖，特别是不应该因此而嵌套包含头文件。</p>
<h3 id="2-4-其他文件"><a href="#2-4-其他文件" class="headerlink" title="2.4 其他文件"></a>2.4 其他文件</h3><p>还有一个惯例就是编写一个名为”README”的文件，用于描述程序的整体情况以及问题。例如，我们经常在README包含程序所使用的条件编译选项列表以及相关说明，还可以包含机器无关的文件列表等。</p>
<h2 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h2><blockquote>
<p>“当代码与注释不一致时，两者很可能都是错的” – Norm Schryer</p>
</blockquote>
<p>注释应该描述发生了什么，如何做的，参数的含义，使用和修改了哪些全局变量以及约束或Bugs。避免给那些本身很清晰的代码加注释，因为这些注释信息将很快的过时。注释与代码不一致将会带来负面影响。短小的注释应该是关于做什么的，比如”计算有意义的值”，而不是关于”怎么做”的，例如”值的总和除以n”。C不是汇编；在头3-10行的区域添加注释，说明代码总体是做什么的，经常要比为每行添加注释说明微逻辑更加有用。</p>
<p>注释应该为那些令人不悦的代码作出”辩护”。辩护应该是这样的：如果使用正常的代码，一些糟糕的事情将会发生。但仅仅让代码运行的更快还不足以让这些hack代码显得合理化；而是应该将那些在不使用hack代码时令人无法接受的性能数据展示出来。注释应该对着写不可接受的行为作出解释，并告诉大家为什么使用Hack代码可以很好的解决这个问题。</p>
<p>那些用于描述数据结构，算法等的注释应该以块注释的形式存在。块注释起始以/ <em> 占据1-2列， </em> 放在每行注释前面的第二列，块注释最后以占据2-3列的 <em> / 结尾。另外一个候选方案是每行注释文字前面用 </em> 占据1-2列，块注释以占据1-2列的 * /收尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *    Here is a block comment.</span></span><br><span class="line"><span class="comment"> *    The comment text should be tabbed or spaced over uniformly.</span></span><br><span class="line"><span class="comment"> *    The opening slash-star and closing star-slash are alone on a line.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Alternate format for block comments</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注意</p>
<p><code>grep &#39;^.\e*&#39;</code></p>
<p>将匹配文件中所有的注释。特别长的块注释，诸如持久讨论或版权声明，经常以占据1-2列的/<em> 开始，每行注释文字前没有 </em> ，并最终以占据1-2列的 * /结束。函数内部很适合使用块注释，块注释应该与其描述的代码拥有相同的缩进。独立的单行注释也应该与其说明的代码缩进一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* Get input file from command line. */</span></span><br><span class="line">    <span class="keyword">if</span> (freopen(argv[<span class="number">1</span>], <span class="string">"r"</span>, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror (argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别短的注释可以与其描述的代码放在同一行上，并且要通过tab与代码语句分隔开来。如果针对一块代码有不止一个短注释，这些注释应该具有相同的缩进。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == EXCEPTION) &#123;</span><br><span class="line">    b = TRUE;                <span class="comment">/* special case */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b = isprime(a);            <span class="comment">/* works only for odd a */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-声明"><a href="#4-声明" class="headerlink" title="4. 声明"></a>4. 声明</h2><p>全局声明应该从第一列开始。在所有外部数据声明的前面都应该放置extern关键字。如果一个外部变量是一个在定义时大小确定的数组，那么这个数组界限必须在extern声明时显示指出，除非数组的大小与数组本身编码在一起了(例如，一个总是以0结尾的只读字符数组)。重复声明数组大小对于一些使用他人编写的代码的人特别有益。</p>
<p>指针修饰符*应该与变量名在一起，而不是与类型在一起。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>        *s, *t, *u;</span><br></pre></td></tr></table></figure>
<p>替换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>*    s, t, u;</span><br></pre></td></tr></table></figure>
<p>后者是错误的，因为实际上t和u并未如预期那样被声明为指针。</p>
<p>不相关的声明，即使是相同类型的，也应该独立占据一行。我们应该对声明对象的角色进行注释，不过当常量名本身足以说明角色时，使用#define定义的常量列表则不需要注释。通常多行变量名、值与注释使用相同缩进，使得他们在一列直线上。尽量使用Tab字符而不是空格。结构体和联合体的声明时，每个元素应该单独占据一行，并附带一条注释。{应该与结构体的tag名放在同一行，}应该放在声明结尾的第一列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">boat</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>        wllength;    <span class="comment">/* water line length in meters */</span></span><br><span class="line">    <span class="keyword">int</span>        type;        <span class="comment">/* see below */</span></span><br><span class="line">    <span class="keyword">long</span>        sailarea;    <span class="comment">/* sail area in square mm */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* defines for boat.type */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    KETCH    (1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    YAWL        (2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SLOOP    (3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SQRIG    (4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MOTOR    (5)</span></span><br></pre></td></tr></table></figure>
<p>这些defines有时放在结构体内type声明的后面，并使用足够的tab缩进到结构体成员成员的下一级。如果这些实际值不那么重要的话，使用enum会更好。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bt &#123; KETCH=<span class="number">1</span>, YAWL, SLOOP, SQRIG, MOTOR &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">boat</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>        wllength;    <span class="comment">/* water line length in meters */</span></span><br><span class="line">    <span class="keyword">enum</span> bt    type;        <span class="comment">/* what kind of boat */</span></span><br><span class="line">    <span class="keyword">long</span>        sailarea;    <span class="comment">/* sail area in square mm */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>任何初值重要的变量都应该被显式地初始化，或者至少应该添加注释，说明依赖C的默认初始值0。空初始化”{}”应该永远不被使用。结构体初始化应该用大括号完全括起来。用于初始化长整型(long)的常量应该使用显式长度。使用大写字母，例如2l看起来更像21，数字二十一。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>        x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span>        *msg = <span class="string">"message"</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">boat</span>    <span class="title">winner</span>[] = &#123;</span></span><br><span class="line">    &#123; <span class="number">40</span>, YAWL, <span class="number">6000000L</span> &#125;,</span><br><span class="line">    &#123; <span class="number">28</span>, MOTOR, <span class="number">0L</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果一个文件不是独立程序，而是某个工程整体的一部分，那么我们应该最大化的利用static关键字，使得函数和变量对于单个文件来说是局部范畴的。只有在有清晰需求且无法通过其他方式实现的特殊情况时，我们才允许变量被其他文件访问。这种情况下应该使用注释明确告知使用了其他文件中的变量；注释应该说明其他文件的名字。如果你的调试器遮蔽了你需要在调试阶段查看的静态对象，那么可以将这些变量声明为STATIC，并根据需要决定是否#define STATIC。</p>
<p>最重要的类型应该被typedef，即使他们只是整型，因为独立的名字使得程序更加易读(如果只有很少的几个integer的typedef)。结构体在声明时应该被typedef。保持结构体标志的名字与typedef后的名字相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">splodge_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>    sp_count;</span><br><span class="line">    <span class="keyword">char</span>    *sp_name, *sp_alias;</span><br><span class="line">&#125; <span class="keyword">splodge_t</span>;</span><br></pre></td></tr></table></figure>
<p>总是声明函数的返回类型。如果函数原型可用，那就使用它。一个常见的错误就是忽略那些返回double的外部数学函数声明。那样的话，编译器就会假定这些函数的返回值为一个整型数，并且将bit位逐一尽职尽责的注意转换为一个浮点数(无意义)。</p>
<blockquote>
<p>“C语言的观点之一是程序员永远是对的” – Michael DeCorte</p>
</blockquote>
<h2 id="5-函数声明"><a href="#5-函数声明" class="headerlink" title="5. 函数声明"></a>5. 函数声明</h2><p>每个函数前面应该放置一段块注释，概要描述该函数做什么以及(如果不是很清晰)如何使用该函数。重要的设计决策讨论以及副作用说明也适合放在注释 中。避免提供那些代码本身可以清晰提供的信息。</p>
<p>函数的返回类型应该单独占据一行，(可选的)缩进一个级别。不用使用默认返回类型int；如果函数没有返回值，那么将返回类型声明为void。如 果返回值需要大段详细的说明，可以在函数之前的注释中描述；否则可以在同一行中对返回类型进行注释。函数名(以及形式参数列表)应该被单独放在一 行，从第一列开始。目的(返回值)参数一般放在第一个参数位置(从左面开始)。所有形式参数声明、局部声明以及函数体中的代码都应该缩进一级。函 数体的开始括号应该单独一行，放在开始处的第一列。</p>
<p>每个参数都应该被声明(不要使用默认类型int)。通常函数中每个变量的角色都应该被描述清楚，我们可以在函数注释中描述，或如果每个声明单独一 行，我们可以将注释放在同一行上。像循环计数器”i”，字符串指针”s”以及用于标识字符的整数类型”c”这些简单变量都无需注释。如果一组函数 都拥有一个相似的参数或局部变量，那么在所有函数中使用同一个名字来标识这个变量是很有益处的(相反，避免在相关函数中使用一个名字标识用途不同 的变量)。不同函数中的相似参数还应该放在各个参数列表中的相同位置。</p>
<p>参数和局部变量的注释应该统一缩进以排成一列。局部变量声明应用一个空行与函数语句分隔开来。</p>
<p>当你使用或声明变长参数的函数时要小心。目前在C中尚没有真正可移植的方式处理变长参数。最好设计一个使用固定个数参数的接口。如果一定要使用变 长参数，请使用标准库中的宏来声明具有变长参数的函数。</p>
<p>如果函数使用了在文件中没有进行全局声明的外部变量(或函数)，我们应该在函数体内部使用extern关键字单独对这些变量进行声明。</p>
<p>避免局部声明覆盖高级别的声明。尤其是，局部变量不应该在嵌套代码块中被重声明。虽然这在C中是合法的，但是当使用-h选项时，潜在的冲突可能性 足以让lint工具发出抱怨之声。</p>
<h2 id="6-空格"><a href="#6-空格" class="headerlink" title="6. 空格"></a>6. 空格</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;main()&#123;<span class="keyword">for</span>(;i[<span class="string">"]&lt;i;++i)&#123;--i;&#125;"</span>];read(<span class="string">'-'</span>-<span class="string">'-'</span>,i+++<span class="string">"hell\o, world!\n"</span>,<span class="string">'/'</span>/<span class="string">'/'</span>));&#125;read(j,i,p)&#123;write(j/p+p,i---j,i/i);&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不光彩的事情，模糊C代码大赛，1984年。作者要求匿名。</li>
</ul>
<p>通常情况下，请使用纵向和横向的空白。缩进和空格应该反映代码的块结构。例如，在一个函数定义与下一个函数的注释之间，至少应该有两行空白。</p>
<p>如果一个条件分支语句过长，那就应该将它拆分成若干单独的行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo-&gt;next==<span class="literal">NULL</span> &amp;&amp; totalcount&lt;needed &amp;&amp; needed&lt;=MAX_ALLOT</span><br><span class="line">    &amp;&amp; server_active(current_input)) &#123; ...&#125;</span><br></pre></td></tr></table></figure>
<p>也许下面这样更好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (foo-&gt;next == NULL</span><br><span class="line">    &amp;&amp; totalcount &lt; needed &amp;&amp; needed &lt;= MAX_ALLOT</span><br><span class="line">    &amp;&amp; server_active(current_input))</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>类似地，复杂的循环条件也应该被拆分为不同行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (curr = *listp, trail = listp;</span><br><span class="line">    curr != NULL;</span><br><span class="line">    trail = &amp;(curr-&gt;next), curr = curr-&gt;next )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>其他复杂的表达式，尤其是那些使用了?:操作符的表达式，最好也能拆分成多行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = (a == b)</span><br><span class="line">    ? d + f(a)</span><br><span class="line">    : f(b) - d;</span><br></pre></td></tr></table></figure>
<p>当关键字后面有放在括号内的表达式时，应该使用空格将关键字与左括号分隔(sizeof操作符是个例外)。在参数列表中，我们也应该使用空格显式 的将各个参数隔开。然而，带有参数的宏定义一定不能在名字与左括号间插入空格，否则C预编译器将无法识别后面的参数列表。</p>
<h2 id="7-例子"><a href="#7-例子" class="headerlink" title="7. 例子"></a>7. 例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">         * Determine if the sky is blue by checking that it isn&apos;t night.</span><br><span class="line">         * CAVEAT: Only sometimes right.  May return TRUE when the answer</span><br><span class="line">         * is FALSE.  Consider clouds, eclipses, short days.</span><br><span class="line">         * NOTE: Uses &apos;hour&apos; from &apos;hightime.c&apos;.  Returns &apos;int&apos; for</span><br><span class="line">         * compatibility with the old version.</span><br><span class="line">         */</span><br><span class="line">                int                             /* true or false */</span><br><span class="line">        skyblue()</span><br><span class="line">        &#123;</span><br><span class="line">                extern int      hour;           /* current hour of the day */</span><br><span class="line"></span><br><span class="line">                return (hour &gt;= MORNING &amp;&amp; hour &lt;= EVENING);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Find the last element in the linked list</span><br><span class="line">         * pointed to by nodep and return a pointer to it.</span><br><span class="line">         * Return NULL if there is no last element.</span><br><span class="line">         */</span><br><span class="line">                node_t *</span><br><span class="line">        tail(nodep)</span><br><span class="line">                node_t  *nodep;                 /* pointer to head of list */</span><br><span class="line">        &#123;</span><br><span class="line">                register node_t *np;            /* advances to NULL */</span><br><span class="line">                register node_t *lp;            /* follows one behind np */</span><br><span class="line"></span><br><span class="line">                if (nodep == NULL)</span><br><span class="line">                        return (NULL);</span><br><span class="line">                for (np = lp = nodep; np != NULL; lp = np, np = np-&gt;next)</span><br><span class="line">                        ;       /* VOID */</span><br><span class="line">                return (lp);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-简单语句"><a href="#8-简单语句" class="headerlink" title="8. 简单语句"></a>8. 简单语句</h2><p>每行只应该有一条语句，除非多条语句关联特别紧密。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> FOO:  oogle (zork);  boogle (zork);  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BAR:  oogle (bork);  boogle (zork);  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BAZ:  oogle (gork);  boogle (bork);  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>for或while循环语句的空体应该单独放在一行并加上注释，这样可以清晰的看出空体是有意而为，并非遗漏代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (*dest++ = *src++)</span><br><span class="line">    ;    <span class="comment">/* VOID */</span></span><br></pre></td></tr></table></figure>
<p>不要对非零表达式进行默认测试，例如：</p>
<p><code>if (f() != FAIL)</code></p>
<p>比下面的代码更好</p>
<p><code>if (f())</code><br>即使FAIL的值可能为0(在C中0被认为是假)。当后续有人决定使用-1替代0作为失败返回值时，一个显式的测试将解决你的问题。即使比较的值永远不会改变，我们也应该使用显式的比较；例如<br><code>if (!(bufsize % sizeof(int)))</code></p>
<p>应该被写成</p>
<pre><code>if ((bufsize % sizeof(int)) == 0)
</code></pre><p>这样可以反映这个测试的数值(非布尔)本质。一个常见的错误点是使用strcmp测试字符串是否相同，这个测试的结果永远不应该被放弃。比较好的方法是定义一个宏STREQ。</p>
<pre><code>#define STREQ(a, b) (strcmp((a), (b)) == 0)
</code></pre><p>对谓词或满足下面约束的表达式，非零测试经常被放弃：</p>
<ul>
<li>0表示假，其他都为真。</li>
<li>通过其命名可以看出返回真是显而易见的。</li>
</ul>
<p>用isvalid或valid称呼一个谓词，不要用checkvalid。</p>
<p>一个非常常见的实践就是在一个全局头文件中声明一个布尔类型”bool”。这个特殊的名字可以极大地提高代码可读性。</p>
<pre><code>typedef int    bool;
#define FALSE    0
#define TRUE    1
</code></pre><p>或</p>
<pre><code>typedef enum { NO=0, YES } bool;
</code></pre><p>即便有了这些声明，也不要检查一个布尔值与1(TRUE，YES等)的相当性；可用测试与0(FALSE，NO等)的不等性替代。绝大多数函数都可以保证为假的时候返回0，但为真的时候只返回非零。</p>
<pre><code>if (func() == TRUE) { ...
</code></pre><p>必须被写成</p>
<pre><code>if (func() != FALSE) { ...
</code></pre><p>如果可能的话，最好为函数/变量重命名或者重写这个表达式，这样就可以显而易见的知道其含义，而无需再与true或false比较了(例如，重命名为isvalid())。</p>
<p>嵌入赋值语句也有用武之地。在一些结构中，在没有降低代码可读性的前提下，没有比这更好的方式来实现这个结果了。</p>
<pre><code>while ((c = getchar()) != EOF) {
    process the character
}
</code></pre><p>++和–操作符可算作是赋值语句。这样，为了某些意图，实现带有副作用的功能。使用嵌入赋值语句也可能提高运行时的性能。不过，大家应该在提高的性能与下降的可维护性之间做好权衡。当在一些人为的地方使用嵌入赋值语句时，这种情况会发生，例如：</p>
<pre><code>a = b + c;
d = a + r;
</code></pre><p>不应该被下面代码替代：</p>
<pre><code>d = (a = b + c) + r;
</code></pre><p>即使后者可能节省一个计算周期。在长期运行时，由于优化器渐获成熟，两者的运行时间差距将下降，而两者在维护性方面的差异将提高，因为人类的记忆会随着时间的流逝而衰退。</p>
<p>在任何结构良好的代码中，goto语句都应该保守地使用。使用goto带来好处最大的地方是从switch、for和while多层嵌套中跳出，但这样做的需求也暗示了代码的内层结构应该被抽取出来放到一个单独的返回值为成功或失败的函数中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    for (...) &#123;</span><br><span class="line">        while (...) &#123;</span><br><span class="line">            ...</span><br><span class="line">            if (disaster)</span><br><span class="line">                goto error;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">error:</span><br><span class="line">    clean up the mess</span><br></pre></td></tr></table></figure>
<p>当需要goto时候，其对应的标签应该被放在单独一行，并且后续的代码缩进一级。使用goto语句时应该增加注释(可能放在代码块的头)以说明它的功用和目的。continue应该保守地使用，并且尽可能靠近循环的顶部。Break的麻烦比较少。</p>
<p>非原型函数的参数有时需要被显式做类型提升。例如，如果函数期望一个32bit的长整型，但却被传入一个16bit的整型数，可能会导致函数栈不对齐。指针，整型和浮点值都会发生此问题。</p>
<h2 id="9-复合语句"><a href="#9-复合语句" class="headerlink" title="9. 复合语句"></a>9. 复合语句</h2><p>复合语句是一个由括号括起来的语句列表。有许多种常见的括号格式化方式。如果你有一个本地标准，那请你与本地标准保持一致，或选择一个标准，并持续地使用它。在编辑别人的代码时，始终使用那些代码中使用的样式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">control &#123;</span><br><span class="line">        statement;</span><br><span class="line">        statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的风格被称为”K&amp;R风格”，如果你还没有找到一个自己喜欢的风格，那么可以优先考虑这个风格。在K&amp;R风格中，if-else语句中的else部分以及do-while语句中的while部分应该与结尾大括号在同一行中。而其他大部分风格中，大括号都是单独占据一行的。</p>
<p>当一个代码块拥有多个标签时，每个标签应该单独放在一行上。必须为C语言的switch语句的fall-through特性(即在代码段与下一个case语句之前间没有break)增加注释以利于后期更好的维护。最好是lint风格的注释/指示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch (expr) &#123;</span><br><span class="line">case ABC:</span><br><span class="line">case DEF:</span><br><span class="line">    statement;</span><br><span class="line">    break;</span><br><span class="line">case UVW:</span><br><span class="line">    statement;</span><br><span class="line">    /*FALLTHROUGH*/</span><br><span class="line">case XYZ:</span><br><span class="line">    statement;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，最后那个break是不必要的，但却是必须的，因为如果后续另外一个case添加到最后一个case的后面时，它将阻止fall-through错误的发生。如果使用default case，那么应该该default case放在最后，且不需要break，如果它是最后一个case。</p>
<p>一旦一个if-else语句在if或else段中包含一个复合语句，if和else两个段都应该用括号括上(称为全括号(fully bracketed)语法)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expr) &#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statement;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在如下面那样的没有第二个else的if-if-else语句序列里，括号也是不必可少的。如果ex1后面的括号被省略，编译器解析将出错：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ex1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex2) &#123;</span><br><span class="line">        funca();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    funcb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个带else if的if-else语句在书写上应该让else条件左对齐。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (STREQ (reply, &quot;yes&quot;)) &#123;</span><br><span class="line">    statements for yes</span><br><span class="line">    ...</span><br><span class="line">&#125; else if (STREQ (reply, &quot;no&quot;)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; else if (STREQ (reply, &quot;maybe&quot;)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    statements for default</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种格式看起来像一个通用的switch语句，并且缩进反映了在这些候选语句间的精确切换，而不是嵌套的语句。</p>
<p>Do-while循环总是使用括号将循环体括上。</p>
<p>下面的代码非常危险：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CIRCUIT</span><br><span class="line">#    define CLOSE_CIRCUIT(circno)    &#123; close_circ(circno); &#125;</span><br><span class="line">#else</span><br><span class="line">#    define CLOSE_CIRCUIT(circno)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (expr)</span><br><span class="line">        statement;</span><br><span class="line">    else</span><br><span class="line">        CLOSE_CIRCUIT(x)</span><br><span class="line">    ++i;</span><br></pre></td></tr></table></figure>
<p>注意，在CIRCUIT没有定义的系统上，语句++i仅仅在expr是假的时候获得执行。这个例子指出宏用大写命名的价值，以及让代码完全括号化的价值。</p>
<p>有些时候，通过break，continue，goto或return，if可以无条件地进行控制转移。else应该是隐式的，并且代码不应该缩进。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (level &gt; limit)</span><br><span class="line">    <span class="keyword">return</span> (OVERFLOW)</span><br><span class="line">normal();</span><br><span class="line"><span class="keyword">return</span> (level);</span><br></pre></td></tr></table></figure>
<p>平坦的缩进告诉读者布尔测试在密封块的其他部分是保持不变的。</p>
<h2 id="10-操作符"><a href="#10-操作符" class="headerlink" title="10. 操作符"></a>10. 操作符</h2><p>一元操作符不应该与其唯一的操作数分开。通常，所有其他二元操作符都应该使用空白与其操作树分隔开，但’.’和’-&gt;’例外。当遇到复杂表达式的时候我们需要做出一些判断。如果内层操作符没有使用空白分隔而外层使用了，那么表达式也许会更清晰些。</p>
<p>如果你认为一个表达式很难于阅读，可以考虑将这个表达式拆分为多行。在接近中断点的最低优先级操作符处拆分是最好的选择。由于C具有一些想不到的优先级规则，混合使用操作符的表达式应该使用括号括上。但是过多的括号也会使得代码可读性变差，因为人类不擅长做括号匹配。</p>
<p>二元逗号操作符也会被使用到，但通常我们应该避免使用它。逗号操作符的最大用途是提供多元初始化或操作，比如在for循环语句中。复杂表达式，例如那些使用了嵌套三元?:操作符的表达式，可能引起困惑，并且应该尽可能的避免使用。三元操作符和逗号操作符在一些使用宏的地方很有用，诸如getchar。在三元操作符?:前的逻辑表达式的操作数应该被括起来，并且两个子表达式的返回值应该是相同类型。</p>
<h2 id="11-命名约定"><a href="#11-命名约定" class="headerlink" title="11. 命名约定"></a>11. 命名约定</h2><p>毫无疑问，每个独立的工程都有一套自己的命名约定，不过仍然有一些通用的规则值得参考。</p>
<p>为系统用途保留以下划线开头或下划线结尾的名字，并且这些名字不应该被用在任何用户自定义的名字中。大多数系统使用这些名字用于用户不应 该也不需知道的名字中。如果你一定要使用你自己私有的标识符，可以用标识它们归属的包的字母作为开头。</p>
<ul>
<li>井define定义的常量名字应该全部大写。</li>
<li>Enum常量应该大写或全部大写。</li>
<li>函数名、typedef名，变量名以及结构体、联合体与枚举标志的名字应该用小写字母。</li>
<li>很多”宏函数”都是全部大写的。一些宏(诸如getchar和putchar)使用小写字母命名，这事因为他们可能被当成函数使用。只有在宏的行为类似一 个函数调用时才允许小写命名的宏，也就是说它们只对其参数进行一次求值，并且不会给具名形式参数赋值。有些时候我们无法编写出一个具有函数行为的 宏，即使其参数也只是求值一次。</li>
<li>避免在同一情形下使用不同命名方式，比如foo和Foo。同样避免foobar和foo_bar这种方式。需要考虑这样所带来的困惑。</li>
<li>同样，避免使用看起来相似的名字。在很多终端以及打印设备上，’I’、’1’和’l’非常相似。给变量命名为l特别糟糕，因为它看起来十分像常量’1’。</li>
</ul>
<p>通常，全局名字(包括enum)应该具有一个统一的前缀，通过该前缀名我们可以识别出这个名字归属于哪个模块。全局变量可以选择汇集在一个全局结 构中。typedef的名字通常在结尾加一个’t’。</p>
<p>避免名字与各种标准库中的名字冲突。一些系统可能包含一些你所不需要的库。另外你的程序将来某天很可能也要扩展。</p>
<h2 id="12-常量"><a href="#12-常量" class="headerlink" title="12. 常量"></a>12. 常量</h2><p>数值型常量不应该被硬编码到源文件中。应该使用C预处理器的#define特性为常量赋予一个有意义的名字。符号化的常量可以让代码具有更好的可读性。在一处地方统一定义这些值也便于进行大型程序的管理，这样常量值可以在一个地方进行统一修改，只需修改define的值即可。枚举数据类型更适合声明一组具有离散值的变量，并且编译器还可以对其进行额外的类型检查。至少，任何硬编码的值常量必须具有一段注释，以说明该值的来历。</p>
<p>常量的定义应该与其使用是一致的；例如使用540.0作为一个浮点数，而不是使用540外加一个隐式的float类型转换。有些时候常量0和1被直接使用而没有用define进行定义。例如，一个for循环语句中用于标识数组下标的常量，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARYBOUND; i++)</span><br></pre></td></tr></table></figure>
<p>上面代码是合理的，但下面代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">door_t</span> *front_door = opens(door[i], <span class="number">7</span>);</span><br><span class="line"><span class="keyword">if</span> (front_door == <span class="number">0</span>)</span><br><span class="line">    error(<span class="string">"can't open %s\\\\n"</span>, door[i]);</span><br></pre></td></tr></table></figure>
<p>是不合理的。在最后的那个例子中，front_door是一个指针。当一个值是指针的时候，它应该与NULL比较而不是与0比较。NULL被定义在标准I/O库头文件stdio.h中，在一些新系统中它在stdlib.h中定义。即使像1或0这样的简单值，我们最好也用define定义成TRUE和FALSE定义后再使用(有些时候，使用YES和NO可读性更好)。</p>
<p>简单字符常量应该被定义成字面值，不应该使用数字。不鼓励使用非可见文本字符，因为它们是不可移植的。如果非可见文本字符十分必要，尤其是当它们在字符串中使用时，它们应该定义成三个八进制数字的转义字符(例如： ‘\007‘)而非一个字符。即使这样，这种用法也应该考虑其机器相关性，并按这里的方法处理。</p>
<h2 id="13-宏"><a href="#13-宏" class="headerlink" title="13. 宏"></a>13. 宏</h2><p>复杂表达式可能会被用作宏参数，这可能会因操作符优先级顺序而引发问题，除非宏定义中所有参数出现的位置都用括号括上了。对这种因参数内副作用而引发的问题，我们似乎也无能为例，除了在编写表达式时杜绝副作用(无论如何，这都是一个很好的主意)。如果可能的话，尽量在宏定义中对宏参数只进行一次求值。有很多时候我们无法写出一个可像函数一样使用的宏。</p>
<p>一些宏也当成函数使用(例如，getc和fgetc)。这些宏会被用于实现其他函数，这样一旦宏自身发生变化，使用该宏的函数也会受到影响。在交换宏和函数时务必要小心，因为函数参数是按值传递的，而宏参数则是通过名称替换。只有在宏定义时特别谨慎小心，才有可能减少使用宏时的担心。</p>
<p>宏定义中应该避免使用全局变量，因为全局变量的名字很可能被局部声明遮盖。对于那些对具名参数进行修改(不是这些参数所指向的存储区域)或被用作赋值语句左值的宏，我们应该添加相应的注释以给予提醒。那些不带参数但引用变量，或过长或作为函数别名的宏应该使用空参数列表，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    OFF_A()    (a_global+OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    BORK()    (zork())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SP3()    <span class="meta-keyword">if</span> (b) &#123; int x; av = f (&amp;x); bv += x; &#125;</span></span><br></pre></td></tr></table></figure>
<p>宏节省了函数调用和返回的额外开销，但当一个宏过长时，函数调用和返回的额外开销就变得微不足道了，这种情况下我们应该使用函数。</p>
<p>在一些情况下，让编译器确保宏在使用时应该以分号结尾是很有必要的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x==<span class="number">3</span>)</span><br><span class="line">    SP3();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    BORK();</span><br></pre></td></tr></table></figure>
<p>如果省略SP3调用后面的分号，后面的else将会匹配到SP3宏中的那个if。有了分号，else分支就不会与任何if匹配。SP3宏可以这样安全地实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SP3() \\\\</span></span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="keyword">if</span> (b) &#123; <span class="keyword">int</span> x; av = f (&amp;x); bv += x; &#125;&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>手工给宏定以加上do-while包围看起来很别扭，而且很多编译器和工具会抱怨在while条件是一个常量值。一个用来声明语句的宏可以使得编码更加容易：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifdef lint</span><br><span class="line">    static int ZERO;</span><br><span class="line">#else</span><br><span class="line">#    define ZERO 0</span><br><span class="line">#endif</span><br><span class="line">#define STMT( stuff )        do &#123; stuff &#125; while (ZERO)</span><br><span class="line">我们可以用下面代码来声明SP3宏：</span><br><span class="line"></span><br><span class="line">#define SP3() \\\\</span><br><span class="line">    STMT( if (b) &#123; int x; av = f (&amp;x); bv += x; &#125; )</span><br></pre></td></tr></table></figure>
<p>使用STMT宏可以有效阻止一些可以潜在改变程序行为的打印排版错误。</p>
<p>除了类型转换、sizeof以及上面那些技巧和手法，只有当整个宏用括号括上时才应该包含关键字。</p>
<h2 id="14-条件编译"><a href="#14-条件编译" class="headerlink" title="14. 条件编译"></a>14. 条件编译</h2><p>条件编译在处理机器依赖、调试以及编译阶段设定特定选项时十分有用。不过要小心条件编译。各种控制很容易以一种无法预料的方式结合在一起。如果使用#ifdef判断机器依赖，请确保当没有机器类型适配时，返回一个错误，而不是使用默认机器类型(使用#error并缩进一级，这样它可以一些老旧的编译器下工作)。如果你#ifdef优化选项，默认情况下应该是一个未经优化的代码，而不是一个不兼容的程序。确保测试的是未经优化的代码。</p>
<p>注意在#ifdef区域内的文本可能会被编译器扫描(处理)，即使#ifdef求值的结果为假。但即使文件的#ifdef部分永远不能被编译到(例如，#ifdef COMMENT)，这部分也不该随意的放置文本。</p>
<p>尽可能地将#ifdefs放在头文件中，而不是源文件中。使用#ifdef定义可以在源码中统一使用的宏。例如，一个用于检查内存分配的头文件可能这样实现：(省略了REALLOC和FREE)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">    extern void *mm_malloc();</span><br><span class="line">#    define MALLOC(size) (mm_malloc(size))</span><br><span class="line">#else</span><br><span class="line">    extern void *malloc();</span><br><span class="line">#    define MALLOC(size) (malloc(size))</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>条件编译通常应该基于一个接一个的特性的。多数情况下，都应该避免使用机器或操作系统依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef BSD4</span><br><span class="line">    long t = time ((long *)NULL);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>上面代码之所以糟糕有两个原因：很可能在某个4BSD系统上有更好的选择，并且也可能存在在某个非4BSD系统中上述代码是最佳代码。我们可以通过定义诸如TIME_LONG<br>和TIME_STRUCTD等宏作为替代，并且在诸如config.h的配置文件中定义一个合适的宏。</p>
<h2 id="15-调试"><a href="#15-调试" class="headerlink" title="15. 调试"></a>15. 调试</h2><blockquote>
<p>“C代码。C代码运行。运行，代码，运行… 请运行!!!” – Barbara Tongue</p>
</blockquote>
<p>如果你使用枚举，第一个枚举常量应该是一个非零值，或者第一个常量应该指示一个错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; STATE_ERR, STATE_START, STATE_NORMAL, STATE_END &#125; <span class="keyword">state_t</span>;</span><br><span class="line"><span class="keyword">enum</span> &#123; VAL_NEW=<span class="number">1</span>, VAL_NORMAL, VAL_DYING, VAL_DEAD &#125; <span class="keyword">value_t</span>;</span><br></pre></td></tr></table></figure>
<p>未初始化的值后续将会自己获取。</p>
<p>检查所有错误返回值，即使是那些”不能”失败的函数的返回值。考虑即使之前所有的文件操作都已经成功了，close()和fclose也可能失败。编写你自己的函数，使得它们以一种明确的方式测试错误、返回错误码或从程序中退出。包含大量调试和错误检查代码，并把其中大多数留在最终的产品中。甚至检查那些”不可能”的错误。</p>
<p>使用assert机制保证传给每个函数的值都是定义明确的，并且中间结果是形式良好的。</p>
<p>尽可能少的在调试代码中使用#ifdef。例如，如果mm_malloc是一个调试用的内存分配器，那么MALLOC将挑选合适的分配器，避免使用#ifdef在代码中堆砌垃圾，并且使得分配之间的差异变得清晰，只是在调试期会分配些额外内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">#    define MALLOC(size)  (mm_malloc(size))</span><br><span class="line">#else</span><br><span class="line">#    define MALLOC(size)  (malloc(size))</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>对那些”不可能”溢出的对象做边界校验。一个向变长存储区写入的函数应该接受一个参数maxsize，该参数即目标内存区域的大小。如果有时候目标内存区域大小未知，一些maxsize的”魔数”值应该意味着”没有边界检查”。当边界检查失败，请确保这个函数做一些有用的事情，诸如退出程序或返回一个错误状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * INPUT: A null-terminated source string `src' to copy from and</span></span><br><span class="line"><span class="comment"> * a `dest' string to copy to.  `maxsize' is the size of `dest'</span></span><br><span class="line"><span class="comment"> * or UINT_MAX if the size is not known.  `src' and `dest' must</span></span><br><span class="line"><span class="comment"> * both be shorter than UINT_MAX, and `src' must be no longer than</span></span><br><span class="line"><span class="comment"> * `dest'.</span></span><br><span class="line"><span class="comment"> * OUTPUT: The address of `dest' or NULL if the copy fails.</span></span><br><span class="line"><span class="comment"> * `dest' is modified even when the copy fails.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">char</span> *</span><br><span class="line">copy (dest, maxsize, src)</span><br><span class="line">    <span class="keyword">char</span> *dest, *src;</span><br><span class="line">    <span class="keyword">unsigned</span> maxsize;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *dp = dest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (maxsize\-\- &gt; <span class="number">0</span>)</span><br><span class="line">        if ((*dp++ = *src++) == '\\\\0')</span><br><span class="line">            <span class="keyword">return</span> (dest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，记住一个程序产生错误答案的速度快两倍(译注：是否有南辕北辙的意味)，实则是变得无限缓慢，这个道理对那些偶尔崩溃或打击有效数据的程序同样成立。</p>
<h2 id="16-可移植性"><a href="#16-可移植性" class="headerlink" title="16. 可移植性"></a>16. 可移植性</h2><blockquote>
<p>“C语言结合了汇编的强大功能和可移植性” – 无名氏，暗指比尔.萨克。</p>
</blockquote>
<p>可移植代码的好处是有目共睹的。这一节将阐述一些编写可移植代码的指导原则。这里”可移植的”是指一个源码文件能够在不同机器上被编译和执行，其 前提仅仅是在不同平台上可能包含不同的头文件，使用不同的编译器开关选项罢了。头文件包含的#define和typedef可能因机器而异。一般 来说，一个新”机器”是指一种不同的硬件，一种不同的操作系统，一个不同的编译器，或者是这些的任意组合。参考1包含了很多关于风格和可移植 性方面的有用信息。下面是一个隐患列表，当你设计可移植代码时应该考虑避免这些隐患：</p>
<p>编写可移植的代码。只有当被证明是必要的情况下才考虑优化的细节。优化后的代码往往是模糊不清、难以理解的。在一台机器上经过优化后的代码，在其他机器上 可能变得更加糟糕。将采用的性能优化手段记录下来并尽可能多地本地化。文档应该解释这些手段的工作原理以及引入它们的原因（例如：”循环执行了无 数次”）<br>要意识到很多东西天生就是不可移植的。比如处理类似程序状态字这样的特定硬件寄存器的代码，以及被设计用于支持某特定硬件部件的代码，诸如汇编器以及 I/O驱动。即使在这种情况下，许多例程和数据仍然可以被设计成机器无关的。<br>组织源文件时将机器无关与机器相关的代码分别放在不同文件中。之后如果这个程序需要被移植到一个新机器上时，我们就可以很容易判断出来哪些需要被改变。为 一些文件的头文件中机器依赖相关的代码添加注释。<br>任何”实现相关”的行为都应该作为机器(编译器)依赖对待。假设编译器或硬件以一种十分古怪的方式实现它。<br>注意机器字长。对象的大小可能不直观，指针大小也不总是与整型大小相同，也不总是彼此大小相同，或者可相互自由转换。下面的表中列举了C语言基本类型在不 同机器和编译器下的大小(以bit为单位)。</p>
<table>
<thead>
<tr>
<th style="text-align:right">type</th>
<th style="text-align:right">pdp11</th>
<th style="text-align:right">VAX/11</th>
<th style="text-align:right">68000</th>
<th style="text-align:right">Cray-2</th>
<th style="text-align:right">Unisys</th>
<th style="text-align:right">Harris</th>
<th style="text-align:right">80386</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">series</td>
<td style="text-align:right">family</td>
<td style="text-align:right">1100</td>
<td style="text-align:right">H800</td>
</tr>
<tr>
<td style="text-align:right">char</td>
<td style="text-align:right">8</td>
<td style="text-align:right">8</td>
<td style="text-align:right">8</td>
<td style="text-align:right">8</td>
<td style="text-align:right">9</td>
<td style="text-align:right">8</td>
<td style="text-align:right">8</td>
</tr>
<tr>
<td style="text-align:right">short</td>
<td style="text-align:right">16</td>
<td style="text-align:right">16</td>
<td style="text-align:right">8/16</td>
<td style="text-align:right">64(32)</td>
<td style="text-align:right">18</td>
<td style="text-align:right">24</td>
<td style="text-align:right">8/16</td>
</tr>
<tr>
<td style="text-align:right">int</td>
<td style="text-align:right">16</td>
<td style="text-align:right">32</td>
<td style="text-align:right">16/32</td>
<td style="text-align:right">64(32)</td>
<td style="text-align:right">36</td>
<td style="text-align:right">24</td>
<td style="text-align:right">16/32</td>
</tr>
<tr>
<td style="text-align:right">long</td>
<td style="text-align:right">32</td>
<td style="text-align:right">32</td>
<td style="text-align:right">32</td>
<td style="text-align:right">64</td>
<td style="text-align:right">36</td>
<td style="text-align:right">48</td>
<td style="text-align:right">32</td>
</tr>
<tr>
<td style="text-align:right">char*</td>
<td style="text-align:right">16</td>
<td style="text-align:right">32</td>
<td style="text-align:right">32</td>
<td style="text-align:right">64</td>
<td style="text-align:right">72</td>
<td style="text-align:right">24</td>
<td style="text-align:right">16/32/48</td>
</tr>
<tr>
<td style="text-align:right">int*</td>
<td style="text-align:right">16</td>
<td style="text-align:right">32</td>
<td style="text-align:right">32</td>
<td style="text-align:right">64(24)</td>
<td style="text-align:right">72</td>
<td style="text-align:right">24</td>
<td style="text-align:right">16/32/48</td>
</tr>
<tr>
<td style="text-align:right">int(*)()</td>
<td style="text-align:right">16</td>
<td style="text-align:right">32</td>
<td style="text-align:right">32</td>
<td style="text-align:right">64</td>
<td style="text-align:right">576</td>
<td style="text-align:right">24</td>
<td style="text-align:right">16/32/48</td>
</tr>
</tbody>
</table>
<p>有些机器针对某一类型可能有不止一个大小。其类型大小取决于编译器和不同的编译期标志。下面表展示了大多数系统的”安全”类型大小。无符号与带符 号数具有相同的大小(单位:bit)。</p>
<p>|Type   | Minimum |   No Smaller|<br>|# Bits |   Than||<br>|—–:|—–:|—–:|<br>|char |  8|   |<br>|short   | 16  |  char|<br>|int   | 16 |   short|<br>|long   | 32  |  int|<br>|float    |24  | |<br>|double  |  38 |   float|<br>|any <em>  |  14   ||<br>|char </em>  |  15   | any <em>|<br>|void </em>   | 15    |any *|</p>
<ul>
<li>void星 类型可以保证有足够位精度来表示一个指向任意数据对象的指针。void()()类型可以保证表示一个指向任意函数的指针。当你需要通用指针时 可以使用这些类型(在一些旧的编译器里，分别用char星 和char()()表示)。确保在使用这些指针类型之前将其转换回正确的类型。</li>
<li>即使说一个int星 和一个char星 类型大小相同，它们仍可能具有不同的格式。例如，下面例子在一些sizeof(int)等于 sizeof(char)的机器上可能失败。其原因在与free函数期望一个<br>char星 ，但却传入了一个int星 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">free</span> (p);</span><br></pre></td></tr></table></figure>
<p>注意，一个对象的大小不能保证这个对象的精度。Cray-2可能使用64位来存储一个整型，但一个长整型转换为一个整型并且再转换回长整型后可能会被截断 为32位。<br>整型常量0可以强制转型为任何指针类型。转换后的指针称为对应那个类型的空指针，并且与那个类型的其他指针不同。空指针比较总是与常量0相当。空指针不应 该与一个值为0的变量比较。空指针不总是使用全0的位模式表示。两个不同类型的空指针有些时候可能不同。某个类型的空指针被强制转换为另外一个类 型的指针，其结果是该指针转换为第二个类型的空指针。<br>对于ANSI编译器，当两个类型相同的指针访问同一块存储区时，则它们比较是相等的。当一个非0整型常量被转换为指针类型时，它们可能与其他指针相等。对 于非ANSI编译器，访问同一块存储区的两个指针比较可能并不相同。例如，下面两个指针比较可能相等或不相等，并且他们可能或可能没有访问同一块 存储区域。</p>
<pre><code>((int *) 2 )
((int *) 3 )
</code></pre><p>如果你需要’magic’指针而不是NULL，要么分配一些内存，要么将指针视为机器相关的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x_int_dummy;        <span class="comment">/* in x.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_FAIL    (NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_BUSY    (&amp;x_int_dummy)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_FAIL    (NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_BUSY    MD_PTR1        <span class="comment">/* MD_PTR1 from "machdep.h" */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>浮点数字既包含精度也包含范围。这些都是数据对象大小无关的。但是，一个32位浮点数在不同机器上溢出时的值有所不同。同时，4.9乘以5.1在不同的机 器上可能产生两个不同的数字。在圆整(rounding)和截断方面的差异将给出特别不同的答案。</li>
<li>在一些机器上，一个双精度浮点数在精度或范围方面可能比一个单精度浮点数还要低。</li>
<li>在一些机器上，double值的前半部分可能是一个具有相同值的float类型。千万不要依赖于此。</li>
<li>提防带符号字符。例如，在某些VAX系统上，用在表达式中的字符是符号扩展的，但在其他一些机器上并非如此。对有符号和无符号有依赖的代码是不可移植的。 例如，如果假设c是正值，arrayc在c为有符号且为负值时将无法正常工作。如果你一定要假设signed或unsigned字符的话，请 用SIGNED或UNSIGNED为其加上注释。无符号字符的行为可由unsigned char保证。</li>
<li>避免对ASCII做假设。如果你必须假设，那么请将其记录下来并本地化。请记住字符很可能用不止8位表示。</li>
<li>大多数机器采用2的补码表示数，但我们在代码中不应该利用这一特点。使用等价移位操作替代算术运算的优化尤其值得怀疑。如果必须这么做，那么机器相关的代 码应该用#ifdef定义，或者操作应该在#ifdef宏判定下执行。你应该衡量一下使用这种难以理解的代码所节省的时间与做代码移植时找bug 所花费的时间相比孰多孰少。</li>
<li>一般情况下，如果字长或值范围非常重要，应该使用typedef定义具有特定大小的类型。大型程序应该具有一个统一的头文件用于提供通用的、大小 (size)敏感的类型的typedef定义，这样更加便于修改以及在紧急修复时查找大小敏感的代码。无符号类型比有符号整型更加编译器无关。如 果既可以用16bit也可以用32bit标识一个简单for循环的计数器，我们应该使用int。因为对于当前机器来说，通过整型可以获取更高效 (自然)的存储单元。</li>
<li>数据对齐也很重要。例如，在不同的机器上，一个四字节的整型数的可能以任意地址作为起始地址，也可能只允许以偶数地址作为起始地址，或者只能以4的整数倍 的地址作为起始地址。因此，一个特定的结构体的各个元素在不同的机器上的偏移量有不同，即使给定的这些元素在所有机器上的大小相同。事实上，一个 包含一个32位指针和一个8位字符的结构提在三个不同的机器上可能有三个不同的大小。作为一个推论，对象指针可能无法自由互换；通过一个指向起始 地址为奇数地址长度为4个字节的指针保存一个整型数有时可以正常工作，但有时则会导致产生core，有些时候静悄悄地失败了(在这个过程中会破坏 其他数据)。在那些不按字节寻址的机器上，字符指针更是”事故高发地区”。对齐考虑以及加载器的特殊性使得很容易轻率地认为两个连续声明的变量在 内存中也是连在一起的，或者某个类型的变量已经被适当对齐并可以用作其他类型变量使用了。</li>
<li>在一些机器上，诸如VAX(小端)，一个字的字节随着地址的增加，其重要性提高；而另外一些机器上，诸如68000(大端)，随着地址的增加，其重要性降 低。字或更大数据对象(诸如一个双精度字)的字节顺序可能并不相同。因此，任何依赖对象内从左到右方向位模式的代码都值得特别细致的审查。只有当 结构体中两个不同的位字段不被连接以及不被当作一个单元时，这些位字段才具备可移植性。事实上，连接任意两个变量都是不可移植的行为。<br>结构体中有一些未使用的空洞。猜想联合体用于类型欺骗。尤其是，一个值不应该在存储时使用一个类型，而在读取时使用另外一种类型。对联合体来说，一个显式 的标签(tag)字段可能会很有用。<br>不同的编译器在返回结构体时使用不同的约定。这就会导致代码在接受从不同编译器编译的库代码中返回的结构体值时会出现错误。结构体指针不是问题。<br>不要假设参数传递机制。特别是指针大小以及参数求值顺序，大小等。例如，下面的代码就不具备可移植性。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    c = foo (getchar(), getchar());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span></span><br><span class="line">foo (c1, c2, c3)</span><br><span class="line">    <span class="keyword">char</span> c1, c2, c3;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> bar = *(&amp;c1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (bar);            <span class="comment">/* often won't return c2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的例子有诸多问题。栈可能向上增长，也可能向下增长(事实上，甚至都不需要一个栈)。参数在传入时可能被扩大，例如一个char可能以int型被传 入。参数可能以从左到右，从右到左，或以任意顺序压入栈，或直接放在寄存器中(根本无需压栈)。参数求值的顺序也可能与压栈的次序有所不同。一个 编译器可能使用多种(不兼容的)调用约定。</li>
<li>在某些机器上，空字符指针((char *)0)常被当作指向空字符串的指针对待。不要依赖于此。</li>
<li>不要修改字符串常量。下面就是一个臭名昭著的例子</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"/dev/tty??"</span>;</span><br><span class="line"><span class="built_in">strcpy</span> (&amp;s[<span class="number">8</span>], ttychars);</span><br></pre></td></tr></table></figure>
<ul>
<li>地址空间可能有空洞。简单计算一个数组中未分配空间的元素(在数组实际存储区域之前或之后)的地址可能会导致程序崩溃。如果这个地址被用于比较，有时程序 可以运行，但会破坏数据，报错，或陷入死循环。在ANSI C中，指向一个对象数组的指针指向数组结尾后的第一个元素是合法的，这在一些老编译器上通常是安全的。不过这个”在外边”不可以被解引用。</li>
<li>只有==和!=比较可用于某给定类型的所有指针。当两个指针指向同一个数组内的元素(或数组后第一个元素)时，使用&lt;&lt;、&lt;=、&amp; gt;或&gt;=对两个指针进行比较是可移植的。同样，仅仅对指向同一个数组内的元素(或数组后第一个元素)的两个指针使用算术操作符才是可移 植的。</li>
<li>字长(word size)也影响移位和掩码。下面代码在一些68000机器上只会将一个整型数的最右三个位清0，而在其他机器上它还会将高地址的两个字节清零。x &amp;= 0177770 使用 x &amp;= ~07可以在所有机器上正常工作。位字段(bitfield)没有这些问题。</li>
<li>表达式内的副作用可能导致代码语义是编译器相关的，因为在大多数情况下C语言的求值顺序是没有显式定义的。下面是一个臭名昭著的例子：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = b[i++];</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们只知道b的下标值没有被增加。a的下标i值可能是自增后的值也可能是自增前的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bar_t</span> &#123;</span> <span class="class"><span class="keyword">struct</span> <span class="title">bar_t</span> *<span class="title">next</span>;</span> &#125; bar;</span><br><span class="line">bar-&gt;next = bar = tmp;</span><br></pre></td></tr></table></figure>
<p>在第二个例子中，bar-&gt;next的地址很可能在bar被赋值之前被计算使用。</p>
<pre><code>bar = bar-&gt;next = tmp;
</code></pre><p>第三个例子中，bar可能在bar-&gt;next之前被赋值。虽然这可能有悖于”赋值从右到左处理”的规则，但这确是一个合法的解析。考虑下 面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> i;</span><br><span class="line"><span class="keyword">short</span> a[N];</span><br><span class="line">i = old</span><br><span class="line">i = a[i] = <span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>
<p>赋给i的值必须是一个按照从右到左的处理顺序进行赋值处理后的值。但是i可能在ai被赋值前而被赋值为”</p>
<pre><code>(long) (short)new&quot;。不同编译器作法不同。
</code></pre><p>质疑代码中出现的数值(“魔数”)。<br>避免使用预处理器技巧。一些诸如使用/ /粘和字符串以及依赖参数字符串展开的宏会破坏代码可靠性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(string)    (printf(<span class="meta-string">"string = %s"</span>,(string)))</span></span><br><span class="line"> ...</span><br><span class="line">FOO(filename);</span><br></pre></td></tr></table></figure>
<p>只是在有些时候会扩展为</p>
<pre><code>(printf(&quot;filename = %s&quot;,(filename)))
</code></pre><p>小心。诡异的预处理器在一些机器上可能导致宏异常中断。下面是一个宏的两种不同实现版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOKUP(chr)    (a[<span class="meta-string">'c'</span>+(chr)])    <span class="comment">/* Works as intended. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOKUP(c)    (a[<span class="meta-string">'c'</span>+(c)])        <span class="comment">/* Sometimes breaks. */</span></span></span><br></pre></td></tr></table></figure>
<p>第二个版本的LOOKUP可能以两种不同的方式扩展，并且会导致代码异常中断。</p>
<ul>
<li>熟悉现有的库函数和定义(但不用太熟悉。与其外部接口相反，库基础设施的内部细节常会改变并且没有警告，这些细节常常也是不可移植的)。你不应该再自己重 新编写字符串比较例程、终端控制例程或为系统结构编写你自己的定义。自己动手实现既浪费你的时间，又使得你的代码可读性变差，因为另外一个读者需 要知道你是否在新的实现中做了什么特殊的事情，并尝试证实它们的存在。同时这样做会使得你无法充分利用一些辅助的微代码或其他有助于提高系统例程 性能的方法。更进一步，它将是一个bug的高产源头。如果可能的话，要知道公共库之间的差异(如ANSI、POSIX等等)。</li>
<li>如果lint可用，请使用lint。这个工具对于查找代码中机器相关的构造、其他不一致性以及顺利通过编译器检查的程序bug时具有很高价值。如果你的编 译器具备打开警告的开关，请打开它。</li>
<li>质疑在代码块内部的与代码块外部switch或goto有关联的标签(Label)。</li>
<li>无论类型在哪里，参数都应该被转换为适当的类型。当NULL用在没有原型的函数调用时，请对NULL进行转换。不要让函数调用成为类型欺骗发生的地方。C 语言的类型提升规则很是让人费解，所以尽量小心。例如，如果一个函数接受一个32位长的长整型做为参数，但实际传入的却是一个16位长的整型数， 函数栈可能会无法对齐，这个值也可能会被错误提升。</li>
<li>在混用有符号和无符号值的算术计算时请使用显式类型转换</li>
<li>应该谨慎使用跨程序的goto、longjmp。很多实现”忘记”恢复寄存器中的值了。尽可能将关键的值声明为volatile，或将它们注释为 VOLATILE。</li>
<li>一些链接器将名字转换为小写，并且一些链接器只识别前六个字母作为唯一标识。在这些系统上程序可能会悄悄地中断运行。</li>
<li>当心编译器扩展。如果使用了编译器扩展，请将他们视为机器依赖并用文档记录下来。</li>
<li>通常程序无法在数据段执行代码或者无法将数据写入代码段。即使程序可以这么做，也无法保证这么做是可靠的。</li>
</ul>
<h2 id="17-标准C"><a href="#17-标准C" class="headerlink" title="17. 标准C"></a>17. 标准C</h2><p>现代C编译器支持一些或全部的ANSI提议的标准C。无论何时可能的话，尽量用标准C编写和运行程序，并且使用诸如函数原型，常量存储以及volatile(易失性)存储等特性。标准C通过给优化器提供有有效的信息以提升程序的性能。标准C通过保证所有编译器接受同样的输入语言以及提供相关机制隐藏机器相关内容或对于那些机器相关代码提供警告的方式提升代码的可移植性。</p>
<h3 id="17-1-兼容性"><a href="#17-1-兼容性" class="headerlink" title="17.1 兼容性"></a>17.1 兼容性</h3><p>编写很容易移植到老编译器上的代码。例如，有条件地在global.h中定义一些新(标准中的)关键字，比如const和volatile。标准编译器预定义了预处理器符号STDC(见脚注8)。void星 类型很难简单地处理正确，因为很多老编译器只理解void，但不认识void星 。最简单的方法就是定义一个新类型VOIDP(与机器和编译器相关)，通常在老编译器下该类型被定义为char星 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#if __STDC__</span><br><span class="line">    typedef void *voidp;</span><br><span class="line">#    define COMPILER_SELECTED</span><br><span class="line">#endif</span><br><span class="line">#ifdef A_TARGET</span><br><span class="line">#    define const</span><br><span class="line">#    define volatile</span><br><span class="line">#    define void int</span><br><span class="line">    typedef char *voidp;</span><br><span class="line">#    define COMPILER_SELECTED</span><br><span class="line">#endif</span><br><span class="line">#ifdef ...</span><br><span class="line">    ...</span><br><span class="line">#endif</span><br><span class="line">#ifdef COMPILER_SELECTED</span><br><span class="line">#    undef COMPILER_SELECTED</span><br><span class="line">#else</span><br><span class="line">    &#123; NO TARGET SELECTED! &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>注意在ANSI C中，#必须是同一行中预处理器指示符的第一个非空白字符。在一些老编译器中，它必须是同一行中的第一个字符。</p>
<p>当一个静态函数具有前置声明时，前置声明必须包含存储修饰符。在一些老编译器中，这个修饰符必须是”extern”。对于ANSI编译器，这个存储修饰符必须为static，但全局函数依然必须声明为extern。因此，静态函数的前置声明应该使用一个#define，例如FWD_STATIC，并通过#ifdef适当定义。</p>
<p>一个”#ifdef NAME”应该要么以”#endif”结尾，要么以”#endif /星 NAME 星/结尾，不应该用”#endif NAME”结尾。对于短小的#ifdef不应该使用注释，因为通过代码我们可以明确其含义。</p>
<p>ANSI的三字符组可能导致内容包含??的字符串的程序神秘的中断。</p>
<h3 id="17-2-格式化"><a href="#17-2-格式化" class="headerlink" title="17.2 格式化"></a>17.2 格式化</h3><p>ANSI C的代码风格与常规C一样，但有两点意外：存储修饰符(storage qualifiers)和参数列表。</p>
<p>由于const和volatile的绑定规则很奇怪，因此每个const或volatile对象都应该单独声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *s;        <span class="comment">/* YES */</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *s, *t;    <span class="comment">/* NO */</span></span><br></pre></td></tr></table></figure>
<p>具备原型的函数将参数声明和定义归并在一个参数列表中了。应该在函数的注释中提供各个参数的注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * `bp&apos;: boat trying to get in.</span><br><span class="line"> * `stall&apos;: a list of stalls, never NULL.</span><br><span class="line"> * returns stall number, 0 =&gt; no room.</span><br><span class="line"> */</span><br><span class="line">    int</span><br><span class="line">enter_pier (boat_t const *bp, stall_t *stall)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h3 id="17-3-原型"><a href="#17-3-原型" class="headerlink" title="17.3 原型"></a>17.3 原型</h3><p>Function prototypes should be used to make code more robust and to make it run faster. Unfortunately, the prototyped declaration</p>
<p>应该使用函数原型使得代码更加健壮并且运行时性能更好。不幸地是原型的声明</p>
<pre><code>extern void bork (char c);
</code></pre><p>与定义不兼容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">void</span></span><br><span class="line">bork (c)</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>原型中c应该以机器上最自然的类型传入，很可能是一个字节。而非原型化(向后兼容)的定义暗示c总是以一个整型传入。如果一个函数具有可类型提升的参数，那么调用者和被调用者必须以相等地方式编译。要么都必须使用函数原型，要么都不使用原型。如果在程序设计时参数就是可以提升类型的，那么问题就可以被避免，例如bork可以定义成接受一个整型参数。</p>
<p>如果定义也是原型化的，上面的声明将工作正常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    void</span><br><span class="line">bork (char c)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>不幸地是，原型化的语法将导致非ANSI编译器拒绝这个程序。</p>
<p>但我们可以很容易地通过编写外部声明来同时适应原型与老编译器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if __STDC__</span><br><span class="line">#    define PROTO(x) x</span><br><span class="line">#else</span><br><span class="line">#    define PROTO(x) ()</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>extern char 星星ncopies PROTO((char 星s, short times));<br>注意PROTO必须使用双层括号。</p>
<p>最后，最好只使用一种风格编写代码(例如，使用原型)。当需要非原型化的版本时，可使用一个自动转换工具生成。</p>
<h3 id="17-4-Pragmas"><a href="#17-4-Pragmas" class="headerlink" title="17.4 Pragmas"></a>17.4 Pragmas</h3><p>Pragmas用于以一种可控的方式引入机器相关的代码。很显然，pragma应该被视为机器相关的。不幸地是，ANSI pragmas的语法使得我们无法将其隔离到机器相关的头文件中了。</p>
<p>Pragmas分为两类。优化相关的可以被安全地忽略。而那些影响系统行为(需要pragmas)的Pragmas则不能忽略。需要的pragmas应该结合#ifdef使用，这样如果一个pragma都没有选到，编译过程将退出。</p>
<p>两个编译器可能通过两个不同的方式使用同一个给定的pragma。例如，一个编译器可能使用haggis发出一个优化信号。而另一个可能使用它暗示一个特定语句，一旦执行到此，程序应该退出。不过，一旦使用了pragma，它们必须总是被机器相关的#ifdef包围。对于非ANSI编译器，Pragmas必须总是被#ifdef。确保对#pragma的#进行缩进，否则一些较老的预处理器处理它时会挂起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if defined(__STDC__) &amp;&amp; defined(USE_HAGGIS_PRAGMA)</span><br><span class="line">    #pragma (HAGGIS)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“ANSI标准中描述的’#pragma’命令具有任意实现定义的影响。在GNU C预处理中，’#pragma’首先尝试运行游戏’rogue’；如果失败，它将尝试运行游戏’hack’；如果失败，它将尝试运行GNU Emacs显示汉诺塔；如果失败，它将报告一个致命错误。无论如何，预处理将不再继续。”<br>– GNU CC 1.34 C预处理手册。</p>
</blockquote>
<h2 id="18-特殊考虑"><a href="#18-特殊考虑" class="headerlink" title="18. 特殊考虑"></a>18. 特殊考虑</h2><p>这节包含一些杂项：‘做’与’不做’。</p>
<ul>
<li>不要通过宏替换来改变语法。这将导致程序对于所有人都是难以理解的，除了那个肇事者。<br>不要在需要离散值的地方使用浮点变量。使用一个浮点数作为循环计数器无疑是搬起石头砸自己的脚。总是用&lt;=或&gt;=测试浮点数，对它们永远不要 用精确比较(==或!=)。</li>
<li>编译器也有bug。常见且高发的问题包括结构体赋值和位字段。你无法泛泛的预测一个编译器都有哪些bug。但你可以在程序中避免使用那些已知的在所有编译 器上都存在问题的结构。你无法让你写的任何代码都是有用的，你可能仍然会遇到bug，并且在这期间编译器很可能会被修复。因此，只有当你被强制使 用某个特定的充斥bug的编译器时，你才应该”围绕”着编译器bug写代码。</li>
<li>不要依赖自动代码美化工具。良好代码风格的主要受益者就是代码的编写者，并且尤其在手写算法或伪代码的早期设计阶段。自动代码美化工具只应该用在那些已经 完成、语法正确并且此后不能满足当空白和缩进被更为关注的要求时。伴随着对细致程序员的细节的关注，对于那些将函数或文件布局解释清楚的工作，程 序员们会做得更好(换句话说，一些视觉布局是由意图而不是语法决定的，美化工具无法了解到程序员的思想)。粗心的程序员应该学习成为一个细致的程 序员，而不是依赖美化工具让代码可读性更好。</li>
<li>意外地遗漏逻辑比较表达式中的第二个=是一个常犯的问题。使用显式测试。避免对赋值使用隐式测试。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abool = bbool;</span><br><span class="line">if (abool) &#123; ...</span><br></pre></td></tr></table></figure>
<p>当嵌入的赋值表达式使用时，确保测试是显式的，这样后续它就无法被”修复”了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while ((abool = bbool) != FALSE) &#123; ...</span><br><span class="line">while (abool = bbool) &#123; ...    /* VALUSED */</span><br><span class="line">while (abool = bbool, abool) &#123; ...</span><br></pre></td></tr></table></figure>
<ul>
<li>显式地注释那些在正常控制流之外被修改的变量，或其他可能在维护过程中中断的代码。</li>
<li>现代编译器会自动将变量放到寄存器中。对于你认为最关键的变量慎用寄存器。在极端情况下，用寄存器标记2-4个最为关键的值，并且将剩余的标记为 REGISTER。后者在那些具有较多寄存器的机器上可以#define为寄存器。</li>
</ul>
<h2 id="19-Lint"><a href="#19-Lint" class="headerlink" title="19. Lint"></a>19. Lint</h2><p>Lint是一个C程序检查工具，用于检查C语言源码文件，探测和报告诸如类型不兼容、函数定义与调用不一致以及潜在的bug等情况。强烈建议在所 有程序上使用lint工具，并且期望大多数工程将lint作为官方验收程序的一部分。</p>
<p>应该注意的是使用lint的最好方法不是将lint作为官方验收之前的一道必须跨过的栅栏，而是作为一个在代码发生添加或变更之后使用的工具。 Lint可以发现一些隐藏的bug并且可以在问题发生前保证程序的可移植性。lint产生的许多信息确实暗示了一些事情是错误的。一个有意思的故 事是关于一个漏掉了fprintf的一个参数的程序：</p>
<pre><code>fprintf (&quot;Usage: foo -bar &lt;file&gt;\n&quot;);
</code></pre><p>作者从未有过一个问题。但每当一个正常用户在命令行上犯错，这个程序就会产生一个core。许多版本的lint工具都能发现这个问题。</p>
<p>大多lint选项都值得我们学习。一些选项可能在合法的代码上给出警告，但它们也会捕捉到许多把事情搞遭的代码。注意’–p’只能为库的一个子 集检查函数调用和类型的一致性，因此程序为了最大化的覆盖检查，应该同时进行带–p和不带–p的lint检查。</p>
<p>Lint也可以识别代码里的一些特殊注释。这些注释可以强制让lint在发现问题时关闭警告输出，还可以作为一些特殊代码的文档。</p>
<h2 id="20-Make"><a href="#20-Make" class="headerlink" title="20. Make"></a>20. Make</h2><p>另外一个非常有用的工具是make。在开发过程中，make只会重新编译那些上次make后发生了改变的模块。它也可以用于自动化其他任务。一些 常见的约定包括：</p>
<p>all<br>     执行所有二进制文件的构建过程</p>
<p>clean<br>     删除所有中间文件</p>
<p>debug<br>     构建一个测试用二进制文件a.out或debug</p>
<p>depend<br>     制作可传递的依赖关系</p>
<p>install<br>     安装二进制文件，库等</p>
<p>deinstall<br>     取消安装</p>
<p>mkcat<br>     安装手册</p>
<p>lint<br>    运行lint工具</p>
<p>print/list<br>    制作一个所有源文件的拷贝</p>
<p>shar<br>    为所有源文件制作一个shar文件</p>
<p>spotless<br>     执行make clean，并将源码存入版本控制工具。注意：不会删除Makefile，即便它是一个源文件。</p>
<p>source<br>     撤销spotless所做的事情。</p>
<p>tags<br>     运行ctags(建议使用-t标志)</p>
<p>rdist<br>     分发源码到其他主机</p>
<p>file.c<br>     从版本控制系统中检出这个文件</p>
<p>除此之外，通过命令行也可以定义Makefile使用的值(如”CFLAGS”)或源码中使用的值(如”DEBUG”)。</p>
<h2 id="21-工程相关的标准"><a href="#21-工程相关的标准" class="headerlink" title="21. 工程相关的标准"></a>21. 工程相关的标准</h2><p>除了这里提到内容外，每个独立的工程都期望能建立附加标准。下面是每个工程程序管理组需要考虑的问题中的一部分：</p>
<ul>
<li>哪些额外的命名约定需要遵守？尤其是，那些用于全局数据的功能归类以及结构体或联合体成员名字的系统化的前缀约定非常有用。</li>
<li>什么样的头文件组织适合于工程特定的数据体系结构？</li>
<li>应该建立什么样的规程来审核lint警告？需要确立一个与lint选项一致的宽容度，保证lint不会针对一些不重要的问题给出警告，但同时保证真正的bug或不一致问题不被隐藏。</li>
<li>如果一个工程建立了自己的档案库，它应该计划向系统管理员提供一个lint库文件。这个lint库文件允许lint工具检查对库函数的兼容性使用。</li>
<li>需要使用哪种版本控制工具？</li>
</ul>
<h2 id="22-结论"><a href="#22-结论" class="headerlink" title="22. 结论"></a>22. 结论</h2><p>这里描述了一套C语言编程风格的标准。其中最重要的几点是：</p>
<p>合理使用空白和注释，使得我们通过代码布局就可以清楚地看出程序的结构。使用简单表达式、语句和函数，使他们可以很容易地被理解。<br>记住，在将来某个时候你或其他人很可能会被要求修改代码或让代码运行在一台不同的机器上。精心编写代码，使得其可以移植到尚不确定的机器上。局部化你的优化，因为这些优化经常让人困惑，并且对于该优化措施是否适合其他机器我们持悲观态度。<br>许多风格选择是主观武断的。保持代码风格一致比遵循这些绝对的风格规则更重要(尤其是与组织内部标准保持一致)。混用风格比任何一种糟糕的风格都更加糟糕。<br>无论采用哪种标准，如果认为该标准有用就必须遵循它。如果你觉得遵循某条标准时有困难，不要仅仅忽略它们，而是在和你当地的大师或组织内的有经验的程序员讨论后再做决定.</p>
<h2 id="23-参考资料"><a href="#23-参考资料" class="headerlink" title="23. 参考资料"></a>23. 参考资料</h2><p>B.A. Tague, C Language Portability, Sept 22, 1977. This document issued by department 8234 contains three memos by R.C. Haight, A.L. Glasser, and T.L. Lyon dealing with style and portability.<br>S.C. Johnson, Lint, a C Program Checker, Unix Supplementary Documents, November 1986.<br>R.W. Mitze, The 3B/PDP-11 Swabbing Problem, Memorandum for File, 1273-770907.01MF, September 14, 1977.<br>R.A. Elliott and D.C. Pfeffer, 3B Processor Common Diagnostic Standards- Version 1, Memorandum for File, 5514-780330.01MF, March 30, 1978.<br>R.W. Mitze, An Overview of C Compilation of Unix User Processes on the 3B, Memorandum for File, 5521-780329.02MF, March 29, 1978.<br>B.W. Kernighan and D.M. Ritchie, The C Programming Language, Prentice Hall 1978, Second Ed. 1988, ISBN 0-13-110362-8.<br>S.I. Feldman, Make – A Program for Maintaining Computer Programs, UNIXSupplementary Documents, November 1986.<br>Ian Darwin and Geoff Collyer, Can’t Happen or / NOTREACHED / or Real Programs Dump Core, USENIX Association Winter Conference, Dallas 1985 Proceedings.<br>Brian W. Kernighan and P. J. Plauger The Elements of Programming Style. McGraw-Hill, 1974, Second Ed. 1978, ISBN 0-07-034-207-5.<br>J. E. Lapin Portable C and UNIX System Programming, Prentice Hall 1987, ISBN 0-13-686494-5.<br>Ian F. Darwin, Checking C Programs with lint, O’Reilly &amp; Associates, 1989. ISBN 0-937175-30-7.<br>Andrew R. Koenig, C Traps and Pitfalls, Addison-Wesley, 1989. ISBN 0-201-17928-8.</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程规范 </tag>
            
            <tag> 中文版 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的考研经验及给后人的建议（03）——英语篇]]></title>
      <url>/2015/05/%E9%9A%8F%E7%AC%94/%E7%94%9F%E6%B4%BB-%E6%88%91%E7%9A%84%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C%E5%8F%8A%E7%BB%99%E5%90%8E%E4%BA%BA%E7%9A%84%E5%BB%BA%E8%AE%AE%EF%BC%8803%EF%BC%89%E2%80%94%E2%80%94%E8%8B%B1%E8%AF%AD%E7%AF%87/</url>
      <content type="html"><![CDATA[<h3 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h3><p>我本人的英语基础超差（四级都没考）。不过考研英语分数不错——66分（新题型全对，翻译全对，阅读错4-6分，完型错4-6分，写作覆灭），而且我的复习时间也相对的比较短，所以的我的英语复习经验应该是我的考研经历中最值的借鉴的。<a id="more"></a></p>
<h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><p>NULL</p>
<h3 id="复习的原则"><a href="#复习的原则" class="headerlink" title="复习的原则"></a>复习的原则</h3><p>鉴于两点：</p>
<ul>
<li>考研的英语确实比难———多半人考研不过原因就是英语不过线，（不要笑，好多人就是考不了那听起来很底的38分）。</li>
<li>语言的学习是个不断积累的过程，半年的时间想学好，几乎不可能，特别是你还要学数学、政治、专业课。<br>所以半年想英语怎么怎么翻天覆地的变化就洗洗睡吧。<strong>但是</strong>，考试就不一样了，应试总是有方法的！  (￣y▽￣)~*<br>综上，我的原则就是：</li>
<li><strong>重视</strong>，但不要怕，不要破罐子破摔。</li>
<li><strong>抓大放小</strong>，全面铺开——时间精力不够也得不偿失，所以要优先攻克分时比（分数于时间的比）最高的——<strong>以最少的投入，拿最高的分儿</strong>。<h3 id="复习方法"><a href="#复习方法" class="headerlink" title="复习方法"></a>复习方法</h3><h4 id="英语题型及分值"><a href="#英语题型及分值" class="headerlink" title="英语题型及分值"></a>英语题型及分值</h4>1、完型填空（10分）<br>2、阅读理解（40分）<br>3、阅读——新题型（10分）<br>4、英译汉 （10分）<br>5、应用文（10分）<br>6、短文写作（20分） <h4 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h4></li>
<li>不难看出，两种阅读加起来分值刚好一半！——果然是那句古话：“<strong>得阅读者得天下</strong>”。所以——<strong>阅读是复习第一位的！！</strong></li>
<li>作文：30分，不过去年湖北地区作文加英译汉的平均分是可怜的17分<em>未经证实，姑且信之</em>，别的地区能那到什么地方呢？。综上，作文拿高分是不那容易了，所以——我的建议就是<strong>模板背一下，拿平均分走人。</strong></li>
<li>英译汉，不好拿分，不过可以和阅读一起复习，不占我们宝贵的时间。拿多少分就看运气了（我去年是满分╮(╯▽╰)╭  ）。</li>
<li>完型填空——你自己找个真题做一下就知道有多难，还是个最考基本功的东西，不是你半年可以搞定的，所以，少年郎 我跟你港啊——<strong>基础不好的同学还是放弃吧</strong>。 </li>
</ul>
<h3 id="复习的计划"><a href="#复习的计划" class="headerlink" title="复习的计划"></a>复习的计划</h3><h4 id="复习用书"><a href="#复习用书" class="headerlink" title="复习用书"></a>复习用书</h4><p>我的第一篇文章写过的，<a href="http://chnwentao.com/2015/04/26/我的考研经验及给后人的建议——开题/">网址</a></p>
<h4 id="单词的重要性"><a href="#单词的重要性" class="headerlink" title="单词的重要性"></a>单词的重要性</h4><p><strong>阅读是考研的核心，单词是阅读的核心，也是英语的一切的基础</strong><br>再次强调，单词是一切，单词不背，别的啥弄都没意义！<br>骚年，你就乖乖的去背单词吧。<br>背单词的方法——怎么高兴怎么来，反正你怎么背都是都个忘， ╮(╯_╰)╭<br>我当年是一天两个小时，两个list。5天一次复习，正好一个月背一遍，背到10月份，尼玛翻开一看还是大部分都不认识！！然后就准备弃考了。所以大家要有心理准备！<br>注意点:</p>
<ul>
<li>不要拼写，不要读音，识单词记意思就足够了，不要浪费时间！当然你要是觉得这样加深记忆，请随意。</li>
<li><strong>药不能停</strong>，单词这货你一周不理就不认识了！<strong>千万不能停！！不到最考前十分钟坚决不停！！</strong>后期时候，你可能没那么多时间。可以减少时间，十分种都好，但<strong>不能停！！！</strong></li>
</ul>
<h4 id="阅读-翻译"><a href="#阅读-翻译" class="headerlink" title="阅读+翻译"></a>阅读+翻译</h4><p>过年50分，我拿了44到46，错了3个到2个（有几个记不清我当时做的对不对了）。</p>
<h5 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h5><ul>
<li><strong>单词</strong>(上面说的)。</li>
<li><strong>语法</strong>：搞的懂主谓宾，从句中的定语从句是啥东西就够了。什么？你不知道，好吧，怎么和我一样菜呢？给你们个地址吧，<a href="http://pan.baidu.com/s/1mgikoCo" target="_blank" rel="noopener">我的网盘</a> (这个讲的太细，不过很基础，你就1.5-2.0倍速，一两天听完就ok,不用笔记，大概知道就好)。</li>
<li><strong>长难句</strong>：不用专门买书，特别是那本何凯文的，就是个XX。相信我，你买了也看不下去的。别听辅导班忽悠，长难句不可怕。你做你的真题就好，见多了自然就懂了。<strong>看不懂是单词背的少，看错是见的少</strong>。</li>
<li><strong>翻译</strong> ，翻译就是一种要书面翻译的长难句，有一定的技巧和套路，学会了很简单。给你们个视频吧，新东方的武峰老师的，超级棒！<a href="http://pan.baidu.com/s/1dD6Lfzz" target="_blank" rel="noopener">这是地址</a> 你们就在复习阅读的时候按他说的方法，翻译一下阅读里的句子就OK啦!</li>
</ul>
<h5 id="复习的计划-1"><a href="#复习的计划-1" class="headerlink" title="复习的计划"></a>复习的计划</h5><p><strong>真题,还是真题，近十年的就OK</strong>。和数学一样，<strong>千万不要碰模拟题！！！！</strong>被它带沟里概不负责！！！！</p>
<h5 id="阅读怎么做？"><a href="#阅读怎么做？" class="headerlink" title="阅读怎么做？"></a>阅读怎么做？</h5><p>（<strong>每个人的情况不同，大家参考，不是硬套！！！不然会进沟里的</strong>）<br>重点是掐时间——17分钟上下，养成习惯，超了自己找原因。<br>考研文章很难，一般是看不懂说了啥了，不过不要怕，这个不影响答题的。考研阅读的一大特点就是：很傻逼的一段话一个问题，很固定有没有？最多就第5个问题可以问一下什么题目，中心思想什么的。————那我们的方法就出来了！<strong>先通读问题，然后一个问题，一段的去找答案</strong>。<br>怎么找答案呢？我粗略的统计了一下近十年的真题，85%长难句里有答案！40%的观点标志词是答案，还有转折词！这个都是我们阅读的时候要注意的地方！<br>我就不太详细的说了，这个要自己总结，不要套别人的。多做题多总结！</p>
<h5 id="怎么用真题？"><a href="#怎么用真题？" class="headerlink" title="怎么用真题？"></a>怎么用真题？</h5><p><strong>真题不是只做一遍的！！5遍6遍不算多！！我时间那么紧都做了近三遍啊！</strong><br>不要说第二遍你都记住了什么的，你确定你第二遍，第三遍都能全对？能翻译的下来？看一眼就知道答案在哪儿？能你就不用了做下一遍了。<br>使用步骤：<br>1.自己做一遍，不要太纠结对错，全错也正常。<br>2.全文翻译，一个单词一个单词的来，不要嫌麻烦。不会的单词抄下来，和单词书一起每天背。长难句最好手译一下，练习一下翻译嘛。<br>3.对答案，要求是：知道错为什么错，对为什么对。为什么问这个？正确答案在文章哪？错误选项怎么来的？标志词在哪儿？<br>4.分析：出题思路，问题和文章的关系？问题间的关系；文章逻辑，开门见山还是欲扬先抑？观点在哪儿？有没有标志（老外的文章一定有，自己琢磨一下）？<strong>例子和观点的关系</strong>（这个很重要，好吧，我说一个我的经验，观点是考点，但观点在长难句里，基础不好的人看不懂，便你可以看的懂例子啊，例子不是证明观点，就是反驳观点，那么我们的答案不就出来了！！）。<br>5.总结 ：观点词，标志词及其位置，上面提到的各种关系。设问方法。易错点等等………………</p>
<h4 id="写作-新题型"><a href="#写作-新题型" class="headerlink" title="写作+新题型"></a>写作+新题型</h4><p>我的写作今年被坑了，没好好复习不说，还押错了题， 不然我就75+了╮(╯_╰)╭<br>我的观点就是暑假后就开始准备，不要花太多时间，一个星期一篇。<br>重点是：总结自己的模板，见到题都套的。我当时的模板不错，相当万能。可是去年出的太偏了啊！！十年不遇的啊！！要的可以联系我，blog有联系方式。<br>新题型不用专门复习，就是难度降低+字数加长+答案都在原文有原话的阅读，一般也不会怎么错，我一直是全对的。建议后期熟悉一下题型就好！</p>
<h3 id="注意点及共性问题答疑"><a href="#注意点及共性问题答疑" class="headerlink" title="注意点及共性问题答疑"></a>注意点及共性问题答疑</h3><p>欢迎留言提出问题及建议，共同努力，帮助更多的人！！<br>留言请点击<a href="http://chnwentao.com">我的博客</a>，方便我尽快回复！</p>
<h3 id="相关文章链接-2015-05-01"><a href="#相关文章链接-2015-05-01" class="headerlink" title="相关文章链接[^2015-05-01]"></a>相关文章链接[^2015-05-01]</h3><p><a href="http://chnwentao.com/2015/04/26/我的考研经验及给后人的建议——数学篇/">数学的备考</a><br><a href="http://chnwentao.com/2015/04/26/我的考研经验及给后人的建议——开题/">总的建议</a></p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[OSX10.10.3照片应用如何切换图库]]></title>
      <url>/2015/04/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-OSX10-10-3%E7%85%A7%E7%89%87%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E5%9B%BE%E5%BA%93/</url>
      <content type="html"><![CDATA[<h3 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h3><p>OSX10.10.3 最重榜的（有争议的）更新可能就是<strong>照片</strong>应该了。<br>前几天更新了以后发现系统竟然默认不能更换图库！！<br>经过不懈的摸索，终于被我找到啦！<a id="more"></a></p>
<h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><p>NULL</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>实际上巨简单：通过按住键点击“照片”应用的图标，启动时会出现选择图库的选项！</p>
<h3 id="OSX上的类似功能"><a href="#OSX上的类似功能" class="headerlink" title="OSX上的类似功能"></a>OSX上的类似功能</h3><p>itunes 中当你想给你的iphone或ipad安装自己下载的更新：<br>用数据线把iPad连上电脑，点击右上角iPad字样，按住Option，同时点击“恢复iPad”，选择刚才下载好的iOS 7系统固件进行恢复。</p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 方法 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> 应用 </tag>
            
            <tag> 照片 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的考研经验及给后人的建议（02）——数学篇]]></title>
      <url>/2015/04/%E9%9A%8F%E7%AC%94/%E7%94%9F%E6%B4%BB-%E6%88%91%E7%9A%84%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C%E5%8F%8A%E7%BB%99%E5%90%8E%E4%BA%BA%E7%9A%84%E5%BB%BA%E8%AE%AE%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>===================（接上篇）===================</p>
<h3 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h3><p>这个最晚五一后就要准备了，知道我为啥要现在急着写了吧，再不写就只能给你们下届的看了：）<br><a id="more"></a></p>
<h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><p>2015-05-01 添加注意点及共性问题答疑<br>2015-05-01 相关文章链接[^2015-05-01]<br>2015-05-01 添加用书选择<br>2015-05-01 添加<a href="http://pan.baidu.com/s/1bn75ctx" target="_blank" rel="noopener">汤家凤的高数基础班视频链接</a></p>
<h3 id="用书选择"><a href="#用书选择" class="headerlink" title="用书选择"></a>用书选择</h3><p>我的第一篇文章写过的，<a href="http://chnwentao.com/2015/04/26/我的考研经验及给后人的建议——开题/">网址</a></p>
<h3 id="预备知识（5月——6月中）"><a href="#预备知识（5月——6月中）" class="headerlink" title="预备知识（5月——6月中）"></a>预备知识（5月——6月中）</h3><p>打基础的阶段，在这个时间段要过一遍课本，选做一下课习题，目标：1 对知识有一个框架，2 全面的理解每一个概念和公式，不然以后看全书就像看天书一样……<br>但是基础不好的同学直接一般抓不住重点，走马观花，这个是就浪费时间了，我当时的就是选择听<a href="http://pan.baidu.com/s/1bn75ctx" target="_blank" rel="noopener">汤家凤的高数基础班视频（链接）</a> ，1.5倍速听，省下的时候用来做一题，嘿嘿。不做题的结果就听过就忘，一点印象也没：（<br>+++++++<strong>强调，数学，做题就是王道，没有其他，要高分就是多做题，这可是血 的教训！！</strong>++++++<br>线代的复习呢，我也是听汤的基础班，虽说他的线代不出名，但是真的不错，他思路的整理分析的特别好。<strong>墙裂推荐</strong> ！再说了，你都熟悉了他的思路，听起来也接受的快。 这里不推荐李永乐的视频：太难，不适合入门。  </p>
<h3 id="基础阶段（6月中到暑假末）"><a href="#基础阶段（6月中到暑假末）" class="headerlink" title="基础阶段（6月中到暑假末）"></a>基础阶段（6月中到暑假末）</h3><p>这个是复习的黄金阶段，大把的时间给数学吧，争取全书和讲义都刷 <strong>两遍</strong>。<br>注意点：<br>1 刷题是做，不是看！，不管会不会，都是自己动手做一遍！<strong>我们的经验就是 看题目》自己做》对答案》不正确的话，把标准步骤默写一遍，写整齐点，以后用的到，》整理一下人家的思路，你的思路，写到题的旁边</strong>。<br>2 注意<strong>步骤</strong>，考研数学100+的人丢分一般都是步骤和计算，步骤规范，题没算出来 都可以拿不少分的，我的120就是这么来的。<br>3 注意计算，你复习到9——10月的时候会发现，你所以的题都会，可以就是算不对，到时候你会崩溃的。<br>4 时间的把握，一般的人，一天6小时，高数一遍是25天，线代一遍15到20天，<strong>不要拖，时间永远是不够的</strong>.  </p>
<h3 id="强化时间（要求10月20号前完成）"><a href="#强化时间（要求10月20号前完成）" class="headerlink" title="强化时间（要求10月20号前完成）"></a>强化时间（要求10月20号前完成）</h3><p>任务: 1 全书第三遍（主要是整理错题和常见题的技巧和思路）； 2 600题：两遍 ； 3 400两遍（如果有时间的话——这个时间你可能大半的时间要给专业课了，）；<br>注意点：<br>1 不要怕不会，好多人一看600题 ，发现一个都不会，然后就崩溃了。我想说的是大家都是一个样子，你不会，他也不会，你只要坚持认认真真的做下来，你会有收获的。还是上面说的，<strong>坚持就是胜利！</strong><br>2 这个时间要多注意<strong>对知识系统的理解</strong>，这时间的题一般都涉及好几章的知识，还有就是对 <strong>题目已知条件的蕴含</strong>的总结（ 我的个人经验！）。  </p>
<h3 id="刷真题时间（10月底到考前五分钟）"><a href="#刷真题时间（10月底到考前五分钟）" class="headerlink" title="刷真题时间（10月底到考前五分钟）"></a>刷真题时间（10月底到考前五分钟）</h3><p>记住是 <strong>真题</strong>！！千万不要碰模拟题！！！不要问为什么！！！<br>能刷几遍就是刷几遍（每个题至少3遍），越多越好的，顺着做，倒着做，做到吐。<br>先一套一套的做，做的时候掐时间，不看答案。<br>第二遍，一种题型一种题型的做，做到看到题型就知道步骤，知道陷阱……<br>第三遍，就是模拟考场环境，一套一套的做<br>第四遍（你确定你还有时间??）,  那你专功错的比较多题型，你说什么？不会的？这个时间怎么可能还有不会！！只有算不对的，没有不会的！  </p>
<h3 id="注意点及共性问题答疑"><a href="#注意点及共性问题答疑" class="headerlink" title="注意点及共性问题答疑"></a>注意点及共性问题答疑</h3><p>欢迎留言提出问题及建议，共同努力，帮助更多的人！！<br>留言请点击<a href="http://chnwentao.com">我的博客</a>，方便我尽快回复</p>
<h3 id="相关文章链接-2015-05-01"><a href="#相关文章链接-2015-05-01" class="headerlink" title="相关文章链接[^2015-05-01]"></a>相关文章链接[^2015-05-01]</h3><p><a href="http://chnwentao.com/2015/04/26/我的考研经验及给后人的建议——数学篇/">英语的备考</a><br><a href="http://chnwentao.com/2015/04/26/我的考研经验及给后人的建议——开题/">总的建议</a><br><a href="http://chnwentao.com/2015/05/01/我的考研经验及给后人的建议（03）——英语篇/">英语的备考</a></p>
<h3 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h3><p><a href="http://chnwentao.com/2015/05/01/我的考研经验及给后人的建议（03）——英语篇/">英语的备考</a><br>政治的备考<br>专业课的备考；<br>可能你也会遇到的问题：</p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 经验 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 考试 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SublimeText3入门教程-安装及配置]]></title>
      <url>/2015/04/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-SublimeText%203-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h2><p>本文以自己的经历为主线介绍了Sublime Text，旨在成为最合适初学者的的Sublime Text入门教程。<br>注意：本文主要是针对MAC用户 <a id="more"></a></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<h2 id="前言——为什么选择Sublime-Text-3"><a href="#前言——为什么选择Sublime-Text-3" class="headerlink" title="前言——为什么选择Sublime Text 3"></a>前言——为什么选择Sublime Text 3</h2><p>其实很简单——用的人多…………正式一点的说，就是下面几个原因：</p>
<ol>
<li><p>跨平台：Unix/Linux/Win 全平台支持，换电脑不用重新学.</p>
</li>
<li><p>扩展性强、插件丰富，你想的到，想不到的他都；</p>
</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="主程序安装"><a href="#主程序安装" class="headerlink" title="主程序安装"></a>主程序安装</h3><p>可用命令行，也可以用安装包——推荐初学者使用，一键就OK;<br><a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083.dmg" target="_blank" rel="noopener">OS X版安装地址</a></p>
<h3 id="安装Package-Control"><a href="#安装Package-Control" class="headerlink" title="安装Package Control"></a>安装Package Control</h3><p>Sublime Text支持大量插件，如何找到并管理这些插件就成了一个问题，神器 ：Package Control可以很方便的浏览、安装和卸载Sublime Text中的插件。<br>安装方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 Browse up a folder and then into the Installed Packages/ folder</span><br><span class="line">2 Download Package Control.sublime-package and copy it into the Installed Packages/ directory</span><br><span class="line">3 Restart Sublime Text</span><br></pre></td></tr></table></figure>
<p>安装方法二：<br>打开ST3，点击菜单 View -&gt; Show Console，会在底部出现一个命令输入框，然后将上面的命令拷贝到输入框中，回车，等待，安装成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>Ctrl+D 选词 （反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑）<br>Ctrl+G 跳转到相应的行<br>Ctrl+J 合并行（已选择需要合并的多行时）<br>Ctrl+L 选择整行（按住-继续选择下行）<br>Ctrl+M 光标移动至括号内开始或结束的位置<br>Ctrl+T 词互换<br>Ctrl+U 软撤销<br>Ctrl+P 查找当前项目中的文件和快速搜索；输入 @ 查找文件主标题/函数；或者输入 : 跳转到文件某行；<br>Ctrl+R 快速列出/跳转到某个函数<br>Ctrl+K Backspace 从光标处删除至行首<br>Ctrl+KB 开启/关闭侧边栏<br>Ctrl+KK 从光标处删除至行尾<br>Ctrl+KT 折叠属性<br>Ctrl+KU 改为大写<br>Ctrl+KL 改为小写<br>Ctrl+K0 展开所有<br>Ctrl+Enter 插入行后（快速换行）<br>Ctrl+Tab 当前窗口中的标签页切换</p>
<p>Ctrl+Shift+A 选择光标位置父标签对儿<br>Ctrl+Shift+D 复制光标所在整行，插入在该行之前<br>ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找<br>Ctrl+Shift+K 删除整行<br>Ctrl+Shift+L 鼠标选中多行（按下快捷键），即可同时编辑这些行<br>Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号）<br>Ctrl+Shift+P 打开命令面板<br>Ctrl+Shift+/ 注释已选择内容<br>Ctrl+Shift+↑可以移动此行代码，与上行互换<br>Ctrl+Shift+↓可以移动此行代码，与下行互换<br>Ctrl+Shift+[ 折叠代码<br>Ctrl+Shift+] 展开代码<br>Ctrl+Shift+Enter 光标前插入行<br>Ctrl+PageDown 、Ctrl+PageUp 文件按开启的前后顺序切换</p>
<p>Ctrl+Z 撤销<br>Ctrl+Y 恢复撤销<br>Ctrl+F2 设置书签<br>Ctrl+/ 注释整行（如已选择内容，同“Ctrl+Shift+/”效果）<br>Ctrl+鼠标左键 可以同时选择要编辑的多处文本</p>
<p>Shift+鼠标右键（或使用鼠标中键）可以用鼠标进行竖向多行选择<br>Shift+F2 上一个书签<br>Shift+Tab 去除缩进<br>Alt+Shift+1~9（非小键盘）屏幕显示相等数字的小窗口</p>
<p>Alt+. 闭合当前标签<br>Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑</p>
<p>Tab 缩进 自动完成<br>F2 下一个书签<br>F6 检测语法错误<br>F9 行排序(按a-z)<br>F11 全屏模式</p>
<h2 id="我的常用功能及插件推荐"><a href="#我的常用功能及插件推荐" class="headerlink" title="我的常用功能及插件推荐"></a>我的常用功能及插件推荐</h2><p>ConvertToUTF8：转码成utf-8，解决乱码</p>
<p>Bracket Highlighter：匹配括号<br>是一个括号、引号、标签高亮插件，支持 []、()、{}、””、’’ 和 <tag></tag> 等，比 Sublime Text 自带的高亮要明显得多。</p>
<p>Monokai Extended 主题，推荐使用</p>
<p>sublimeLinter 是少数几个能在sublime text 3工作的代码检查插件，SublimeLinter支持JavaScript、CSS、HTML、Java、PHP、Python、Ruby等十多种开发语言，但前提是需要配置相应语言的环境，要检查JavaScript代码需要安装node.js，检查PHP代码需要安装PHP并配置环境等。SublimeLinter可以及时提示编写代码中存在的不规范和错误的写法，并培养我们良好的编码习惯和风格。</p>
<p>TrailingSpaces：强迫症患者必备</p>
<p>MarkDown Editing：支持Markdown语法高亮；支持Github Favored Markdown语法；自带3个主题。</p>
<p>TableEditor：Markdown中的表格书写体验真心不咋样，所有有人为这个开发了一个插件，具有较好的自适应性，会自动对齐，强迫症患者喜欢。<br>首先需要用ctrl + shift + p打开这个功能（Table Editor: Enable for current syntax or Table Editor: Enable for current view or “Table Editor: Set table syntax … for current view”），然后就可以狂用tab来自动完成了~~~</p>
<p>Alignment：进行智能对齐。</p>
<h3 id="C的编译环境"><a href="#C的编译环境" class="headerlink" title="C的编译环境"></a>C的编译环境</h3><h4 id="markdown的使用"><a href="#markdown的使用" class="headerlink" title="markdown的使用"></a>markdown的使用</h4><p>可以参考这个： 说的很全，且插件都相当不错</p>
<p>-<a href="http://frank19900731.github.io/blog/2015/04/13/zai-sublime-zhong-pei-zhi-markdown-huan-jing/" target="_blank" rel="noopener">在 Sublime 中配置 Markdown 环境</a></p>
<h3 id="python-相关"><a href="#python-相关" class="headerlink" title="python 相关"></a>python 相关</h3><ul>
<li>Anaconda 取消错误提示：Sublime &gt; Preferences &gt; Package Settings &gt; Anaconda &gt; Settings User 中添加如下代码： <code>{&quot;anaconda_linting&quot;: false}</code></li>
<li><a href="https://github.com/JerryKwan/Sublime-Text-2-pydocstring" target="_blank" rel="noopener">python 自动生成注释的插件</a></li>
</ul>
<h2 id="z参考"><a href="#z参考" class="headerlink" title="z参考"></a>z参考</h2><p><a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">sublime官方</a><br><a href="http://lucida.me/blog/sublime-text-complete-guide/" target="_blank" rel="noopener">Sublime Text 全程指南</a></p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工具使用 </tag>
            
            <tag> 教程 </tag>
            
            <tag> SublimeText </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的考研经验及给后人的建议（01）——总述]]></title>
      <url>/2015/04/%E9%9A%8F%E7%AC%94/%E7%94%9F%E6%B4%BB-%E6%88%91%E7%9A%84%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C%E5%8F%8A%E7%BB%99%E5%90%8E%E4%BA%BA%E7%9A%84%E5%BB%BA%E8%AE%AE%E2%80%94%E2%80%94%E5%BC%80%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h3><p>不用看我的人个经历的话，可以从我是如何准备的看起。<a id="more"></a></p>
<h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><p>2015-05-01 加入摘要、后面几遍文章的链接<br>2015-05-01 添加注意点及共性问题答疑<br>2015-05-01 错别字修改<br>2015-05-01 添加教科书链接</p>
<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>去年的这个时候下定决心考研，五一刚过就说服了领导，以最快的速度办理了离职手续，五月底就杀回武汉。现在想想可能领导当时那么好说话，估计是早就发现我志不在此了吧。考研前便说要将自己的考研的经历写下来，让后来的人少走些弯路，可以复试完一个多月了，却一直忙着忙那的没时间动笔。这几天网站刚刚建好，建站真的很烦，就用[2015-05-01修改]这篇文章祭奠一下我的脑细胞吧！</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="我的情况："><a href="#我的情况：" class="headerlink" title="我的情况："></a>我的情况：</h4><p>08年毕业，后在一个核电站工作，工作三年后下决心考研。（我想说的就是自己基础不怎么样，都三年一眼书都没看过了啊！！特别是英语，高考完就丢了！）<br>报考的学校是一个一本非211（为什么选这个在2.1里面会说的） 的专业硕士；<br>考研的分数是英语 66；政治 63； 数学 121；专业课 135 ；总分 385 (什么概念呢，就是全国除了那么一两所大学以外的学校都能过线。）</p>
<h4 id="我为什么要考研的问题："><a href="#我为什么要考研的问题：" class="headerlink" title="我为什么要考研的问题："></a>我为什么要考研的问题：</h4><p>这个说来话长了，要从高考说起……算了，还是跳过历史性话题吧，总的来说是对当时的生活不满意（好吧，是相当的厌恶），并它归结为历史遗留原因。然后呢，想了两年，对比了不少的案例，觉的考研是是一最优的方向。为什么呢？<br>原因01：工作几年了，对所处的行业不喜欢想换个行业，但是，换行业的话，工作经验清零，而自己又已不是应届生了，再找工作就变的很困难。（国企几乎不可能）…………那考研就是个不错的选择，即能换个自己喜欢的工作，还能提升自己。<br>原因02：学历太低，现在本科都是必备属性，专科：奇怪的的东西 ：）</p>
<h3 id="我是如何准备的："><a href="#我是如何准备的：" class="headerlink" title="我是如何准备的："></a>我是如何准备的：</h3><h4 id="想清楚为什么要考研（这个极端重要！！）"><a href="#想清楚为什么要考研（这个极端重要！！）" class="headerlink" title="想清楚为什么要考研（这个极端重要！！）"></a>想清楚为什么要考研（这个极端重要！！）</h4><p><strong>再次重复，这个很重要！很重要！！</strong><br>想清楚为什么要考研，一定要给自己的充分的理由、坚定的信念。<br>考研不难，不是少数高智商人群的游戏，一般的人只要用心都是考的上，但是很辛苦。其贵在坚持，我所见到的，    只要全身心去努力的，没有考不上自己理想的学校的。没考上的很大的一部分是没有坚持的到最后，或没有正常的利用好时间（对，我说的就是那种玩手机的，玩游戏的，和女朋友happy的）。</p>
<h4 id="考研前——学校的选择："><a href="#考研前——学校的选择：" class="headerlink" title="考研前——学校的选择："></a>考研前——学校的选择：</h4><p>首选名校啦！中国常春藤，C9,985什么的，名校在以后的工作就是个大buff。但名校的复试一般有歧视，所以学历不太好的同学还是谨慎一点，初试分够了，复试被莫名其妙的刷掉很不划算的。所以我的建议一：就是一级一级的跳，三本报一本（非221）；二本的报211；211的报985；<br>给专科和三本的同学的建议：就是一定要看清楚招生简章，多看几遍总是没错的。和我一起考研的一个专科女生就是没看清楚（也可能是侥幸心理），人家的条件他不满足，初试过了。可是学校直接不让复试。</p>
<h3 id="辅导用书的准备："><a href="#辅导用书的准备：" class="headerlink" title="辅导用书的准备："></a>辅导用书的准备：</h3><p>总的原则就是：用大多数都在用的，总是没错的。一是用的人多证明权威，二资料好找，考研时间就是分数 ，能省就省，能花钱买就花钱买。所以比较小众的书籍请慎重（问一下自己：他要是真的好，大家为什么没人用呢？）<br>我的书单：</p>
<ul>
<li>教材 给大家个电子版的吧。<a href="http://pan.baidu.com/s/1eQxV7WY" target="_blank" rel="noopener">网盘</a></li>
<li>英语：1 单词：大绿皮——新东方乱序（实际上都差不多，自己看着顺眼就好，还能增加背单词的欲望，唉，背单词是个苦差事儿），2 阅读——张建的大黄皮真题阅读；3 写作书——老蒋（怎么也是黄皮？怪怪的）</li>
<li>数学二：1 基础 ：李永乐的复习全书（粉色的那本）+李永乐的线代讲义；2 提高 ：660题+ 400题 （这个可选，你不一定有时间看的）最后：真题，我用的李永乐的真题（和复习全书一样，一个系列的那本）</li>
<li>政治：大纲解析+风中劲草+肖1000+肖4套+任4套</li>
</ul>
<h3 id="注意点及共性问题答疑"><a href="#注意点及共性问题答疑" class="headerlink" title="注意点及共性问题答疑"></a>注意点及共性问题答疑</h3><p>欢迎留言提出问题及建议，共同努力，帮助更多的人！！<br>留言请点击<a href="http://chnwentao.com">我的博客</a>，方便我尽快回复！</p>
<h3 id="下集预告及相关文章链接-2015-05-01更新"><a href="#下集预告及相关文章链接-2015-05-01更新" class="headerlink" title="下集预告及相关文章链接[^2015-05-01更新]"></a>下集预告及相关文章链接[^2015-05-01更新]</h3><p><a href="http://chnwentao.com/2015/04/26/我的考研经验及给后人的建议——数学篇/">数学的备考</a><br><a href="http://chnwentao.com/2015/05/01/我的考研经验及给后人的建议（03）——英语篇/">英语的备考</a><br>政治的备考<br>专业课的备考；<br>可能你也会遇到的问题：</p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 经验 </tag>
            
            <tag> 考试 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
