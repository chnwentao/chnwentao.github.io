<!DOCTYPE html><html lang=""><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Java多线程的总结 | CS Learning of CHNwentao</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.3"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?js?c4c99183a6a02c53d4760ae1995c3b38";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script><link rel="icon" href="/favicon.ico"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#更新记录"><span class="toc-number">1.</span> <span class="toc-text">更新记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程-VS-多进程"><span class="toc-number">2.</span> <span class="toc-text">多线程 VS 多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多进程"><span class="toc-number">2.1.</span> <span class="toc-text">多进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程"><span class="toc-number">2.2.</span> <span class="toc-text">多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协作式线程VS-抢占式线程"><span class="toc-number">3.</span> <span class="toc-text">协作式线程VS 抢占式线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread-类-Vs-Runnable-接口"><span class="toc-number">4.</span> <span class="toc-text">Thread 类 Vs Runnable 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-类"><span class="toc-number">4.1.</span> <span class="toc-text">Thread 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runnable-接口"><span class="toc-number">4.2.</span> <span class="toc-text">Runnable 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新特性-线程池"><span class="toc-number">5.</span> <span class="toc-text">新特性-线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全"><span class="toc-number">6.</span> <span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步"><span class="toc-number">7.</span> <span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#锁-amp-synchronized-关键字"><span class="toc-number">7.1.</span> <span class="toc-text">锁 & synchronized 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile关键字"><span class="toc-number">7.2.</span> <span class="toc-text">volatile关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的通信"><span class="toc-number">8.</span> <span class="toc-text">线程的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见的问题"><span class="toc-number">9.</span> <span class="toc-text">常见的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在多线程中，什么是上下文切换-context-switching-？"><span class="toc-number">9.1.</span> <span class="toc-text">在多线程中，什么是上下文切换(context-switching)？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何让正在运行的线程暂停一段时间？"><span class="toc-number">9.2.</span> <span class="toc-text">如何让正在运行的线程暂停一段时间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你对线程优先级的理解是什么？"><span class="toc-number">9.3.</span> <span class="toc-text">你对线程优先级的理解是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可以直接调用Thread类的run-方法么？"><span class="toc-number">9.4.</span> <span class="toc-text">可以直接调用Thread类的run()方法么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户线程和守护线程有什么区别？"><span class="toc-number">9.5.</span> <span class="toc-text">用户线程和守护线程有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你如何确保main-方法所在的线程是Java程序最后结束的线程？"><span class="toc-number">9.6.</span> <span class="toc-text">你如何确保main()方法所在的线程是Java程序最后结束的线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步方法和同步块，哪个是更好的选择？"><span class="toc-number">9.7.</span> <span class="toc-text">同步方法和同步块，哪个是更好的选择？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是ThreadLocal"><span class="toc-number">9.8.</span> <span class="toc-text">什么是ThreadLocal?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Java-Timer类？如何创建一个有特定时间间隔的任务？"><span class="toc-number">9.9.</span> <span class="toc-text">什么是Java Timer类？如何创建一个有特定时间间隔的任务？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://7xiuu0.com1.z0.glb.clouddn.com/17-11-23/22222257.jpg"></div><div class="author-info__name text-center">Wente Guo</div><div class="author-info__description text-center">一个学习的博客网站，专注于计算机科学、机器学习、数据挖掘等的 技术分享、相关咨询及经验总结</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">146</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">194</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">20</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container" style="background-image: url(true);"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">CS Learning of CHNwentao</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">Java多线程的总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-31</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"> </i><a class="post-meta__categories" href="/categories/Java/">Java</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2,731</span><span class="post-meta__separator">|</span><span>Reading time: 8 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>NULL</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 id="多线程-VS-多进程"><a href="#多线程-VS-多进程" class="headerlink" title="多线程 VS 多进程"></a>多线程 VS 多进程</h2><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>在大多数操作系统中都可以创建多个进程。当一个程序启动时，它可以为即将开始的每项任务创建一个进程，并允许它们同时运行。当一个程序因等待网络访问或用户输入而被阻塞时，另一个程序还可以运行，这样就增加了资源利用率。但是，按照这种方式创建每个进程要付出一定的代价：设置一个进程要占用相当一部分处理器时间和内存资源。而且，大多数操作系统不允许进程访问其他进程的内存空间。因此，进程间的 <strong>通信很不方便</strong>，并且也不会将它自己提供给容易的编程模型。<a id="more"></a></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>线程也称为轻型进程 (LWP)。因为线程只能在单个进程的作用域内活动，所以创建线程比创建进程要廉价得多。这样，因为线程允许协作和数据交换，并且在计算资源方面非常廉价，所以线程比进程更可取。线程需要操作系统的支持，因此不是所有的机器都提供线程。</p>
<h2 id="协作式线程VS-抢占式线程"><a href="#协作式线程VS-抢占式线程" class="headerlink" title="协作式线程VS 抢占式线程"></a>协作式线程VS 抢占式线程</h2><p><strong>协作式线程</strong> 模型允许线程自己决定什么时候放弃处理器来等待其他的线程。程序开发员可以精确地决定某个线程何时会被其他线程挂起，允许它们与对方有效地合作。缺点在于某些恶意或是写得不好的线程会消耗所有可获得的 CPU 时间，导致其他线程“饥饿”。<br><strong>抢占式线程</strong> 模型中，操作系统可以在任何时候打断线程。通常会在它运行了一段时间（就是所谓的一个时间片）后才打断它。这样的结果自然是没有线程能够不公平地长时间霸占处理器。</p>
<p>抢占式线程模型要求线程正确共享资源，协作式模型却要求线程共享执行时间。</p>
<h2 id="Thread-类-Vs-Runnable-接口"><a href="#Thread-类-Vs-Runnable-接口" class="headerlink" title="Thread 类 Vs Runnable 接口"></a>Thread 类 Vs Runnable 接口</h2><h3 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a>Thread 类</h3><p>Thread 类是一个具体的类，即不是抽象类，该类封装了线程的行为。要创建一个线程，程序员必须创建一个从 Thread 类导出的新类。程序员必须覆盖 Thread 的 run() 函数来完成有用的工作。用户并不直接调用此函数；而是必须调用 Thread 的 start() 函数，该函数再调用 run()（自动自动的）。</p>
<p>但 Java 编程语言只允许一个类有一个父类。同时，所以我们一般避免从 Thread 类导出，因为它强加了类层次。</p>
<h3 id="Runnable-接口"><a href="#Runnable-接口" class="headerlink" title="Runnable 接口"></a>Runnable 接口</h3><p>此接口只有一个函数：run()，此函数必须由实现了此接口的类实现。<br>我个人更喜欢 runnable 接口，因为从 Thread 类继承会强加类层次。<br>当使用 runnable 接口时，您不能直接创建所需类的对象并运行它；必须从 Thread 类的一个实例内部运行它。<code>Thread t1 = new Thread (new ClassImplementsRunnable(XXX, &quot;Threadname&quot;));</code></p>
<h2 id="新特性-线程池"><a href="#新特性-线程池" class="headerlink" title="新特性-线程池"></a>新特性-线程池</h2><p>线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多线程中，所有对象都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个对象，把内容给改乱了。这就是传说中的 <strong>数据竞争（data race）</strong>。数据竞争的存在是Java多线程应用中要解决的首要问题。<br>在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量。这两种机制的提出都是为了实现代码线程的安全性。</p>
<h3 id="锁-amp-synchronized-关键字"><a href="#锁-amp-synchronized-关键字" class="headerlink" title="锁 &amp; synchronized 关键字"></a>锁 &amp; synchronized 关键字</h3><p>在 Java 程序中最简单实现同步的方法就是 <strong>上锁</strong>。为了防止同时访问共享资源，线程在使用资源的前后可以给该资源上锁和开锁。</p>
<p>使用方法（其中之一）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line">       <span class="function"><span class="keyword">synchronized</span> <span class="title">method</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">       method body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>局限性：<br>不能设超时<br>不能中断<br>仅有单一条件</p>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>因为同步的开销很大。<br>Volatile /‘vɒlətaɪl/  是一种免锁机制！<br>当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。</p>
<p>注意：<br>volatile可以用在任何变量前面，但不能用于final变量前面，因为final型的变量是禁止修改的。也不存在线程安全的问题。<br>Volatile /‘vɒlətaɪl/  变量的同步性较差（但有时它更简单并且开销更低），而且其使用也更容易出错。</p>
<h2 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h2><p>在有些情况下，仅依靠线程之间对数据的互斥访问是不够的。有些线程之间存在协作关系，需要按照一定的协议来协同完成某项任务，比如典型的生产者-消费者模式。这种情况下就需要用到Java提供的线程之间的 <strong>等待-通知机制</strong>。</p>
<p>当线程所要求的条件不满足时，就进入等待状态；而另外的线程则负责在合适的时机发出通知来唤醒等待中的线程。</p>
<p>Java中的java.lang.Object类中的<code>wait/notify/notifyAll方</code>法组就是完成线程之间的同步的.</p>
<p>使用注意：</p>
<ul>
<li><code>wait/notify/notifyAll</code>操作需要放在synchronized代码块或方法中，这样才能保证在执行 <code>wait/notify/notifyAll</code>的时候，当前线程已经获得了所需要的锁。</li>
<li>当对于某个对象的等待集合中的线程数目没有把握的时候，最好使用 <code>notifyAll</code>而不是<code>notify</code>。<code>notifyAll</code>虽然会导致线程在没有必要的情况下被唤醒而产生性能影响，但是在使用上更加简单一些。</li>
<li>由于线程可能在非正常情况下被意外唤醒，一般需要把<code>wait</code>操作放在一个循环中，并检查所要求的逻辑条件是否满足。<br>典型的使用模式如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="comment">/* 逻辑条件不满足的时候 */</span>) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           lock.wait();  </span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="常见的问题"><a href="#常见的问题" class="headerlink" title="常见的问题"></a>常见的问题</h2><h3 id="在多线程中，什么是上下文切换-context-switching-？"><a href="#在多线程中，什么是上下文切换-context-switching-？" class="headerlink" title="在多线程中，什么是上下文切换(context-switching)？"></a>在多线程中，什么是上下文切换(context-switching)？</h3><p>上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p>
<h3 id="如何让正在运行的线程暂停一段时间？"><a href="#如何让正在运行的线程暂停一段时间？" class="headerlink" title="如何让正在运行的线程暂停一段时间？"></a>如何让正在运行的线程暂停一段时间？</h3><p>我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。</p>
<h3 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h3><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级</p>
<h3 id="可以直接调用Thread类的run-方法么？"><a href="#可以直接调用Thread类的run-方法么？" class="headerlink" title="可以直接调用Thread类的run()方法么？"></a>可以直接调用Thread类的run()方法么？</h3><p>当然可以，但是不建议，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread.start()方法。</p>
<h3 id="用户线程和守护线程有什么区别？"><a href="#用户线程和守护线程有什么区别？" class="headerlink" title="用户线程和守护线程有什么区别？"></a>用户线程和守护线程有什么区别？</h3><p>当我们在Java程序中创建一个线程，它就被称为用户线程。一个普通线程调用<code>t.setDaemon(ture)</code> 就可以变成守护线程，<br>一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候（只剩下守护线程时），JVM关闭程序并且退出。<br>一个守护线程创建的子线程依然是守护线程。<br>注意 守护线程不要访问固定资源，小心中断！</p>
<h3 id="你如何确保main-方法所在的线程是Java程序最后结束的线程？"><a href="#你如何确保main-方法所在的线程是Java程序最后结束的线程？" class="headerlink" title="你如何确保main()方法所在的线程是Java程序最后结束的线程？"></a>你如何确保main()方法所在的线程是Java程序最后结束的线程？</h3><p>我们可以使用Thread类的<code>joint()</code>方法来确保所有程序创建的线程在<code>main()</code>方法退出前结束。</p>
<h3 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h3><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>
<h3 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal?"></a>什么是ThreadLocal?</h3><p>ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。<br>每个线程都会拥有他们自己的Thread变量，它们可以使用get()\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。</p>
<h3 id="什么是Java-Timer类？如何创建一个有特定时间间隔的任务？"><a href="#什么是Java-Timer类？如何创建一个有特定时间间隔的任务？" class="headerlink" title="什么是Java Timer类？如何创建一个有特定时间间隔的任务？"></a>什么是Java Timer类？如何创建一个有特定时间间隔的任务？</h3><p><code>java.util.Timer</code>是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。<br><code>java.util.TimerTask</code>是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info">Wente Guo</span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info">http://chnwentao.com/2016/03/待整理/Java-总结-多线程/</span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/多线程/">多线程</a></div></article><nav id="pagination"><div class="prev-post pull-left"><a href="/2016/04/大数据工具/Hadoop-转载-The Hadoop Distributed File System/"><i class="fa fa-chevron-left">  </i><span>转载-The Hadoop Distributed File System(译）</span></a></div><div class="next-post pull-right"><a href="/2016/03/待整理/Python3-笔记-多线程与多进程/"><span>python3-多线程与多进程</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">©2015 - 2017 By Wente Guo</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a><span class="footer-separator">|</span><span>Hosted by </span><a href="https://pages.coding.me"><span>Coding Pages</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.3"></script><script src="/js/fancybox.js?version=1.3"></script><script src="/js/sidebar.js?version=1.3"></script><script src="/js/copy.js?version=1.3"></script><script src="/js/fireworks.js?version=1.3"></script><script src="/js/transition.js?version=1.3"></script><script src="/js/scroll.js?version=1.3"></script><script src="/js/head.js?version=1.3"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body></html>